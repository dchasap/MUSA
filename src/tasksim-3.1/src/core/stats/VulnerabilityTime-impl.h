/*
 * Copyright - Barcelona Supercomputing Center.
 * All rights reserved.
 *
 * Redistribution in source and binary forms, with or without
 * modification, is not permitted.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#ifndef STATS_VULNERABILITYSPACE_IMPL_H_
#define STATS_VULNERABILITYSPACE_IMPL_H_

#include <cmath>
#include <iomanip>
#include <unistd.h>

namespace sim {
namespace stats {

template<typename T>
inline
VulnerabilityTime::VulnerabilityTime(const T &obj, const std::string &name, unsigned num_bits_ignored,
                                     engine::cycles_t stat_period, engine::addr_t stat_granularity,
                                     const std::string &range_map) :
        VulnerabilityStat(obj, name, num_bits_ignored, stat_period, stat_granularity, range_map),
        data_(),
        memory_map_(),
        cur_period_(0),
        start_period_(0),
        end_period_(stat_period)
{
}

inline
VulnerabilityTime::~VulnerabilityTime()
{
    char f[] = "vulnerability.XXXXXX";
    int fd = mkstemp(f);
    if (fd < 0) {
        std::cerr << "[TASKSIM ERROR] Unable to create output file for vulnerability statistics " << f << std::endl;
        exit(-1);
    }

    std::ofstream data_out(f);
    close(fd);
    Stat::out_ << this->name_ << ":" << this->class_ << ":" << this->id_ << std::endl;
    Stat::out_ << "time:" << sizeof(engine::cycles_t) << ":address:" << sizeof(engine::addr_t)
               << ":safe_ratio:" << sizeof(float) << std::endl;
    Stat::out_ << "addr_grain:" << (~this->address_mask_)+1 << ":map_size:" << map_size_ << ":stat_period:" << this->stat_period_
               << ":end_stats:" << this->end_time_ << std::endl;
    Stat::out_ << "filename:" << f << std::endl;

    std::map<unsigned, size_t> range_sizes;
    std::map<unsigned, std::vector<engine::addr_t>> range_addrs;
    for (auto &period_data: data_) {
        for (auto &address_avg_pair: period_data) {
            int range_index = this->range_map_.get_range_index(address_avg_pair.first);
            if (range_index < 0) {
                range_index = this->range_map_.get_range_index(address_avg_pair.first + ~this->stat_mask_);
                assert(static_cast<size_t>(range_index) < this->range_map_.size());
            }
            range_sizes[range_index] += address_avg_pair.second.nterms;
            range_addrs[range_index].push_back(address_avg_pair.first);
        }
    }

    size_t n_periods = data_.size();
    for (auto &range_size_pair: range_sizes) {
        if (!range_size_pair.second) {
            continue;
        }
        data_out << this->range_map_.name_at(range_size_pair.first);
        for (size_t n = 1; n < n_periods; n++) {
            data_out << " " << n * this->stat_period_;
        }
        data_out << " " << this->end_time_ << '\n';

        for (auto address: range_addrs[range_size_pair.first]) {
            data_out << std::hex << address << std::dec;
            for (size_t n = 0; n < n_periods; n++) {
                auto value = data_[n].find(address);
                if (value == data_[n].end()) {
                    data_out << " 0";
                }
                else {
                    data_out << ' ' << value->second.mean[0];
                    for (size_t i = 1; i < MAX; i++) {
                        data_out << ',' << value->second.mean[i];
                    }
                    data_[n].erase(value);
                }
            }
            data_out << '\n';
        }
        data_out << '\n';
    }
}

inline
void VulnerabilityTime::aggregate(engine::addr_t address, engine::cycles_t period, double ratios[MAX])
{
    if (period >= data_.size()) {
        data_.resize(period + 1);
    }
    average_t &avg = data_[period][address & this->stat_mask_];
    avg.nterms++;
    for (size_t i = 0; i < MAX; i++) {
        avg.mean[i] += (ratios[i] - avg.mean[i]) / avg.nterms;
        assert(!std::isnan(avg.mean[i]));
    }
}

inline
void VulnerabilityTime::periodic_output(engine::addr_t address, address_stats_t &A, engine::cycles_t time,
                                                         bool safe, safe_reason_t safe_reason)
{
    if (this->stat_period_ == 0) return;

    if (time > end_period_) {
        cur_period_ = time / this->stat_period_;
        start_period_ = cur_period_ - time % this->stat_period_;
        end_period_ = start_period_ + this->stat_period_;
    }

    if (A.last < start_period_) {
        engine::cycles_t period = A.last / this->stat_period_;
        engine::cycles_t inside = A.last % this->stat_period_;

        // Advance until end of period corresponding to A.last, aggregate() it
        if (safe) {
            A.duration[safe_reason] += this->stat_period_ - inside;
        }

        const double stat_period = this->stat_period_;
        double ratios[MAX];
        for (size_t i = 0; i < MAX; i++) {
            ratios[i] = A.duration[i] / stat_period;
        }
        aggregate(address, period, ratios);

        // Advance full periods until current period
        memset(ratios, 0, sizeof(ratios));
        if (safe) {
            ratios[safe_reason] = 1.;
        }
        while (++period < cur_period_) {
            aggregate(address, period, ratios);
        }

        // Update address stats with changes operated
        memset(A.duration, 0, sizeof(A.duration));
        A.last = start_period_;
    }
}

inline
void VulnerabilityTime::mem_access(engine::cycles_t time, sim::logic::coherence::single::Request &req)
{
    // NB : A will be zero initialized if 'address & this->address_mask_' is not in map
    engine::addr_t address = req.get_tag() & this->address_mask_;

    if (this->range_map_.get_range_index(address) < 0) {
        return;
    }

    address_stats_t &A = memory_map_[address];
    safe_reason_t safe_reason = safe_reason_t::MAX;
    bool safe = false;

    if (req.get_op() == sim::logic::coherence::single::req_op_t::WRITE) {
        safe = true;
        safe_reason = safe_reason_t::STORE;
    } else if (req.is_fill()) {
        safe = true;
        safe_reason = safe_reason_t::OVERWRITE_FETCH;
    }

    periodic_output(address, A, time, safe, safe_reason);

    if (safe) {
        A.duration[safe_reason] += time - A.last;
    }

    A.last = time;
}

inline
void VulnerabilityTime::finalize(engine::cycles_t time)
{
    this->end_time_ = time;
    map_size_ = memory_map_.size();

    const double last_duration = this->stat_period_ > 0 ? (time % this->stat_period_) : time;
    const engine::cycles_t last_period = this->stat_period_ > 0 ? time / this->stat_period_ : 0;

    for (auto it = memory_map_.begin(); it != memory_map_.end(); it = memory_map_.erase(it)) {
        periodic_output(it->first, it->second, time, true, END_PROGRAM);

        if (last_duration) {
            double ratios[MAX];
            for (size_t i = 0; i < END_PROGRAM; i++) {
                ratios[i] = it->second.duration[i] / last_duration;
            }
            ratios[END_PROGRAM] = (it->second.duration[END_PROGRAM] + (time - it->second.last)) / last_duration;
            aggregate(it->first, last_period, ratios);
        }
    }
}

}
}

#endif // STATS_VULNERABILITYSPACE_IMPL_H_
