#ifndef TL_NODECL_VISITOR_CPP
#define TL_NODECL_VISITOR_CPP
/* Autogenerated file. DO NOT MODIFY. */
/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */
#include <tl-nodecl-visitor.hpp>
#include <tl-nodecl.hpp>
#include "cxx-utils.h"
#include "mem.h"

namespace Nodecl {

BaseNodeclVisitor<void>::Ret BaseNodeclVisitor<void>::walk(const NodeclBase& n)
{

    if (n.is_null())
        return;
    switch ((int)n.get_kind())
    {
        case AST_NODE_LIST: { AST tree = nodecl_get_ast(n._n); AST it; for_each_element(tree, it) { AST elem = ASTSon1(it);
NodeclBase nb(::_nodecl_wrap(elem)); this->walk(nb); } break; }

       case NODECL_VECTOR_FMADD: { this->visit(static_cast<const Nodecl::VectorFmadd &>(n)); break; }
       case NODECL_VECTOR_DIFFERENT: { this->visit(static_cast<const Nodecl::VectorDifferent &>(n)); break; }
       case NODECL_OPEN_M_P_CRITICAL_NAME: { this->visit(static_cast<const Nodecl::OpenMP::CriticalName &>(n)); break; }
       case NODECL_LOGICAL_NOT: { this->visit(static_cast<const Nodecl::LogicalNot &>(n)); break; }
       case NODECL_STRUCTURED_VALUE: { this->visit(static_cast<const Nodecl::StructuredValue &>(n)); break; }
       case NODECL_VECTOR_BITWISE_NOT: { this->visit(static_cast<const Nodecl::VectorBitwiseNot &>(n)); break; }
       case NODECL_C99_DESIGNATED_INITIALIZER: { this->visit(static_cast<const Nodecl::C99DesignatedInitializer &>(n)); break; }
       case NODECL_VECTOR_ARITHMETIC_SHR: { this->visit(static_cast<const Nodecl::VectorArithmeticShr &>(n)); break; }
       case NODECL_OPEN_M_P_DIST_SCHEDULE: { this->visit(static_cast<const Nodecl::OpenMP::DistSchedule &>(n)); break; }
       case NODECL_OPEN_M_P_TASKWAIT: { this->visit(static_cast<const Nodecl::OpenMP::Taskwait &>(n)); break; }
       case NODECL_OMP_SS_NAME: { this->visit(static_cast<const Nodecl::OmpSs::Name &>(n)); break; }
       case NODECL_OPEN_M_P_PARALLEL_SIMD_FOR: { this->visit(static_cast<const Nodecl::OpenMP::ParallelSimdFor &>(n)); break; }
       case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_OUT_POINTED: { this->visit(static_cast<const Nodecl::Analysis::Correctness::IncoherentOutPointed &>(n)); break; }
       case NODECL_FORTRAN_ALLOCATE_STATEMENT: { this->visit(static_cast<const Nodecl::FortranAllocateStatement &>(n)); break; }
       case NODECL_OMP_SS_DEP_WEAK_REDUCTION: { this->visit(static_cast<const Nodecl::OmpSs::DepWeakReduction &>(n)); break; }
       case NODECL_VECTOR_RSQRT: { this->visit(static_cast<const Nodecl::VectorRsqrt &>(n)); break; }
       case NODECL_ANALYSIS_PLUS_INFINITY: { this->visit(static_cast<const Nodecl::Analysis::PlusInfinity &>(n)); break; }
       case NODECL_VECTOR_SQRT: { this->visit(static_cast<const Nodecl::VectorSqrt &>(n)); break; }
       case NODECL_STRUCTURED_VALUE_COMPOUND_LITERAL: { this->visit(static_cast<const Nodecl::StructuredValueCompoundLiteral &>(n)); break; }
       case NODECL_FORTRAN_DEALLOCATE_STATEMENT: { this->visit(static_cast<const Nodecl::FortranDeallocateStatement &>(n)); break; }
       case NODECL_OPEN_M_P_SIMD_FOR: { this->visit(static_cast<const Nodecl::OpenMP::SimdFor &>(n)); break; }
       case NODECL_BITWISE_AND: { this->visit(static_cast<const Nodecl::BitwiseAnd &>(n)); break; }
       case NODECL_VECTOR_FABS: { this->visit(static_cast<const Nodecl::VectorFabs &>(n)); break; }
       case NODECL_TRY_BLOCK: { this->visit(static_cast<const Nodecl::TryBlock &>(n)); break; }
       case NODECL_STRUCTURED_VALUE_BRACED_TYPECAST: { this->visit(static_cast<const Nodecl::StructuredValueBracedTypecast &>(n)); break; }
       case NODECL_OMP_SS_SH_MEM: { this->visit(static_cast<const Nodecl::OmpSs::ShMem &>(n)); break; }
       case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_P: { this->visit(static_cast<const Nodecl::Analysis::Correctness::IncoherentP &>(n)); break; }
       case NODECL_VECTOR_SCATTER: { this->visit(static_cast<const Nodecl::VectorScatter &>(n)); break; }
       case NODECL_VECTOR_PREFETCH: { this->visit(static_cast<const Nodecl::VectorPrefetch &>(n)); break; }
       case NODECL_OMP_SS_TASK_IS_TASK_CALL: { this->visit(static_cast<const Nodecl::OmpSs::TaskIsTaskCall &>(n)); break; }
       case NODECL_NONTEMPORAL_FLAG: { this->visit(static_cast<const Nodecl::NontemporalFlag &>(n)); break; }
       case NODECL_FORTRAN_DATA: { this->visit(static_cast<const Nodecl::FortranData &>(n)); break; }
       case NODECL_OPEN_M_P_UNIFORM: { this->visit(static_cast<const Nodecl::OpenMP::Uniform &>(n)); break; }
       case NODECL_VECTOR_LITERAL: { this->visit(static_cast<const Nodecl::VectorLiteral &>(n)); break; }
       case NODECL_OPEN_M_P_BARRIER_SIGNAL: { this->visit(static_cast<const Nodecl::OpenMP::BarrierSignal &>(n)); break; }
       case NODECL_ANALYSIS_UPPER_EXPOSED: { this->visit(static_cast<const Nodecl::Analysis::UpperExposed &>(n)); break; }
       case NODECL_OPEN_M_P_TASK_REDUCTION: { this->visit(static_cast<const Nodecl::OpenMP::TaskReduction &>(n)); break; }
       case NODECL_VECTOR_LOOP: { this->visit(static_cast<const Nodecl::VectorLoop &>(n)); break; }
       case NODECL_CHECKPOINT_DATA: { this->visit(static_cast<const Nodecl::Checkpoint::Data &>(n)); break; }
       case NODECL_CXX_CAPTURE_COPY: { this->visit(static_cast<const Nodecl::CxxCaptureCopy &>(n)); break; }
       case NODECL_OPEN_M_P_VECTOR_LENGTH_FOR: { this->visit(static_cast<const Nodecl::OpenMP::VectorLengthFor &>(n)); break; }
       case NODECL_ANALYSIS_UNDEFINED: { this->visit(static_cast<const Nodecl::Analysis::Undefined &>(n)); break; }
       case NODECL_OMP_SS_RELEASE: { this->visit(static_cast<const Nodecl::OmpSs::Release &>(n)); break; }
       case NODECL_INTEGER_LITERAL: { this->visit(static_cast<const Nodecl::IntegerLiteral &>(n)); break; }
       case NODECL_CHECKPOINT_COMM: { this->visit(static_cast<const Nodecl::Checkpoint::Comm &>(n)); break; }
       case NODECL_VECTOR_LOGICAL_NOT: { this->visit(static_cast<const Nodecl::VectorLogicalNot &>(n)); break; }
       case NODECL_CXX_FUNCTION_FORM_DEFAULT_INIT: { this->visit(static_cast<const Nodecl::CxxFunctionFormDefaultInit &>(n)); break; }
       case NODECL_EQUAL: { this->visit(static_cast<const Nodecl::Equal &>(n)); break; }
       case NODECL_ANALYSIS_RANGE_SUB: { this->visit(static_cast<const Nodecl::Analysis::RangeSub &>(n)); break; }
       case NODECL_CXX_ARROW_PTR_MEMBER: { this->visit(static_cast<const Nodecl::CxxArrowPtrMember &>(n)); break; }
       case NODECL_OPEN_M_P_UNROLL: { this->visit(static_cast<const Nodecl::OpenMP::Unroll &>(n)); break; }
       case NODECL_OPEN_M_P_OVERLAP: { this->visit(static_cast<const Nodecl::OpenMP::Overlap &>(n)); break; }
       case NODECL_DUMMY: { this->visit(static_cast<const Nodecl::Dummy &>(n)); break; }
       case NODECL_OPEN_M_P_FOR: { this->visit(static_cast<const Nodecl::OpenMP::For &>(n)); break; }
       case NODECL_FORTRAN_PRINT_STATEMENT: { this->visit(static_cast<const Nodecl::FortranPrintStatement &>(n)); break; }
       case NODECL_OPEN_M_P_TARGET_DATA: { this->visit(static_cast<const Nodecl::OpenMP::TargetData &>(n)); break; }
       case NODECL_OMP_SS_DEP_WEAK_IN: { this->visit(static_cast<const Nodecl::OmpSs::DepWeakIn &>(n)); break; }
       case NODECL_ARITHMETIC_SHR: { this->visit(static_cast<const Nodecl::ArithmeticShr &>(n)); break; }
       case NODECL_VECTOR_REDUCTION_MINUS: { this->visit(static_cast<const Nodecl::VectorReductionMinus &>(n)); break; }
       case NODECL_OMP_SS_WEAK_REDUCTION: { this->visit(static_cast<const Nodecl::OmpSs::WeakReduction &>(n)); break; }
       case NODECL_IN_PLACE_FLAG: { this->visit(static_cast<const Nodecl::InPlaceFlag &>(n)); break; }
       case NODECL_OPEN_M_P_FLUSH_MEMORY: { this->visit(static_cast<const Nodecl::OpenMP::FlushMemory &>(n)); break; }
       case NODECL_OPEN_M_P_MAP_FROM: { this->visit(static_cast<const Nodecl::OpenMP::MapFrom &>(n)); break; }
       case NODECL_OPEN_M_P_VECTOR_LENGTH: { this->visit(static_cast<const Nodecl::OpenMP::VectorLength &>(n)); break; }
       case NODECL_DEREFERENCE: { this->visit(static_cast<const Nodecl::Dereference &>(n)); break; }
       case NODECL_CATCH_HANDLER: { this->visit(static_cast<const Nodecl::CatchHandler &>(n)); break; }
       case NODECL_FORTRAN_ASSIGNED_GOTO_STATEMENT: { this->visit(static_cast<const Nodecl::FortranAssignedGotoStatement &>(n)); break; }
       case NODECL_CXX_CAST: { this->visit(static_cast<const Nodecl::CxxCast &>(n)); break; }
       case NODECL_PRAGMA_CUSTOM_CLAUSE: { this->visit(static_cast<const Nodecl::PragmaCustomClause &>(n)); break; }
       case NODECL_UNBOUNDED_LOOP_CONTROL: { this->visit(static_cast<const Nodecl::UnboundedLoopControl &>(n)); break; }
       case NODECL_OPEN_M_P_BARRIER_AT_END: { this->visit(static_cast<const Nodecl::OpenMP::BarrierAtEnd &>(n)); break; }
       case NODECL_FORTRAN_WHERE_PAIR: { this->visit(static_cast<const Nodecl::FortranWherePair &>(n)); break; }
       case NODECL_OPEN_M_P_NUM_TASKS: { this->visit(static_cast<const Nodecl::OpenMP::NumTasks &>(n)); break; }
       case NODECL_OPEN_M_P_WORKSHARE: { this->visit(static_cast<const Nodecl::OpenMP::Workshare &>(n)); break; }
       case NODECL_OPEN_M_P_MOTION_TO: { this->visit(static_cast<const Nodecl::OpenMP::MotionTo &>(n)); break; }
       case NODECL_OPEN_M_P_DISTRIBUTE: { this->visit(static_cast<const Nodecl::OpenMP::Distribute &>(n)); break; }
       case NODECL_OPEN_M_P_PRIVATE: { this->visit(static_cast<const Nodecl::OpenMP::Private &>(n)); break; }
       case NODECL_OPEN_M_P_SIMD: { this->visit(static_cast<const Nodecl::OpenMP::Simd &>(n)); break; }
       case NODECL_STRUCTURED_VALUE_FORTRAN_TYPESPEC_ARRAY_CONSTRUCTOR: { this->visit(static_cast<const Nodecl::StructuredValueFortranTypespecArrayConstructor &>(n)); break; }
       case NODECL_INTEL_ASSUME: { this->visit(static_cast<const Nodecl::IntelAssume &>(n)); break; }
       case NODECL_CXX_DEP_NAME_NESTED: { this->visit(static_cast<const Nodecl::CxxDepNameNested &>(n)); break; }
       case NODECL_OPEN_M_P_PRIVATE_INIT: { this->visit(static_cast<const Nodecl::OpenMP::PrivateInit &>(n)); break; }
       case NODECL_NEW: { this->visit(static_cast<const Nodecl::New &>(n)); break; }
       case NODECL_PREINCREMENT: { this->visit(static_cast<const Nodecl::Preincrement &>(n)); break; }
       case NODECL_VECTOR_MASK_AND: { this->visit(static_cast<const Nodecl::VectorMaskAnd &>(n)); break; }
       case NODECL_VECTOR_MASK_OR: { this->visit(static_cast<const Nodecl::VectorMaskOr &>(n)); break; }
       case NODECL_OPEN_M_P_REDUCTION: { this->visit(static_cast<const Nodecl::OpenMP::Reduction &>(n)); break; }
       case NODECL_CXX_PARSE_LATER: { this->visit(static_cast<const Nodecl::CxxParseLater &>(n)); break; }
       case NODECL_OMP_SS_N_D_RANGE: { this->visit(static_cast<const Nodecl::OmpSs::NDRange &>(n)); break; }
       case NODECL_FORTRAN_ENTRY_STATEMENT: { this->visit(static_cast<const Nodecl::FortranEntryStatement &>(n)); break; }
       case NODECL_OPEN_M_P_PRIORITY: { this->visit(static_cast<const Nodecl::OpenMP::Priority &>(n)); break; }
       case NODECL_VECTOR_BITWISE_XOR: { this->visit(static_cast<const Nodecl::VectorBitwiseXor &>(n)); break; }
       case NODECL_COMPOUND_EXPRESSION: { this->visit(static_cast<const Nodecl::CompoundExpression &>(n)); break; }
       case NODECL_OMP_SS_REGISTER: { this->visit(static_cast<const Nodecl::OmpSs::Register &>(n)); break; }
       case NODECL_FORTRAN_PAUSE_STATEMENT: { this->visit(static_cast<const Nodecl::FortranPauseStatement &>(n)); break; }
       case NODECL_VECTOR_MASK_CONVERSION: { this->visit(static_cast<const Nodecl::VectorMaskConversion &>(n)); break; }
       case NODECL_CLASS_MEMBER_ACCESS: { this->visit(static_cast<const Nodecl::ClassMemberAccess &>(n)); break; }
       case NODECL_OPEN_M_P_REDUCTION_ITEM: { this->visit(static_cast<const Nodecl::OpenMP::ReductionItem &>(n)); break; }
       case NODECL_CXX_FUNCTION_FORM_UNARY_PREFIX: { this->visit(static_cast<const Nodecl::CxxFunctionFormUnaryPrefix &>(n)); break; }
       case NODECL_OPEN_M_P_IF: { this->visit(static_cast<const Nodecl::OpenMP::If &>(n)); break; }
       case NODECL_FORTRAN_COMPUTED_GOTO_STATEMENT: { this->visit(static_cast<const Nodecl::FortranComputedGotoStatement &>(n)); break; }
       case NODECL_MINUS: { this->visit(static_cast<const Nodecl::Minus &>(n)); break; }
       case NODECL_VECTOR_LOGICAL_AND: { this->visit(static_cast<const Nodecl::VectorLogicalAnd &>(n)); break; }
       case NODECL_EVICT_FLAG: { this->visit(static_cast<const Nodecl::EvictFlag &>(n)); break; }
       case NODECL_BITWISE_OR_ASSIGNMENT: { this->visit(static_cast<const Nodecl::BitwiseOrAssignment &>(n)); break; }
       case NODECL_OMP_SS_DEP_COMMUTATIVE: { this->visit(static_cast<const Nodecl::OmpSs::DepCommutative &>(n)); break; }
       case NODECL_COMPOUND_STATEMENT: { this->visit(static_cast<const Nodecl::CompoundStatement &>(n)); break; }
       case NODECL_OMP_SS_UNREGISTER: { this->visit(static_cast<const Nodecl::OmpSs::Unregister &>(n)); break; }
       case NODECL_FLOATING_LITERAL: { this->visit(static_cast<const Nodecl::FloatingLiteral &>(n)); break; }
       case NODECL_VECTOR_SUBSCRIPT: { this->visit(static_cast<const Nodecl::VectorSubscript &>(n)); break; }
       case NODECL_PRAGMA_CUSTOM_LINE: { this->visit(static_cast<const Nodecl::PragmaCustomLine &>(n)); break; }
       case NODECL_PLUS: { this->visit(static_cast<const Nodecl::Plus &>(n)); break; }
       case NODECL_OMP_SS_COPY_INOUT: { this->visit(static_cast<const Nodecl::OmpSs::CopyInout &>(n)); break; }
       case NODECL_OPEN_M_P_MAP_TO: { this->visit(static_cast<const Nodecl::OpenMP::MapTo &>(n)); break; }
       case NODECL_VECTOR_LOGICAL_OR: { this->visit(static_cast<const Nodecl::VectorLogicalOr &>(n)); break; }
       case NODECL_OPEN_M_P_COMBINED_WITH_PARALLEL: { this->visit(static_cast<const Nodecl::OpenMP::CombinedWithParallel &>(n)); break; }
       case NODECL_VECTOR_SINCOS: { this->visit(static_cast<const Nodecl::VectorSincos &>(n)); break; }
       case NODECL_DELETE: { this->visit(static_cast<const Nodecl::Delete &>(n)); break; }
       case NODECL_OMP_SS_ALLOCA: { this->visit(static_cast<const Nodecl::OmpSs::Alloca &>(n)); break; }
       case NODECL_ANALYSIS_DEFINED: { this->visit(static_cast<const Nodecl::Analysis::Defined &>(n)); break; }
       case NODECL_OMP_SS_TARGET: { this->visit(static_cast<const Nodecl::OmpSs::Target &>(n)); break; }
       case NODECL_CONDITIONAL_EXPRESSION: { this->visit(static_cast<const Nodecl::ConditionalExpression &>(n)); break; }
       case NODECL_BITWISE_AND_ASSIGNMENT: { this->visit(static_cast<const Nodecl::BitwiseAndAssignment &>(n)); break; }
       case NODECL_CXX_SIZEOF_PACK: { this->visit(static_cast<const Nodecl::CxxSizeofPack &>(n)); break; }
       case NODECL_OPEN_M_P_FLUSH_AT_ENTRY: { this->visit(static_cast<const Nodecl::OpenMP::FlushAtEntry &>(n)); break; }
       case NODECL_OMP_SS_FILE: { this->visit(static_cast<const Nodecl::OmpSs::File &>(n)); break; }
       case NODECL_MASK_LITERAL: { this->visit(static_cast<const Nodecl::MaskLiteral &>(n)); break; }
       case NODECL_VECTOR_LANE_ID: { this->visit(static_cast<const Nodecl::VectorLaneId &>(n)); break; }
       case NODECL_CONTINUE_STATEMENT: { this->visit(static_cast<const Nodecl::ContinueStatement &>(n)); break; }
       case NODECL_OPEN_M_P_MASK: { this->visit(static_cast<const Nodecl::OpenMP::Mask &>(n)); break; }
       case NODECL_BOOLEAN_LITERAL: { this->visit(static_cast<const Nodecl::BooleanLiteral &>(n)); break; }
       case NODECL_CXX_DOT_PTR_MEMBER: { this->visit(static_cast<const Nodecl::CxxDotPtrMember &>(n)); break; }
       case NODECL_INTEL_ASSUME_ALIGNED: { this->visit(static_cast<const Nodecl::IntelAssumeAligned &>(n)); break; }
       case NODECL_BITWISE_OR: { this->visit(static_cast<const Nodecl::BitwiseOr &>(n)); break; }
       case NODECL_OMP_SS_DEP_WEAK_OUT: { this->visit(static_cast<const Nodecl::OmpSs::DepWeakOut &>(n)); break; }
       case NODECL_OPEN_M_P_DEP_IN: { this->visit(static_cast<const Nodecl::OpenMP::DepIn &>(n)); break; }
       case NODECL_REAL_PART: { this->visit(static_cast<const Nodecl::RealPart &>(n)); break; }
       case NODECL_OPEN_M_P_TASKYIELD: { this->visit(static_cast<const Nodecl::OpenMP::Taskyield &>(n)); break; }
       case NODECL_CXX_LAMBDA: { this->visit(static_cast<const Nodecl::CxxLambda &>(n)); break; }
       case NODECL_STRING_LITERAL: { this->visit(static_cast<const Nodecl::StringLiteral &>(n)); break; }
       case NODECL_TYPEID: { this->visit(static_cast<const Nodecl::Typeid &>(n)); break; }
       case NODECL_OMP_SS_COPY_OUT: { this->visit(static_cast<const Nodecl::OmpSs::CopyOut &>(n)); break; }
       case NODECL_ANALYSIS_CORRECTNESS_AUTO_STORAGE: { this->visit(static_cast<const Nodecl::Analysis::Correctness::AutoStorage &>(n)); break; }
       case NODECL_PRAGMA_CUSTOM_DIRECTIVE: { this->visit(static_cast<const Nodecl::PragmaCustomDirective &>(n)); break; }
       case NODECL_CXX_DEP_DECLTYPE: { this->visit(static_cast<const Nodecl::CxxDepDecltype &>(n)); break; }
       case NODECL_OMP_SS_CHUNKSIZE: { this->visit(static_cast<const Nodecl::OmpSs::Chunksize &>(n)); break; }
       case NODECL_OPEN_M_P_FOR_APPENDIX: { this->visit(static_cast<const Nodecl::OpenMP::ForAppendix &>(n)); break; }
       case NODECL_OPEN_M_P_UNTIED: { this->visit(static_cast<const Nodecl::OpenMP::Untied &>(n)); break; }
       case NODECL_ANALYSIS_MAXIMUM: { this->visit(static_cast<const Nodecl::Analysis::Maximum &>(n)); break; }
       case NODECL_CHECKPOINT_KIND: { this->visit(static_cast<const Nodecl::Checkpoint::Kind &>(n)); break; }
       case NODECL_VECTOR_CONVERSION: { this->visit(static_cast<const Nodecl::VectorConversion &>(n)); break; }
       case NODECL_SYMBOL: { this->visit(static_cast<const Nodecl::Symbol &>(n)); break; }
       case NODECL_CXX_ALIGNOF: { this->visit(static_cast<const Nodecl::CxxAlignof &>(n)); break; }
       case NODECL_OPEN_M_P_THREADPRIVATE: { this->visit(static_cast<const Nodecl::OpenMP::Threadprivate &>(n)); break; }
       case NODECL_GREATER_OR_EQUAL_THAN: { this->visit(static_cast<const Nodecl::GreaterOrEqualThan &>(n)); break; }
       case NODECL_TYPE: { this->visit(static_cast<const Nodecl::Type &>(n)); break; }
       case NODECL_C99_FIELD_DESIGNATOR: { this->visit(static_cast<const Nodecl::C99FieldDesignator &>(n)); break; }
       case NODECL_GCC_ASM_DEFINITION: { this->visit(static_cast<const Nodecl::GccAsmDefinition &>(n)); break; }
       case NODECL_CXX_DEP_GLOBAL_NAME_NESTED: { this->visit(static_cast<const Nodecl::CxxDepGlobalNameNested &>(n)); break; }
       case NODECL_REFERENCE: { this->visit(static_cast<const Nodecl::Reference &>(n)); break; }
       case NODECL_FORTRAN_OPEN_STATEMENT: { this->visit(static_cast<const Nodecl::FortranOpenStatement &>(n)); break; }
       case NODECL_CXX_FUNCTION_FORM_UNARY_POSTFIX: { this->visit(static_cast<const Nodecl::CxxFunctionFormUnaryPostfix &>(n)); break; }
       case NODECL_TOP_LEVEL: { this->visit(static_cast<const Nodecl::TopLevel &>(n)); break; }
       case NODECL_VECTOR_MASK_ASSIGNMENT: { this->visit(static_cast<const Nodecl::VectorMaskAssignment &>(n)); break; }
       case NODECL_CHECKPOINT_STORE: { this->visit(static_cast<const Nodecl::Checkpoint::Store &>(n)); break; }
       case NODECL_OPEN_M_P_TASKGROUP: { this->visit(static_cast<const Nodecl::OpenMP::Taskgroup &>(n)); break; }
       case NODECL_POSTINCREMENT: { this->visit(static_cast<const Nodecl::Postincrement &>(n)); break; }
       case NODECL_OPEN_M_P_IN_REDUCTION: { this->visit(static_cast<const Nodecl::OpenMP::InReduction &>(n)); break; }
       case NODECL_THROW: { this->visit(static_cast<const Nodecl::Throw &>(n)); break; }
       case NODECL_PRAGMA_CUSTOM_DECLARATION: { this->visit(static_cast<const Nodecl::PragmaCustomDeclaration &>(n)); break; }
       case NODECL_TEMPLATE_FUNCTION_CODE: { this->visit(static_cast<const Nodecl::TemplateFunctionCode &>(n)); break; }
       case NODECL_CXX_NOEXCEPT: { this->visit(static_cast<const Nodecl::CxxNoexcept &>(n)); break; }
       case NODECL_OPEN_M_P_NO_PREFETCH: { this->visit(static_cast<const Nodecl::OpenMP::NoPrefetch &>(n)); break; }
       case NODECL_ANALYSIS_MINIMUM: { this->visit(static_cast<const Nodecl::Analysis::Minimum &>(n)); break; }
       case NODECL_VECTOR_STORE: { this->visit(static_cast<const Nodecl::VectorStore &>(n)); break; }
       case NODECL_OPEN_M_P_MOTION_FROM: { this->visit(static_cast<const Nodecl::OpenMP::MotionFrom &>(n)); break; }
       case NODECL_LOOP_CONTROL: { this->visit(static_cast<const Nodecl::LoopControl &>(n)); break; }
       case NODECL_OMP_SS_ONTO: { this->visit(static_cast<const Nodecl::OmpSs::Onto &>(n)); break; }
       case NODECL_CXX_DECL: { this->visit(static_cast<const Nodecl::CxxDecl &>(n)); break; }
       case NODECL_TEXT: { this->visit(static_cast<const Nodecl::Text &>(n)); break; }
       case NODECL_EMPTY_STATEMENT: { this->visit(static_cast<const Nodecl::EmptyStatement &>(n)); break; }
       case NODECL_ALIGNMENT_INFO: { this->visit(static_cast<const Nodecl::AlignmentInfo &>(n)); break; }
       case NODECL_OPEN_M_P_LINEAR: { this->visit(static_cast<const Nodecl::OpenMP::Linear &>(n)); break; }
       case NODECL_DO_STATEMENT: { this->visit(static_cast<const Nodecl::DoStatement &>(n)); break; }
       case NODECL_OPEN_M_P_UNROLL_AND_JAM: { this->visit(static_cast<const Nodecl::OpenMP::UnrollAndJam &>(n)); break; }
       case NODECL_ASSIGNMENT: { this->visit(static_cast<const Nodecl::Assignment &>(n)); break; }
       case NODECL_OPEN_M_P_TEAMS: { this->visit(static_cast<const Nodecl::OpenMP::Teams &>(n)); break; }
       case NODECL_GXX_TRAIT: { this->visit(static_cast<const Nodecl::GxxTrait &>(n)); break; }
       case NODECL_FORTRAN_USE_ONLY: { this->visit(static_cast<const Nodecl::FortranUseOnly &>(n)); break; }
       case NODECL_ANALYSIS_AUTO_SCOPE_FIRSTPRIVATE: { this->visit(static_cast<const Nodecl::Analysis::AutoScope::Firstprivate &>(n)); break; }
       case NODECL_ANALYSIS_LIVE_IN: { this->visit(static_cast<const Nodecl::Analysis::LiveIn &>(n)); break; }
       case NODECL_ANALYSIS_REACHING_DEFINITION_OUT: { this->visit(static_cast<const Nodecl::Analysis::ReachingDefinitionOut &>(n)); break; }
       case NODECL_FORTRAN_EQUIVALENCE: { this->visit(static_cast<const Nodecl::FortranEquivalence &>(n)); break; }
       case NODECL_VECTOR_EQUAL: { this->visit(static_cast<const Nodecl::VectorEqual &>(n)); break; }
       case NODECL_FORTRAN_ACTUAL_ARGUMENT: { this->visit(static_cast<const Nodecl::FortranActualArgument &>(n)); break; }
       case NODECL_ON_TOP_FLAG: { this->visit(static_cast<const Nodecl::OnTopFlag &>(n)); break; }
       case NODECL_SIZEOF: { this->visit(static_cast<const Nodecl::Sizeof &>(n)); break; }
       case NODECL_CXX_EXPLICIT_INSTANTIATION_DEF: { this->visit(static_cast<const Nodecl::CxxExplicitInstantiationDef &>(n)); break; }
       case NODECL_CHECKPOINT_INIT: { this->visit(static_cast<const Nodecl::Checkpoint::Init &>(n)); break; }
       case NODECL_FORTRAN_BOZ_LITERAL: { this->visit(static_cast<const Nodecl::FortranBozLiteral &>(n)); break; }
       case NODECL_VECTOR_LOWER_THAN: { this->visit(static_cast<const Nodecl::VectorLowerThan &>(n)); break; }
       case NODECL_OPEN_M_P_SCHEDULE: { this->visit(static_cast<const Nodecl::OpenMP::Schedule &>(n)); break; }
       case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_IN: { this->visit(static_cast<const Nodecl::Analysis::Correctness::IncoherentIn &>(n)); break; }
       case NODECL_VECTOR_GREATER_THAN: { this->visit(static_cast<const Nodecl::VectorGreaterThan &>(n)); break; }
       case NODECL_VIRTUAL_FUNCTION_CALL: { this->visit(static_cast<const Nodecl::VirtualFunctionCall &>(n)); break; }
       case NODECL_OPEN_M_P_SINGLE: { this->visit(static_cast<const Nodecl::OpenMP::Single &>(n)); break; }
       case NODECL_POINTER_TO_MEMBER: { this->visit(static_cast<const Nodecl::PointerToMember &>(n)); break; }
       case NODECL_IF_ELSE_STATEMENT: { this->visit(static_cast<const Nodecl::IfElseStatement &>(n)); break; }
       case NODECL_CXX_CAPTURE_REFERENCE: { this->visit(static_cast<const Nodecl::CxxCaptureReference &>(n)); break; }
       case NODECL_LOWER_OR_EQUAL_THAN: { this->visit(static_cast<const Nodecl::LowerOrEqualThan &>(n)); break; }
       case NODECL_GCC_ASM_OPERAND: { this->visit(static_cast<const Nodecl::GccAsmOperand &>(n)); break; }
       case NODECL_ARRAY_SUBSCRIPT: { this->visit(static_cast<const Nodecl::ArraySubscript &>(n)); break; }
       case NODECL_VECTOR_LOWER_OR_EQUAL_THAN: { this->visit(static_cast<const Nodecl::VectorLowerOrEqualThan &>(n)); break; }
       case NODECL_VECTOR_DIV: { this->visit(static_cast<const Nodecl::VectorDiv &>(n)); break; }
       case NODECL_CXX_IMPLICIT_INSTANTIATION: { this->visit(static_cast<const Nodecl::CxxImplicitInstantiation &>(n)); break; }
       case NODECL_OPEN_M_P_SECTION: { this->visit(static_cast<const Nodecl::OpenMP::Section &>(n)); break; }
       case NODECL_PRAGMA_CLAUSE_ARG: { this->visit(static_cast<const Nodecl::PragmaClauseArg &>(n)); break; }
       case NODECL_EXPRESSION_STATEMENT: { this->visit(static_cast<const Nodecl::ExpressionStatement &>(n)); break; }
       case NODECL_VECTOR_BITWISE_OR: { this->visit(static_cast<const Nodecl::VectorBitwiseOr &>(n)); break; }
       case NODECL_CXX_VALUE_PACK: { this->visit(static_cast<const Nodecl::CxxValuePack &>(n)); break; }
       case NODECL_CASE_STATEMENT: { this->visit(static_cast<const Nodecl::CaseStatement &>(n)); break; }
       case NODECL_POSTDECREMENT: { this->visit(static_cast<const Nodecl::Postdecrement &>(n)); break; }
       case NODECL_OPEN_M_P_MAP_TO_FROM: { this->visit(static_cast<const Nodecl::OpenMP::MapToFrom &>(n)); break; }
       case NODECL_CXX_FUNCTION_FORM_DEFAULT_INIT_BRACED: { this->visit(static_cast<const Nodecl::CxxFunctionFormDefaultInitBraced &>(n)); break; }
       case NODECL_ADD_ASSIGNMENT: { this->visit(static_cast<const Nodecl::AddAssignment &>(n)); break; }
       case NODECL_FORTRAN_BIND_C: { this->visit(static_cast<const Nodecl::FortranBindC &>(n)); break; }
       case NODECL_OMP_SS_TASK_EXPRESSION: { this->visit(static_cast<const Nodecl::OmpSs::TaskExpression &>(n)); break; }
       case NODECL_OPEN_M_P_THREAD_LIMIT: { this->visit(static_cast<const Nodecl::OpenMP::ThreadLimit &>(n)); break; }
       case NODECL_DIV: { this->visit(static_cast<const Nodecl::Div &>(n)); break; }
       case NODECL_OMP_SS_IMPLEMENTS: { this->visit(static_cast<const Nodecl::OmpSs::Implements &>(n)); break; }
       case NODECL_ANALYSIS_MINUS_INFINITY: { this->visit(static_cast<const Nodecl::Analysis::MinusInfinity &>(n)); break; }
       case NODECL_ASM_DEFINITION: { this->visit(static_cast<const Nodecl::AsmDefinition &>(n)); break; }
       case NODECL_FORTRAN_IO_STATEMENT: { this->visit(static_cast<const Nodecl::FortranIoStatement &>(n)); break; }
       case NODECL_FUNCTION_CODE: { this->visit(static_cast<const Nodecl::FunctionCode &>(n)); break; }
       case NODECL_STRUCTURED_VALUE_BRACED_IMPLICIT: { this->visit(static_cast<const Nodecl::StructuredValueBracedImplicit &>(n)); break; }
       case NODECL_VECTOR_REDUCTION_ADD: { this->visit(static_cast<const Nodecl::VectorReductionAdd &>(n)); break; }
       case NODECL_ANALYSIS_CORRECTNESS_DEAD: { this->visit(static_cast<const Nodecl::Analysis::Correctness::Dead &>(n)); break; }
       case NODECL_CXX_DEP_NAME_CONVERSION: { this->visit(static_cast<const Nodecl::CxxDepNameConversion &>(n)); break; }
       case NODECL_OPEN_M_P_TASKLOOP: { this->visit(static_cast<const Nodecl::OpenMP::Taskloop &>(n)); break; }
       case NODECL_ANALYSIS_CORRECTNESS_RACE: { this->visit(static_cast<const Nodecl::Analysis::Correctness::Race &>(n)); break; }
       case NODECL_MULTI_EXPRESSION_ITERATOR: { this->visit(static_cast<const Nodecl::MultiExpressionIterator &>(n)); break; }
       case NODECL_ANALYSIS_PHI: { this->visit(static_cast<const Nodecl::Analysis::Phi &>(n)); break; }
       case NODECL_CXX_SIZEOF: { this->visit(static_cast<const Nodecl::CxxSizeof &>(n)); break; }
       case NODECL_OPEN_M_P_SUITABLE: { this->visit(static_cast<const Nodecl::OpenMP::Suitable &>(n)); break; }
       case NODECL_VECTOR_ALIGN_RIGHT: { this->visit(static_cast<const Nodecl::VectorAlignRight &>(n)); break; }
       case NODECL_LABELED_STATEMENT: { this->visit(static_cast<const Nodecl::LabeledStatement &>(n)); break; }
       case NODECL_OPEN_M_P_BARRIER_WAIT: { this->visit(static_cast<const Nodecl::OpenMP::BarrierWait &>(n)); break; }
       case NODECL_VECTOR_ADD: { this->visit(static_cast<const Nodecl::VectorAdd &>(n)); break; }
       case NODECL_DELETE_ARRAY: { this->visit(static_cast<const Nodecl::DeleteArray &>(n)); break; }
       case NODECL_CXX_CLASS_MEMBER_ACCESS: { this->visit(static_cast<const Nodecl::CxxClassMemberAccess &>(n)); break; }
       case NODECL_STRUCTURED_VALUE_PARENTHESIZED: { this->visit(static_cast<const Nodecl::StructuredValueParenthesized &>(n)); break; }
       case NODECL_CXX_EXPLICIT_INSTANTIATION_DECL: { this->visit(static_cast<const Nodecl::CxxExplicitInstantiationDecl &>(n)); break; }
       case NODECL_FORTRAN_NOT_PRESENT: { this->visit(static_cast<const Nodecl::FortranNotPresent &>(n)); break; }
       case NODECL_CXX_PARENTHESIZED_INITIALIZER: { this->visit(static_cast<const Nodecl::CxxParenthesizedInitializer &>(n)); break; }
       case NODECL_CHECKPOINT_LEVEL: { this->visit(static_cast<const Nodecl::Checkpoint::Level &>(n)); break; }
       case NODECL_VECTOR_MINUS: { this->visit(static_cast<const Nodecl::VectorMinus &>(n)); break; }
       case NODECL_PRAGMA_CUSTOM_STATEMENT: { this->visit(static_cast<const Nodecl::PragmaCustomStatement &>(n)); break; }
       case NODECL_LOGICAL_AND: { this->visit(static_cast<const Nodecl::LogicalAnd &>(n)); break; }
       case NODECL_FORTRAN_LABEL_ASSIGN_STATEMENT: { this->visit(static_cast<const Nodecl::FortranLabelAssignStatement &>(n)); break; }
       case NODECL_OMP_SS_SHARED_AND_ALLOCA: { this->visit(static_cast<const Nodecl::OmpSs::SharedAndAlloca &>(n)); break; }
       case NODECL_ANALYSIS_LIVE_OUT: { this->visit(static_cast<const Nodecl::Analysis::LiveOut &>(n)); break; }
       case NODECL_FORTRAN_READ_STATEMENT: { this->visit(static_cast<const Nodecl::FortranReadStatement &>(n)); break; }
       case NODECL_C99_INDEX_DESIGNATOR: { this->visit(static_cast<const Nodecl::C99IndexDesignator &>(n)); break; }
       case NODECL_ALIGNOF: { this->visit(static_cast<const Nodecl::Alignof &>(n)); break; }
       case NODECL_OPEN_M_P_MASTER: { this->visit(static_cast<const Nodecl::OpenMP::Master &>(n)); break; }
       case NODECL_OMP_SS_TASK_IS_LOOP: { this->visit(static_cast<const Nodecl::OmpSs::TaskIsLoop &>(n)); break; }
       case NODECL_WHILE_STATEMENT: { this->visit(static_cast<const Nodecl::WhileStatement &>(n)); break; }
       case NODECL_OPEN_M_P_DEVICE: { this->visit(static_cast<const Nodecl::OpenMP::Device &>(n)); break; }
       case NODECL_OPEN_M_P_AUTO: { this->visit(static_cast<const Nodecl::OpenMP::Auto &>(n)); break; }
       case NODECL_SHAPING: { this->visit(static_cast<const Nodecl::Shaping &>(n)); break; }
       case NODECL_VECTOR_MUL: { this->visit(static_cast<const Nodecl::VectorMul &>(n)); break; }
       case NODECL_UPC_SYNC_STATEMENT: { this->visit(static_cast<const Nodecl::UpcSyncStatement &>(n)); break; }
       case NODECL_OPEN_M_P_NO_MASK: { this->visit(static_cast<const Nodecl::OpenMP::NoMask &>(n)); break; }
       case NODECL_VECTOR_MASK_NOT: { this->visit(static_cast<const Nodecl::VectorMaskNot &>(n)); break; }
       case NODECL_RANGE: { this->visit(static_cast<const Nodecl::Range &>(n)); break; }
       case NODECL_VECTOR_BITWISE_SHL: { this->visit(static_cast<const Nodecl::VectorBitwiseShl &>(n)); break; }
       case NODECL_OPEN_M_P_BARRIER_FULL: { this->visit(static_cast<const Nodecl::OpenMP::BarrierFull &>(n)); break; }
       case NODECL_ANALYSIS_ASSERT: { this->visit(static_cast<const Nodecl::Analysis::Assert &>(n)); break; }
       case NODECL_OMP_SS_DEP_IN_PRIVATE: { this->visit(static_cast<const Nodecl::OmpSs::DepInPrivate &>(n)); break; }
       case NODECL_OPEN_M_P_SHARED: { this->visit(static_cast<const Nodecl::OpenMP::Shared &>(n)); break; }
       case NODECL_OFFSET: { this->visit(static_cast<const Nodecl::Offset &>(n)); break; }
       case NODECL_OMP_SS_TASK_LABEL: { this->visit(static_cast<const Nodecl::OmpSs::TaskLabel &>(n)); break; }
       case NODECL_CXX_DEP_FUNCTION_CALL: { this->visit(static_cast<const Nodecl::CxxDepFunctionCall &>(n)); break; }
       case NODECL_OMP_SS_DEP_WEAK_INOUT: { this->visit(static_cast<const Nodecl::OmpSs::DepWeakInout &>(n)); break; }
       case NODECL_LOGICAL_OR: { this->visit(static_cast<const Nodecl::LogicalOr &>(n)); break; }
       case NODECL_PARENTHESIZED_EXPRESSION: { this->visit(static_cast<const Nodecl::ParenthesizedExpression &>(n)); break; }
       case NODECL_FUNCTION_CALL: { this->visit(static_cast<const Nodecl::FunctionCall &>(n)); break; }
       case NODECL_MOD_ASSIGNMENT: { this->visit(static_cast<const Nodecl::ModAssignment &>(n)); break; }
       case NODECL_RANGE_DISCRETE: { this->visit(static_cast<const Nodecl::RangeDiscrete &>(n)); break; }
       case NODECL_OPEN_M_P_PARALLEL: { this->visit(static_cast<const Nodecl::OpenMP::Parallel &>(n)); break; }
       case NODECL_CUDA_KERNEL_CALL: { this->visit(static_cast<const Nodecl::CudaKernelCall &>(n)); break; }
       case NODECL_RELAXED_FLAG: { this->visit(static_cast<const Nodecl::RelaxedFlag &>(n)); break; }
       case NODECL_OPEN_M_P_DECLARE_TARGET: { this->visit(static_cast<const Nodecl::OpenMP::DeclareTarget &>(n)); break; }
       case NODECL_OPEN_M_P_MERGEABLE: { this->visit(static_cast<const Nodecl::OpenMP::Mergeable &>(n)); break; }
       case NODECL_VECTOR_ASSIGNMENT: { this->visit(static_cast<const Nodecl::VectorAssignment &>(n)); break; }
       case NODECL_OPEN_M_P_DEP_INOUT: { this->visit(static_cast<const Nodecl::OpenMP::DepInout &>(n)); break; }
       case NODECL_CHECKPOINT_IF: { this->visit(static_cast<const Nodecl::Checkpoint::If &>(n)); break; }
       case NODECL_FORTRAN_ALTERNATE_RETURN_STATEMENT: { this->visit(static_cast<const Nodecl::FortranAlternateReturnStatement &>(n)); break; }
       case NODECL_IMPLICIT_MEMBER_INIT: { this->visit(static_cast<const Nodecl::ImplicitMemberInit &>(n)); break; }
       case NODECL_OPEN_M_P_LASTPRIVATE: { this->visit(static_cast<const Nodecl::OpenMP::Lastprivate &>(n)); break; }
       case NODECL_FORTRAN_WHERE: { this->visit(static_cast<const Nodecl::FortranWhere &>(n)); break; }
       case NODECL_DEFAULT_STATEMENT: { this->visit(static_cast<const Nodecl::DefaultStatement &>(n)); break; }
       case NODECL_CXX_BRACED_INITIALIZER: { this->visit(static_cast<const Nodecl::CxxBracedInitializer &>(n)); break; }
       case NODECL_OPEN_M_P_ATOMIC: { this->visit(static_cast<const Nodecl::OpenMP::Atomic &>(n)); break; }
       case NODECL_FORTRAN_NULLIFY_STATEMENT: { this->visit(static_cast<const Nodecl::FortranNullifyStatement &>(n)); break; }
       case NODECL_OPEN_M_P_SIMD_REDUCTION: { this->visit(static_cast<const Nodecl::OpenMP::SimdReduction &>(n)); break; }
       case NODECL_CXX_INITIALIZER: { this->visit(static_cast<const Nodecl::CxxInitializer &>(n)); break; }
       case NODECL_FOR_STATEMENT: { this->visit(static_cast<const Nodecl::ForStatement &>(n)); break; }
       case NODECL_NEG: { this->visit(static_cast<const Nodecl::Neg &>(n)); break; }
       case NODECL_VECTOR_FUNCTION_CODE: { this->visit(static_cast<const Nodecl::VectorFunctionCode &>(n)); break; }
       case NODECL_ADD: { this->visit(static_cast<const Nodecl::Add &>(n)); break; }
       case NODECL_RANGE_LOOP_CONTROL: { this->visit(static_cast<const Nodecl::RangeLoopControl &>(n)); break; }
       case NODECL_FORTRAN_WRITE_STATEMENT: { this->visit(static_cast<const Nodecl::FortranWriteStatement &>(n)); break; }
       case NODECL_FORTRAN_ALTERNATE_RETURN_ARGUMENT: { this->visit(static_cast<const Nodecl::FortranAlternateReturnArgument &>(n)); break; }
       case NODECL_BITWISE_XOR: { this->visit(static_cast<const Nodecl::BitwiseXor &>(n)); break; }
       case NODECL_CHECKPOINT_ID: { this->visit(static_cast<const Nodecl::Checkpoint::Id &>(n)); break; }
       case NODECL_CXX_DEP_NAME_SIMPLE: { this->visit(static_cast<const Nodecl::CxxDepNameSimple &>(n)); break; }
       case NODECL_ANALYSIS_AUTO_SCOPE_SHARED: { this->visit(static_cast<const Nodecl::Analysis::AutoScope::Shared &>(n)); break; }
       case NODECL_OMP_SS_DEP_CONCURRENT: { this->visit(static_cast<const Nodecl::OmpSs::DepConcurrent &>(n)); break; }
       case NODECL_LOWER_THAN: { this->visit(static_cast<const Nodecl::LowerThan &>(n)); break; }
       case NODECL_FORTRAN_CLOSE_STATEMENT: { this->visit(static_cast<const Nodecl::FortranCloseStatement &>(n)); break; }
       case NODECL_UNKNOWN: { this->visit(static_cast<const Nodecl::Unknown &>(n)); break; }
       case NODECL_UNKNOWN_PRAGMA: { this->visit(static_cast<const Nodecl::UnknownPragma &>(n)); break; }
       case NODECL_OMP_SS_DEP_REDUCTION: { this->visit(static_cast<const Nodecl::OmpSs::DepReduction &>(n)); break; }
       case NODECL_CXX_FOR_RANGED: { this->visit(static_cast<const Nodecl::CxxForRanged &>(n)); break; }
       case NODECL_ANALYSIS_ASSERT_DECL: { this->visit(static_cast<const Nodecl::Analysis::AssertDecl &>(n)); break; }
       case NODECL_CXX_DEP_TEMPLATE_ID: { this->visit(static_cast<const Nodecl::CxxDepTemplateId &>(n)); break; }
       case NODECL_OMP_SS_DEP_WEAK_COMMUTATIVE: { this->visit(static_cast<const Nodecl::OmpSs::DepWeakCommutative &>(n)); break; }
       case NODECL_MULTI_EXPRESSION: { this->visit(static_cast<const Nodecl::MultiExpression &>(n)); break; }
       case NODECL_OMP_SS_TASK_CALL: { this->visit(static_cast<const Nodecl::OmpSs::TaskCall &>(n)); break; }
       case NODECL_GXX_BUILTIN_ADDRESSOF: { this->visit(static_cast<const Nodecl::GxxBuiltinAddressof &>(n)); break; }
       case NODECL_OPEN_M_P_FUNCTION_TASK_PARSING_CONTEXT: { this->visit(static_cast<const Nodecl::OpenMP::FunctionTaskParsingContext &>(n)); break; }
       case NODECL_CXX_STATIC_ASSERT: { this->visit(static_cast<const Nodecl::CxxStaticAssert &>(n)); break; }
       case NODECL_OPEN_M_P_GRAINSIZE: { this->visit(static_cast<const Nodecl::OpenMP::Grainsize &>(n)); break; }
       case NODECL_BITWISE_SHL_ASSIGNMENT: { this->visit(static_cast<const Nodecl::BitwiseShlAssignment &>(n)); break; }
       case NODECL_CXX_USING_NAMESPACE: { this->visit(static_cast<const Nodecl::CxxUsingNamespace &>(n)); break; }
       case NODECL_CONVERSION: { this->visit(static_cast<const Nodecl::Conversion &>(n)); break; }
       case NODECL_COMPLEX_LITERAL: { this->visit(static_cast<const Nodecl::ComplexLiteral &>(n)); break; }
       case NODECL_OPEN_M_P_MAP_ALLOC: { this->visit(static_cast<const Nodecl::OpenMP::MapAlloc &>(n)); break; }
       case NODECL_MOD: { this->visit(static_cast<const Nodecl::Mod &>(n)); break; }
       case NODECL_FORTRAN_IO_SPEC: { this->visit(static_cast<const Nodecl::FortranIoSpec &>(n)); break; }
       case NODECL_OMP_SS_COPY_IN: { this->visit(static_cast<const Nodecl::OmpSs::CopyIn &>(n)); break; }
       case NODECL_FORTRAN_IMPLIED_DO: { this->visit(static_cast<const Nodecl::FortranImpliedDo &>(n)); break; }
       case NODECL_SOURCE_COMMENT: { this->visit(static_cast<const Nodecl::SourceComment &>(n)); break; }
       case NODECL_ANALYSIS_RANGE: { this->visit(static_cast<const Nodecl::Analysis::Range &>(n)); break; }
       case NODECL_FIELD_DESIGNATOR: { this->visit(static_cast<const Nodecl::FieldDesignator &>(n)); break; }
       case NODECL_PSEUDO_DESTRUCTOR_NAME: { this->visit(static_cast<const Nodecl::PseudoDestructorName &>(n)); break; }
       case NODECL_GCC_ASM_SPEC: { this->visit(static_cast<const Nodecl::GccAsmSpec &>(n)); break; }
       case NODECL_MUL: { this->visit(static_cast<const Nodecl::Mul &>(n)); break; }
       case NODECL_ITERATOR_LOOP_CONTROL: { this->visit(static_cast<const Nodecl::IteratorLoopControl &>(n)); break; }
       case NODECL_GOTO_STATEMENT: { this->visit(static_cast<const Nodecl::GotoStatement &>(n)); break; }
       case NODECL_CXX_MEMBER_INIT: { this->visit(static_cast<const Nodecl::CxxMemberInit &>(n)); break; }
       case NODECL_OBJECT_INIT: { this->visit(static_cast<const Nodecl::ObjectInit &>(n)); break; }
       case NODECL_OPEN_M_P_SIMD_FUNCTION: { this->visit(static_cast<const Nodecl::OpenMP::SimdFunction &>(n)); break; }
       case NODECL_VECTOR_MASK_XOR: { this->visit(static_cast<const Nodecl::VectorMaskXor &>(n)); break; }
       case NODECL_VERBATIM: { this->visit(static_cast<const Nodecl::Verbatim &>(n)); break; }
       case NODECL_MINUS_ASSIGNMENT: { this->visit(static_cast<const Nodecl::MinusAssignment &>(n)); break; }
       case NODECL_NOEXCEPT_IMPLICIT_TRUE: { this->visit(static_cast<const Nodecl::NoexceptImplicitTrue &>(n)); break; }
       case NODECL_INDEX_DESIGNATOR: { this->visit(static_cast<const Nodecl::IndexDesignator &>(n)); break; }
       case NODECL_BITWISE_SHL: { this->visit(static_cast<const Nodecl::BitwiseShl &>(n)); break; }
       case NODECL_VECTOR_PROMOTION: { this->visit(static_cast<const Nodecl::VectorPromotion &>(n)); break; }
       case NODECL_CONTEXT: { this->visit(static_cast<const Nodecl::Context &>(n)); break; }
       case NODECL_VECTOR_MASK_AND_2_NOT: { this->visit(static_cast<const Nodecl::VectorMaskAnd2Not &>(n)); break; }
       case NODECL_COMMA: { this->visit(static_cast<const Nodecl::Comma &>(n)); break; }
       case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_FP: { this->visit(static_cast<const Nodecl::Analysis::Correctness::IncoherentFp &>(n)); break; }
       case NODECL_ANALYSIS_AUTO_SCOPE_PRIVATE: { this->visit(static_cast<const Nodecl::Analysis::AutoScope::Private &>(n)); break; }
       case NODECL_MEMBER_INIT: { this->visit(static_cast<const Nodecl::MemberInit &>(n)); break; }
       case NODECL_MUL_ASSIGNMENT: { this->visit(static_cast<const Nodecl::MulAssignment &>(n)); break; }
       case NODECL_VECTOR_BITWISE_SHR: { this->visit(static_cast<const Nodecl::VectorBitwiseShr &>(n)); break; }
       case NODECL_VLA_WILDCARD: { this->visit(static_cast<const Nodecl::VlaWildcard &>(n)); break; }
       case NODECL_BITWISE_SHR_ASSIGNMENT: { this->visit(static_cast<const Nodecl::BitwiseShrAssignment &>(n)); break; }
       case NODECL_ANALYSIS_INDUCTION_VARIABLE: { this->visit(static_cast<const Nodecl::Analysis::InductionVariable &>(n)); break; }
       case NODECL_OPEN_M_P_TASK: { this->visit(static_cast<const Nodecl::OpenMP::Task &>(n)); break; }
       case NODECL_ANALYSIS_EMPTY_RANGE: { this->visit(static_cast<const Nodecl::Analysis::EmptyRange &>(n)); break; }
       case NODECL_VECTOR_LOAD: { this->visit(static_cast<const Nodecl::VectorLoad &>(n)); break; }
       case NODECL_OFFSETOF: { this->visit(static_cast<const Nodecl::Offsetof &>(n)); break; }
       case NODECL_ANALYSIS_INDUCTION_VAR_EXPR: { this->visit(static_cast<const Nodecl::Analysis::InductionVarExpr &>(n)); break; }
       case NODECL_OMP_SS_COST: { this->visit(static_cast<const Nodecl::OmpSs::Cost &>(n)); break; }
       case NODECL_VECTOR_CAST: { this->visit(static_cast<const Nodecl::VectorCast &>(n)); break; }
       case NODECL_VECTOR_RCP: { this->visit(static_cast<const Nodecl::VectorRcp &>(n)); break; }
       case NODECL_CXX_ARROW: { this->visit(static_cast<const Nodecl::CxxArrow &>(n)); break; }
       case NODECL_CXX_POSTFIX_INITIALIZER: { this->visit(static_cast<const Nodecl::CxxPostfixInitializer &>(n)); break; }
       case NODECL_OPEN_M_P_FIRSTPRIVATE: { this->visit(static_cast<const Nodecl::OpenMP::Firstprivate &>(n)); break; }
       case NODECL_ANALYSIS_RANGE_INTERSECTION: { this->visit(static_cast<const Nodecl::Analysis::RangeIntersection &>(n)); break; }
       case NODECL_CONCAT: { this->visit(static_cast<const Nodecl::Concat &>(n)); break; }
       case NODECL_VECTOR_FMMINUS: { this->visit(static_cast<const Nodecl::VectorFmminus &>(n)); break; }
       case NODECL_CXX_USING_DECL: { this->visit(static_cast<const Nodecl::CxxUsingDecl &>(n)); break; }
       case NODECL_OMP_SS_WAIT: { this->visit(static_cast<const Nodecl::OmpSs::Wait &>(n)); break; }
       case NODECL_OPEN_M_P_DEP_OUT: { this->visit(static_cast<const Nodecl::OpenMP::DepOut &>(n)); break; }
       case NODECL_OPEN_M_P_TASK_IS_TASKWAIT: { this->visit(static_cast<const Nodecl::OpenMP::TaskIsTaskwait &>(n)); break; }
       case NODECL_PRAGMA_CONTEXT: { this->visit(static_cast<const Nodecl::PragmaContext &>(n)); break; }
       case NODECL_CXX_EXPLICIT_TYPE_CAST: { this->visit(static_cast<const Nodecl::CxxExplicitTypeCast &>(n)); break; }
       case NODECL_DEFAULT_ARGUMENT: { this->visit(static_cast<const Nodecl::DefaultArgument &>(n)); break; }
       case NODECL_OPEN_M_P_ALIGNED: { this->visit(static_cast<const Nodecl::OpenMP::Aligned &>(n)); break; }
       case NODECL_OPEN_M_P_CRITICAL: { this->visit(static_cast<const Nodecl::OpenMP::Critical &>(n)); break; }
       case NODECL_BITWISE_SHR: { this->visit(static_cast<const Nodecl::BitwiseShr &>(n)); break; }
       case NODECL_OMP_SS_TARGET_DECLARATION: { this->visit(static_cast<const Nodecl::OmpSs::TargetDeclaration &>(n)); break; }
       case NODECL_ANALYSIS_REACHING_DEFINITION_IN: { this->visit(static_cast<const Nodecl::Analysis::ReachingDefinitionIn &>(n)); break; }
       case NODECL_CXX_DEF: { this->visit(static_cast<const Nodecl::CxxDef &>(n)); break; }
       case NODECL_CHECKPOINT_LOAD: { this->visit(static_cast<const Nodecl::Checkpoint::Load &>(n)); break; }
       case NODECL_BITWISE_XOR_ASSIGNMENT: { this->visit(static_cast<const Nodecl::BitwiseXorAssignment &>(n)); break; }
       case NODECL_VECTOR_CONDITIONAL_EXPRESSION: { this->visit(static_cast<const Nodecl::VectorConditionalExpression &>(n)); break; }
       case NODECL_ARITHMETIC_SHR_ASSIGNMENT: { this->visit(static_cast<const Nodecl::ArithmeticShrAssignment &>(n)); break; }
       case NODECL_OPEN_M_P_TARGET_UPDATE: { this->visit(static_cast<const Nodecl::OpenMP::TargetUpdate &>(n)); break; }
       case NODECL_FORTRAN_ARITHMETIC_IF_STATEMENT: { this->visit(static_cast<const Nodecl::FortranArithmeticIfStatement &>(n)); break; }
       case NODECL_CXX_FUNCTION_FORM_BINARY_INFIX: { this->visit(static_cast<const Nodecl::CxxFunctionFormBinaryInfix &>(n)); break; }
       case NODECL_ERR_STATEMENT: { this->visit(static_cast<const Nodecl::ErrStatement &>(n)); break; }
       case NODECL_ERR_EXPR: { this->visit(static_cast<const Nodecl::ErrExpr &>(n)); break; }
       case NODECL_BREAK_STATEMENT: { this->visit(static_cast<const Nodecl::BreakStatement &>(n)); break; }
       case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_OUT: { this->visit(static_cast<const Nodecl::Analysis::Correctness::IncoherentOut &>(n)); break; }
       case NODECL_VECTOR_GATHER: { this->visit(static_cast<const Nodecl::VectorGather &>(n)); break; }
       case NODECL_RETURN_STATEMENT: { this->visit(static_cast<const Nodecl::ReturnStatement &>(n)); break; }
       case NODECL_ANALYSIS_REACH_DEF_EXPR: { this->visit(static_cast<const Nodecl::Analysis::ReachDefExpr &>(n)); break; }
       case NODECL_CXX_VALUE_PACK_EXPANDED: { this->visit(static_cast<const Nodecl::CxxValuePackExpanded &>(n)); break; }
       case NODECL_PREDECREMENT: { this->visit(static_cast<const Nodecl::Predecrement &>(n)); break; }
       case NODECL_ANALYSIS_RANGE_UNION: { this->visit(static_cast<const Nodecl::Analysis::RangeUnion &>(n)); break; }
       case NODECL_OPEN_M_P_FIRST_LASTPRIVATE: { this->visit(static_cast<const Nodecl::OpenMP::FirstLastprivate &>(n)); break; }
       case NODECL_DIFFERENT: { this->visit(static_cast<const Nodecl::Different &>(n)); break; }
       case NODECL_ALIGNED_FLAG: { this->visit(static_cast<const Nodecl::AlignedFlag &>(n)); break; }
       case NODECL_OPEN_M_P_SECTIONS: { this->visit(static_cast<const Nodecl::OpenMP::Sections &>(n)); break; }
       case NODECL_OPEN_M_P_NONTEMPORAL: { this->visit(static_cast<const Nodecl::OpenMP::Nontemporal &>(n)); break; }
       case NODECL_VECTOR_MOD: { this->visit(static_cast<const Nodecl::VectorMod &>(n)); break; }
       case NODECL_VECTOR_MASK_AND_1_NOT: { this->visit(static_cast<const Nodecl::VectorMaskAnd1Not &>(n)); break; }
       case NODECL_OMP_SS_LOOP: { this->visit(static_cast<const Nodecl::OmpSs::Loop &>(n)); break; }
       case NODECL_GREATER_THAN: { this->visit(static_cast<const Nodecl::GreaterThan &>(n)); break; }
       case NODECL_CHECKPOINT_SHUTDOWN: { this->visit(static_cast<const Nodecl::Checkpoint::Shutdown &>(n)); break; }
       case NODECL_FORTRAN_USE: { this->visit(static_cast<const Nodecl::FortranUse &>(n)); break; }
       case NODECL_SWITCH_STATEMENT: { this->visit(static_cast<const Nodecl::SwitchStatement &>(n)); break; }
       case NODECL_OPEN_M_P_PREFETCH: { this->visit(static_cast<const Nodecl::OpenMP::Prefetch &>(n)); break; }
       case NODECL_HAS_BEEN_DEFINED_FLAG: { this->visit(static_cast<const Nodecl::HasBeenDefinedFlag &>(n)); break; }
       case NODECL_ANALYSIS_DEAD: { this->visit(static_cast<const Nodecl::Analysis::Dead &>(n)); break; }
       case NODECL_VECTOR_FUNCTION_CALL: { this->visit(static_cast<const Nodecl::VectorFunctionCall &>(n)); break; }
       case NODECL_OPEN_M_P_NO_FLUSH: { this->visit(static_cast<const Nodecl::OpenMP::NoFlush &>(n)); break; }
       case NODECL_OPEN_M_P_FLUSH_AT_EXIT: { this->visit(static_cast<const Nodecl::OpenMP::FlushAtExit &>(n)); break; }
       case NODECL_BITWISE_NOT: { this->visit(static_cast<const Nodecl::BitwiseNot &>(n)); break; }
       case NODECL_OPEN_M_P_FINAL: { this->visit(static_cast<const Nodecl::OpenMP::Final &>(n)); break; }
       case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_IN_POINTED: { this->visit(static_cast<const Nodecl::Analysis::Correctness::IncoherentInPointed &>(n)); break; }
       case NODECL_PREPROCESSOR_LINE: { this->visit(static_cast<const Nodecl::PreprocessorLine &>(n)); break; }
       case NODECL_OPEN_M_P_TARGET: { this->visit(static_cast<const Nodecl::OpenMP::Target &>(n)); break; }
       case NODECL_FORTRAN_HOLLERITH: { this->visit(static_cast<const Nodecl::FortranHollerith &>(n)); break; }
       case NODECL_VECTOR_GREATER_OR_EQUAL_THAN: { this->visit(static_cast<const Nodecl::VectorGreaterOrEqualThan &>(n)); break; }
       case NODECL_CXX_EQUAL_INITIALIZER: { this->visit(static_cast<const Nodecl::CxxEqualInitializer &>(n)); break; }
       case NODECL_IMAG_PART: { this->visit(static_cast<const Nodecl::ImagPart &>(n)); break; }
       case NODECL_POWER: { this->visit(static_cast<const Nodecl::Power &>(n)); break; }
       case NODECL_OPEN_M_P_TARGET_TASK_UNDEFERRED: { this->visit(static_cast<const Nodecl::OpenMP::TargetTaskUndeferred &>(n)); break; }
       case NODECL_GCC_BUILTIN_VA_ARG: { this->visit(static_cast<const Nodecl::GccBuiltinVaArg &>(n)); break; }
       case NODECL_CXX_FUNCTION_FORM_IMPLICIT: { this->visit(static_cast<const Nodecl::CxxFunctionFormImplicit &>(n)); break; }
       case NODECL_VECTOR_REDUCTION_MUL: { this->visit(static_cast<const Nodecl::VectorReductionMul &>(n)); break; }
       case NODECL_CXX_DEP_NEW: { this->visit(static_cast<const Nodecl::CxxDepNew &>(n)); break; }
       case NODECL_FORTRAN_STOP_STATEMENT: { this->visit(static_cast<const Nodecl::FortranStopStatement &>(n)); break; }
       case NODECL_FORTRAN_FORALL: { this->visit(static_cast<const Nodecl::FortranForall &>(n)); break; }
       case NODECL_DIV_ASSIGNMENT: { this->visit(static_cast<const Nodecl::DivAssignment &>(n)); break; }
       case NODECL_VECTOR_NEG: { this->visit(static_cast<const Nodecl::VectorNeg &>(n)); break; }
       case NODECL_CXX_ALIGNAS: { this->visit(static_cast<const Nodecl::CxxAlignas &>(n)); break; }
       case NODECL_OPEN_M_P_NUM_TEAMS: { this->visit(static_cast<const Nodecl::OpenMP::NumTeams &>(n)); break; }
       case NODECL_VECTOR_BITWISE_AND: { this->visit(static_cast<const Nodecl::VectorBitwiseAnd &>(n)); break; }
       case NODECL_CXX_FUNCTION_FORM_TEMPLATE_ID: { this->visit(static_cast<const Nodecl::CxxFunctionFormTemplateId &>(n)); break; }

       default:
           { internal_error("Unexpected tree kind '%s'\n", ast_print_node_type(n.get_kind())); }
    }

}
} /* namespace Nodecl */
#endif // TL_NODECL_VISITOR_CPP
