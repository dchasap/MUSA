/*
 * Copyright (c) 2015, Barcelona Supercomputing Center
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer; redistributions in binary form
 * must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with
 * the distribution; neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#ifndef CORE_TRACE_COMMON_MINST_H_
#define CORE_TRACE_COMMON_MINST_H_

#include <iostream>
#include <map>
#include <string>

namespace sim {
namespace trace {

/**
 * Struct holding an abstract instruction
 * pack(1) is specified to avoid padding so binary traces occupy less space
 * It can hold a CISC instruction, so it may cause multiple loads/stores
 */

enum class op_t : uint8_t { INVALID = 0,
               MACROOP = 1,
               // Integer operations 2-15
               IALU = 2,
               IMUL = 3,
               IDIV = 4,
               // Memory operations 16-31
               LD = 16,
               ST = 17,
               REMOVED_LD = 18,
               REMOVED_ST = 19,
               // Branch-jumps 32-47
               JMP = 32,
               BR = 33,
               IBR = 34,
               // Memory locks 48-63
               LDL = 48,  // Load + Lock
               STL = 49,  // Store + Lock
               LL = 50,   // Load link
               SC = 51,   // Store conditional
               // Floating point 64-79
               FALU = 64,
               FMUL = 65,
               FDIV = 66,
               FMA = 67,  // Floating point  multiply add
               // Vector operations 80-95
               VADD = 80,
               VMUL = 81,
               VDIV = 82,
               VMASK = 83,
               // Cache management operations ??? 96-111
               OTHER = 255 };

enum class complexity_t : uint8_t {
        INVALID = 0,
        MEM = 1,
        BITWISE = 3,
        SIMPLE = 5,
        MIDDLE = 9,
        COMPLEX = 33 };

// TODO(Francesc): Until we adopt C++14 we cannot use an enum as  a key on an unordered_map
static const std::map<sim::trace::op_t, std::string> opname({
        {sim::trace::op_t::INVALID, "INVALID"},
        {sim::trace::op_t::MACROOP, "MACROOP"},
        {sim::trace::op_t::IALU, "IALU"},
        {sim::trace::op_t::IMUL, "IMUL"},
        {sim::trace::op_t::IDIV, "IDIV"},
        {sim::trace::op_t::LD, "LD"},
        {sim::trace::op_t::ST, "ST"},
        {sim::trace::op_t::REMOVED_LD, "REM_LD"},
        {sim::trace::op_t::REMOVED_ST, "REM_ST"},
        {sim::trace::op_t::JMP, "JMP"},
        {sim::trace::op_t::BR, "BR"},
        {sim::trace::op_t::IBR, "IBR"},
        {sim::trace::op_t::LDL, "LDL"},
        {sim::trace::op_t::STL, "STL"},
        {sim::trace::op_t::LL, "LL"},
        {sim::trace::op_t::SC, "SC"},
        {sim::trace::op_t::FALU, "FALU"},
        {sim::trace::op_t::FMUL, "FMUL"},
        {sim::trace::op_t::FDIV, "FDIV"},
        {sim::trace::op_t::FMA, "FMA"},
        {sim::trace::op_t::VADD, "VADD"},
        {sim::trace::op_t::VMUL, "VMUL"},
        {sim::trace::op_t::VDIV, "VDIV"},
        {sim::trace::op_t::VMASK, "VMASK"},
        {sim::trace::op_t::OTHER, "OTHER"}
        });
#pragma pack(1)
struct minst_t {
    op_t type_;                 /**< instruction type, taking values of op_t */
    uint64_t iword_;            /**< for macroops only */
    uint8_t isize_;             /**< for both macroops and microops */
    uint64_t pc_;
    unsigned char ld_:2;        /**< num. of loads generated by this instruction */
    unsigned char st_:1;        /**< num. of stores generated by this instruction */
    unsigned char sve_:1;       /**< SVE boolean flag.*/
    unsigned char :4;           /**< Padding */
    uint8_t ld_size_;           /**< data size accessed by each load */
    uint8_t st_size_;           /**< data size accessed by each store */
    uint8_t ra_, rb_, rc_, rd_; /**< Register indexes as reported by ptlsim */

    // Empty ctor.
    minst_t();
    // Old Ctor.
    minst_t(sim::trace::op_t op, int ld, int st, int ld_size, int st_size);
    // Standard microop creator.
    template<typename TransOp>
    minst_t(const uint8_t *iword, op_t op, int size, const TransOp &uop);
    // Microop creator for load/store missmatch fixing routine.
    minst_t(const uint8_t *iword, op_t op, int size, int ra, int rb, int rc, int rd);
    // Macroop constructor:
    minst_t(const uint8_t *iword, unsigned size, uint64_t pc = 0);

    // Functions to avoid overcomplicating the code and hiding some of the possible complexity.
    bool isInvalid() const;
    bool isValid() const;
    bool isLoad() const;
    bool isStore() const;
    bool is_vector() const;
    bool is_sve() const;
    bool is_memory_sve() const;
    bool is_ld1w() const;
    complexity_t get_sve_complexity();
    void vectorize();
    static bool is_vec(int reg);
    static bool is_vec_or_neutral(int reg);

    void write(std::ostream &) const;
    void read(std::istream &);
};
#pragma pack()

/** function to write a basic block to an output stream */
std::ostream &operator<<(std::ostream &os, const minst_t &item);
std::istream &operator>>(std::istream &is, minst_t &item);

}  // namespace trace
}  // namespace sim

#include "minst-impl.h"

#endif  // CORE_TRACE_COMMON_MINST_H_
