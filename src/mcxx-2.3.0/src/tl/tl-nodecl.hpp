/* Autogenerated file. DO NOT MODIFY. */
/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */
#ifndef TL_NODECL_HPP
#define TL_NODECL_HPP

#include <string>
#include "tl-nodecl-base.hpp"
#include "mem.h"
namespace Nodecl {
class StructuredValueParenthesized : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_STRUCTURED_VALUE_PARENTHESIZED;
       friend class NodeclBase;
    public:
    StructuredValueParenthesized() : NodeclBase() { }
    StructuredValueParenthesized(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static StructuredValueParenthesized make(const locus_t *location = ::make_locus("", 0, 0));

};
class StructuredValueBracedTypecast : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_STRUCTURED_VALUE_BRACED_TYPECAST;
       friend class NodeclBase;
    public:
    StructuredValueBracedTypecast() : NodeclBase() { }
    StructuredValueBracedTypecast(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static StructuredValueBracedTypecast make(const locus_t *location = ::make_locus("", 0, 0));

};
class StructuredValueBracedImplicit : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_STRUCTURED_VALUE_BRACED_IMPLICIT;
       friend class NodeclBase;
    public:
    StructuredValueBracedImplicit() : NodeclBase() { }
    StructuredValueBracedImplicit(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static StructuredValueBracedImplicit make(const locus_t *location = ::make_locus("", 0, 0));

};
class StructuredValueCompoundLiteral : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_STRUCTURED_VALUE_COMPOUND_LITERAL;
       friend class NodeclBase;
    public:
    StructuredValueCompoundLiteral() : NodeclBase() { }
    StructuredValueCompoundLiteral(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static StructuredValueCompoundLiteral make(const locus_t *location = ::make_locus("", 0, 0));

};
class StructuredValueFortranTypespecArrayConstructor : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_STRUCTURED_VALUE_FORTRAN_TYPESPEC_ARRAY_CONSTRUCTOR;
       friend class NodeclBase;
    public:
    StructuredValueFortranTypespecArrayConstructor() : NodeclBase() { }
    StructuredValueFortranTypespecArrayConstructor(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static StructuredValueFortranTypespecArrayConstructor make(const locus_t *location = ::make_locus("", 0, 0));

};
class CxxDepTemplateId : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DEP_TEMPLATE_ID;
       friend class NodeclBase;
    public:
    CxxDepTemplateId() : NodeclBase() { }
    CxxDepTemplateId(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDepTemplateId make(Nodecl::NodeclBase child_name, const std::string& text, template_parameter_list_t* template_parameters, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxDepNameConversion : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DEP_NAME_CONVERSION;
       friend class NodeclBase;
    public:
    CxxDepNameConversion() : NodeclBase() { }
    CxxDepNameConversion(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDepNameConversion make(Nodecl::NodeclBase child_context, Nodecl::NodeclBase child_conversion_type, Nodecl::NodeclBase child_literal_conversion, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_context() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_context(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_conversion_type() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_conversion_type(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_literal_conversion() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_literal_conversion(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class CxxDepDecltype : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DEP_DECLTYPE;
       friend class NodeclBase;
    public:
    CxxDepDecltype() : NodeclBase() { }
    CxxDepDecltype(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDepDecltype make(TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

};
class Text : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_TEXT;
       friend class NodeclBase;
    public:
    Text() : NodeclBase() { }
    Text(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Text make(const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

};
class CudaKernelCall : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CUDA_KERNEL_CALL;
       friend class NodeclBase;
    public:
    CudaKernelCall() : NodeclBase() { }
    CudaKernelCall(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CudaKernelCall make(Nodecl::NodeclBase child_kernel_config, Nodecl::NodeclBase child_function_call, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_kernel_config() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_kernel_config(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_function_call() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_function_call(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class PragmaCustomDirective : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PRAGMA_CUSTOM_DIRECTIVE;
       friend class NodeclBase;
    public:
    PragmaCustomDirective() : NodeclBase() { }
    PragmaCustomDirective(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PragmaCustomDirective make(Nodecl::NodeclBase child_pragma_line, Nodecl::NodeclBase child_context_of_decl, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_pragma_line() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_pragma_line(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_context_of_decl() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_context_of_decl(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class PragmaContext : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PRAGMA_CONTEXT;
       friend class NodeclBase;
    public:
    PragmaContext() : NodeclBase() { }
    PragmaContext(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PragmaContext make(TL::Scope scope, const locus_t *location = ::make_locus("", 0, 0));

};
class Range : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_RANGE;
       friend class NodeclBase;
    public:
    Range() : NodeclBase() { }
    Range(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Range make(Nodecl::NodeclBase child_lower, Nodecl::NodeclBase child_upper, Nodecl::NodeclBase child_stride, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lower() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lower(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_upper() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_upper(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_stride() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_stride(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class OpenMP::Sections : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_SECTIONS;
       friend class NodeclBase;
    public:
    Sections() : NodeclBase() { }
    Sections(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Sections make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_sections, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_sections() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_sections(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::Master : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_MASTER;
       friend class NodeclBase;
    public:
    Master() : NodeclBase() { }
    Master(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Master make(Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class PragmaCustomLine : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PRAGMA_CUSTOM_LINE;
       friend class NodeclBase;
    public:
    PragmaCustomLine() : NodeclBase() { }
    PragmaCustomLine(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PragmaCustomLine make(Nodecl::NodeclBase child_parameters, Nodecl::NodeclBase child_clauses, Nodecl::NodeclBase child_end_clauses, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_parameters() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_parameters(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_clauses() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_clauses(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_end_clauses() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_end_clauses(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class GccBuiltinVaArg : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_GCC_BUILTIN_VA_ARG;
       friend class NodeclBase;
    public:
    GccBuiltinVaArg() : NodeclBase() { }
    GccBuiltinVaArg(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static GccBuiltinVaArg make(Nodecl::NodeclBase child_expr, Nodecl::NodeclBase child_va_type, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_va_type() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_va_type(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::Critical : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_CRITICAL;
       friend class NodeclBase;
    public:
    Critical() : NodeclBase() { }
    Critical(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Critical make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class PragmaCustomStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PRAGMA_CUSTOM_STATEMENT;
       friend class NodeclBase;
    public:
    PragmaCustomStatement() : NodeclBase() { }
    PragmaCustomStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PragmaCustomStatement make(Nodecl::NodeclBase child_pragma_line, Nodecl::NodeclBase child_statements, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_pragma_line() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_pragma_line(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OmpSs::Loop : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_LOOP;
       friend class NodeclBase;
    public:
    Loop() : NodeclBase() { }
    Loop(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Loop make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_loop, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_loop() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_loop(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class TopLevel : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_TOP_LEVEL;
       friend class NodeclBase;
    public:
    TopLevel() : NodeclBase() { }
    TopLevel(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TopLevel make(Nodecl::NodeclBase child_top_level, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_top_level() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_top_level(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class IntelAssumeAligned : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_INTEL_ASSUME_ALIGNED;
       friend class NodeclBase;
    public:
    IntelAssumeAligned() : NodeclBase() { }
    IntelAssumeAligned(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IntelAssumeAligned make(Nodecl::NodeclBase child_pointer, Nodecl::NodeclBase child_alignment, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_pointer() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_pointer(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_alignment() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_alignment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class IntelAssume : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_INTEL_ASSUME;
       friend class NodeclBase;
    public:
    IntelAssume() : NodeclBase() { }
    IntelAssume(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IntelAssume make(Nodecl::NodeclBase child_assumed, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_assumed() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_assumed(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::Register : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_REGISTER;
       friend class NodeclBase;
    public:
    Register() : NodeclBase() { }
    Register(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Register make(Nodecl::NodeclBase child_registered_set, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_registered_set() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_registered_set(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::Unregister : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_UNREGISTER;
       friend class NodeclBase;
    public:
    Unregister() : NodeclBase() { }
    Unregister(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Unregister make(Nodecl::NodeclBase child_unregistered_set, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_unregistered_set() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_unregistered_set(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::SimdFor : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_SIMD_FOR;
       friend class NodeclBase;
    public:
    SimdFor() : NodeclBase() { }
    SimdFor(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static SimdFor make(Nodecl::NodeclBase child_openmp_for, Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_openmp_for() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_openmp_for(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Analysis::Phi : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_PHI;
       friend class NodeclBase;
    public:
    Phi() : NodeclBase() { }
    Phi(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Phi make(Nodecl::NodeclBase child_expressions, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::RangeUnion : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_RANGE_UNION;
       friend class NodeclBase;
    public:
    RangeUnion() : NodeclBase() { }
    RangeUnion(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static RangeUnion make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Analysis::RangeIntersection : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_RANGE_INTERSECTION;
       friend class NodeclBase;
    public:
    RangeIntersection() : NodeclBase() { }
    RangeIntersection(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static RangeIntersection make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Analysis::RangeSub : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_RANGE_SUB;
       friend class NodeclBase;
    public:
    RangeSub() : NodeclBase() { }
    RangeSub(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static RangeSub make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Analysis::EmptyRange : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_EMPTY_RANGE;
       friend class NodeclBase;
    public:
    EmptyRange() : NodeclBase() { }
    EmptyRange(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static EmptyRange make(const locus_t *location = ::make_locus("", 0, 0));

};
class Analysis::MinusInfinity : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_MINUS_INFINITY;
       friend class NodeclBase;
    public:
    MinusInfinity() : NodeclBase() { }
    MinusInfinity(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MinusInfinity make(TL::Type type, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class Analysis::PlusInfinity : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_PLUS_INFINITY;
       friend class NodeclBase;
    public:
    PlusInfinity() : NodeclBase() { }
    PlusInfinity(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PlusInfinity make(TL::Type type, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class Analysis::Minimum : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_MINIMUM;
       friend class NodeclBase;
    public:
    Minimum() : NodeclBase() { }
    Minimum(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Minimum make(Nodecl::NodeclBase child_expressions, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Maximum : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_MAXIMUM;
       friend class NodeclBase;
    public:
    Maximum() : NodeclBase() { }
    Maximum(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Maximum make(Nodecl::NodeclBase child_expressions, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class StringLiteral : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_STRING_LITERAL;
       friend class NodeclBase;
    public:
    StringLiteral() : NodeclBase() { }
    StringLiteral(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static StringLiteral make(TL::Type type, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::Schedule : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_SCHEDULE;
       friend class NodeclBase;
    public:
    Schedule() : NodeclBase() { }
    Schedule(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Schedule make(Nodecl::NodeclBase child_chunk, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_chunk() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_chunk(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::DistSchedule : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_DIST_SCHEDULE;
       friend class NodeclBase;
    public:
    DistSchedule() : NodeclBase() { }
    DistSchedule(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DistSchedule make(Nodecl::NodeclBase child_chunk, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_chunk() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_chunk(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::TargetDeclaration : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_TARGET_DECLARATION;
       friend class NodeclBase;
    public:
    TargetDeclaration() : NodeclBase() { }
    TargetDeclaration(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TargetDeclaration make(Nodecl::NodeclBase child_devices, Nodecl::NodeclBase child_symbols, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_devices() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_devices(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_symbols() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_symbols(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class GccAsmDefinition : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_GCC_ASM_DEFINITION;
       friend class NodeclBase;
    public:
    GccAsmDefinition() : NodeclBase() { }
    GccAsmDefinition(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static GccAsmDefinition make(Nodecl::NodeclBase child_operands0, Nodecl::NodeclBase child_operands1, Nodecl::NodeclBase child_operands2, Nodecl::NodeclBase child_specs, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_operands0() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_operands0(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_operands1() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_operands1(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_operands2() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_operands2(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_specs() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_specs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class OpenMP::Taskwait : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TASKWAIT;
       friend class NodeclBase;
    public:
    Taskwait() : NodeclBase() { }
    Taskwait(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Taskwait make(Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Taskgroup : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TASKGROUP;
       friend class NodeclBase;
    public:
    Taskgroup() : NodeclBase() { }
    Taskgroup(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Taskgroup make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::FlushMemory : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_FLUSH_MEMORY;
       friend class NodeclBase;
    public:
    FlushMemory() : NodeclBase() { }
    FlushMemory(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FlushMemory make(Nodecl::NodeclBase child_expressions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::BarrierFull : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_BARRIER_FULL;
       friend class NodeclBase;
    public:
    BarrierFull() : NodeclBase() { }
    BarrierFull(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BarrierFull make(Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::BarrierSignal : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_BARRIER_SIGNAL;
       friend class NodeclBase;
    public:
    BarrierSignal() : NodeclBase() { }
    BarrierSignal(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BarrierSignal make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::BarrierWait : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_BARRIER_WAIT;
       friend class NodeclBase;
    public:
    BarrierWait() : NodeclBase() { }
    BarrierWait(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BarrierWait make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::ParallelSimdFor : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_PARALLEL_SIMD_FOR;
       friend class NodeclBase;
    public:
    ParallelSimdFor() : NodeclBase() { }
    ParallelSimdFor(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ParallelSimdFor make(Nodecl::NodeclBase child_statement, Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class PragmaCustomDeclaration : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PRAGMA_CUSTOM_DECLARATION;
       friend class NodeclBase;
    public:
    PragmaCustomDeclaration() : NodeclBase() { }
    PragmaCustomDeclaration(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PragmaCustomDeclaration make(Nodecl::NodeclBase child_pragma_line, Nodecl::NodeclBase child_nested_pragma, Nodecl::NodeclBase child_context_of_decl, Nodecl::NodeclBase child_context_of_parameters, TL::Symbol symbol, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_pragma_line() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_pragma_line(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_nested_pragma() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_nested_pragma(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_context_of_decl() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_context_of_decl(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_context_of_parameters() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_context_of_parameters(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class LoopControl : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_LOOP_CONTROL;
       friend class NodeclBase;
    public:
    LoopControl() : NodeclBase() { }
    LoopControl(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static LoopControl make(Nodecl::NodeclBase child_init, Nodecl::NodeclBase child_cond, Nodecl::NodeclBase child_next, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_cond() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_cond(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_next() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_next(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class UnboundedLoopControl : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_UNBOUNDED_LOOP_CONTROL;
       friend class NodeclBase;
    public:
    UnboundedLoopControl() : NodeclBase() { }
    UnboundedLoopControl(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static UnboundedLoopControl make(const locus_t *location = ::make_locus("", 0, 0));

};
class Symbol : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_SYMBOL;
       friend class NodeclBase;
    public:
    Symbol() : NodeclBase() { }
    Symbol(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Symbol make(TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

};
class FortranIoSpec : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_IO_SPEC;
       friend class NodeclBase;
    public:
    FortranIoSpec() : NodeclBase() { }
    FortranIoSpec(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranIoSpec make(Nodecl::NodeclBase child_value, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_value() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_value(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Single : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_SINGLE;
       friend class NodeclBase;
    public:
    Single() : NodeclBase() { }
    Single(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Single make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class AlignedFlag : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ALIGNED_FLAG;
       friend class NodeclBase;
    public:
    AlignedFlag() : NodeclBase() { }
    AlignedFlag(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static AlignedFlag make(const locus_t *location = ::make_locus("", 0, 0));

};
class AlignmentInfo : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ALIGNMENT_INFO;
       friend class NodeclBase;
    public:
    AlignmentInfo() : NodeclBase() { }
    AlignmentInfo(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static AlignmentInfo make(const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class InPlaceFlag : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_IN_PLACE_FLAG;
       friend class NodeclBase;
    public:
    InPlaceFlag() : NodeclBase() { }
    InPlaceFlag(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static InPlaceFlag make(const locus_t *location = ::make_locus("", 0, 0));

};
class OnTopFlag : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ON_TOP_FLAG;
       friend class NodeclBase;
    public:
    OnTopFlag() : NodeclBase() { }
    OnTopFlag(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static OnTopFlag make(const locus_t *location = ::make_locus("", 0, 0));

};
class EvictFlag : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_EVICT_FLAG;
       friend class NodeclBase;
    public:
    EvictFlag() : NodeclBase() { }
    EvictFlag(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static EvictFlag make(const locus_t *location = ::make_locus("", 0, 0));

};
class RelaxedFlag : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_RELAXED_FLAG;
       friend class NodeclBase;
    public:
    RelaxedFlag() : NodeclBase() { }
    RelaxedFlag(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static RelaxedFlag make(const locus_t *location = ::make_locus("", 0, 0));

};
class NontemporalFlag : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_NONTEMPORAL_FLAG;
       friend class NodeclBase;
    public:
    NontemporalFlag() : NodeclBase() { }
    NontemporalFlag(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static NontemporalFlag make(const locus_t *location = ::make_locus("", 0, 0));

};
class HasBeenDefinedFlag : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_HAS_BEEN_DEFINED_FLAG;
       friend class NodeclBase;
    public:
    HasBeenDefinedFlag() : NodeclBase() { }
    HasBeenDefinedFlag(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static HasBeenDefinedFlag make(const locus_t *location = ::make_locus("", 0, 0));

};
class FunctionCode : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FUNCTION_CODE;
       friend class NodeclBase;
    public:
    FunctionCode() : NodeclBase() { }
    FunctionCode(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FunctionCode make(Nodecl::NodeclBase child_statements, Nodecl::NodeclBase child_initializers, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_initializers() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_initializers(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OmpSs::TaskCall : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_TASK_CALL;
       friend class NodeclBase;
    public:
    TaskCall() : NodeclBase() { }
    TaskCall(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TaskCall make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_call, Nodecl::NodeclBase child_site_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_call() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_call(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_site_environment() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_site_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class OpenMP::Taskyield : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TASKYIELD;
       friend class NodeclBase;
    public:
    Taskyield() : NodeclBase() { }
    Taskyield(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Taskyield make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::Workshare : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_WORKSHARE;
       friend class NodeclBase;
    public:
    Workshare() : NodeclBase() { }
    Workshare(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Workshare make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class PragmaClauseArg : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PRAGMA_CLAUSE_ARG;
       friend class NodeclBase;
    public:
    PragmaClauseArg() : NodeclBase() { }
    PragmaClauseArg(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PragmaClauseArg make(const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::SimdFunction : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_SIMD_FUNCTION;
       friend class NodeclBase;
    public:
    SimdFunction() : NodeclBase() { }
    SimdFunction(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static SimdFunction make(Nodecl::NodeclBase child_statement, Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class MemberInit : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_MEMBER_INIT;
       friend class NodeclBase;
    public:
    MemberInit() : NodeclBase() { }
    MemberInit(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MemberInit make(Nodecl::NodeclBase child_init_expr, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class ImplicitMemberInit : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_IMPLICIT_MEMBER_INIT;
       friend class NodeclBase;
    public:
    ImplicitMemberInit() : NodeclBase() { }
    ImplicitMemberInit(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ImplicitMemberInit make(Nodecl::NodeclBase child_init_expr, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Atomic : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_ATOMIC;
       friend class NodeclBase;
    public:
    Atomic() : NodeclBase() { }
    Atomic(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Atomic make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CxxClassMemberAccess : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_CLASS_MEMBER_ACCESS;
       friend class NodeclBase;
    public:
    CxxClassMemberAccess() : NodeclBase() { }
    CxxClassMemberAccess(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxClassMemberAccess make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_member, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_member() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_member(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CxxArrow : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_ARROW;
       friend class NodeclBase;
    public:
    CxxArrow() : NodeclBase() { }
    CxxArrow(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxArrow make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_member, TL::Type type, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_member() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_member(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CxxDotPtrMember : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DOT_PTR_MEMBER;
       friend class NodeclBase;
    public:
    CxxDotPtrMember() : NodeclBase() { }
    CxxDotPtrMember(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDotPtrMember make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_ptr, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_ptr() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_ptr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CxxArrowPtrMember : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_ARROW_PTR_MEMBER;
       friend class NodeclBase;
    public:
    CxxArrowPtrMember() : NodeclBase() { }
    CxxArrowPtrMember(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxArrowPtrMember make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_ptr, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_ptr() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_ptr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CxxSizeof : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_SIZEOF;
       friend class NodeclBase;
    public:
    CxxSizeof() : NodeclBase() { }
    CxxSizeof(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxSizeof make(Nodecl::NodeclBase child_expr, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxSizeofPack : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_SIZEOF_PACK;
       friend class NodeclBase;
    public:
    CxxSizeofPack() : NodeclBase() { }
    CxxSizeofPack(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxSizeofPack make(Nodecl::NodeclBase child_expr, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxAlignof : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_ALIGNOF;
       friend class NodeclBase;
    public:
    CxxAlignof() : NodeclBase() { }
    CxxAlignof(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxAlignof make(Nodecl::NodeclBase child_expr, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxPostfixInitializer : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_POSTFIX_INITIALIZER;
       friend class NodeclBase;
    public:
    CxxPostfixInitializer() : NodeclBase() { }
    CxxPostfixInitializer(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxPostfixInitializer make(Nodecl::NodeclBase child_postfix, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_postfix() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_postfix(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxCast : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_CAST;
       friend class NodeclBase;
    public:
    CxxCast() : NodeclBase() { }
    CxxCast(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxCast make(Nodecl::NodeclBase child_rhs, TL::Type type, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxExplicitTypeCast : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_EXPLICIT_TYPE_CAST;
       friend class NodeclBase;
    public:
    CxxExplicitTypeCast() : NodeclBase() { }
    CxxExplicitTypeCast(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxExplicitTypeCast make(Nodecl::NodeclBase child_init_list, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init_list() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init_list(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxDepFunctionCall : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DEP_FUNCTION_CALL;
       friend class NodeclBase;
    public:
    CxxDepFunctionCall() : NodeclBase() { }
    CxxDepFunctionCall(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDepFunctionCall make(Nodecl::NodeclBase child_called, Nodecl::NodeclBase child_arguments, Nodecl::NodeclBase child_alternate_name, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_called() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_called(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_arguments() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_arguments(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_alternate_name() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_alternate_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class CxxDepNew : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DEP_NEW;
       friend class NodeclBase;
    public:
    CxxDepNew() : NodeclBase() { }
    CxxDepNew(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDepNew make(Nodecl::NodeclBase child_init, Nodecl::NodeclBase child_init_real_type, Nodecl::NodeclBase child_placement, TL::Type type, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_init_real_type() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_init_real_type(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_placement() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_placement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class CxxNoexcept : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_NOEXCEPT;
       friend class NodeclBase;
    public:
    CxxNoexcept() : NodeclBase() { }
    CxxNoexcept(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxNoexcept make(Nodecl::NodeclBase child_expr, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxLambda : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_LAMBDA;
       friend class NodeclBase;
    public:
    CxxLambda() : NodeclBase() { }
    CxxLambda(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxLambda make(Nodecl::NodeclBase child_explicit_captures, TL::Symbol symbol, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_explicit_captures() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_explicit_captures(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxAlignas : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_ALIGNAS;
       friend class NodeclBase;
    public:
    CxxAlignas() : NodeclBase() { }
    CxxAlignas(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxAlignas make(Nodecl::NodeclBase child_values, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_values() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_values(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class StructuredValue : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_STRUCTURED_VALUE;
       friend class NodeclBase;
    public:
    StructuredValue() : NodeclBase() { }
    StructuredValue(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static StructuredValue make(Nodecl::NodeclBase child_items, Nodecl::NodeclBase child_form, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_items() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_form() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_form(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranData : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_DATA;
       friend class NodeclBase;
    public:
    FortranData() : NodeclBase() { }
    FortranData(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranData make(Nodecl::NodeclBase child_objects, Nodecl::NodeclBase child_values, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_objects() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_objects(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_values() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_values(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranEquivalence : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_EQUIVALENCE;
       friend class NodeclBase;
    public:
    FortranEquivalence() : NodeclBase() { }
    FortranEquivalence(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranEquivalence make(Nodecl::NodeclBase child_first, Nodecl::NodeclBase child_second, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_first() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_first(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_second() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_second(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranBozLiteral : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_BOZ_LITERAL;
       friend class NodeclBase;
    public:
    FortranBozLiteral() : NodeclBase() { }
    FortranBozLiteral(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranBozLiteral make(TL::Type type, const std::string& text, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class FortranBindC : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_BIND_C;
       friend class NodeclBase;
    public:
    FortranBindC() : NodeclBase() { }
    FortranBindC(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranBindC make(Nodecl::NodeclBase child_name, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranHollerith : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_HOLLERITH;
       friend class NodeclBase;
    public:
    FortranHollerith() : NodeclBase() { }
    FortranHollerith(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranHollerith make(TL::Type type, const std::string& text, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class FortranUse : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_USE;
       friend class NodeclBase;
    public:
    FortranUse() : NodeclBase() { }
    FortranUse(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranUse make(Nodecl::NodeclBase child_module, Nodecl::NodeclBase child_renamed_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_module() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_module(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_renamed_items() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_renamed_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranUseOnly : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_USE_ONLY;
       friend class NodeclBase;
    public:
    FortranUseOnly() : NodeclBase() { }
    FortranUseOnly(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranUseOnly make(Nodecl::NodeclBase child_module, Nodecl::NodeclBase child_only_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_module() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_module(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_only_items() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_only_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::Simd : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_SIMD;
       friend class NodeclBase;
    public:
    Simd() : NodeclBase() { }
    Simd(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Simd make(Nodecl::NodeclBase child_statement, Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranActualArgument : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_ACTUAL_ARGUMENT;
       friend class NodeclBase;
    public:
    FortranActualArgument() : NodeclBase() { }
    FortranActualArgument(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranActualArgument make(Nodecl::NodeclBase child_argument, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_argument() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_argument(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranNotPresent : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_NOT_PRESENT;
       friend class NodeclBase;
    public:
    FortranNotPresent() : NodeclBase() { }
    FortranNotPresent(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranNotPresent make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::FlushAtEntry : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_FLUSH_AT_ENTRY;
       friend class NodeclBase;
    public:
    FlushAtEntry() : NodeclBase() { }
    FlushAtEntry(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FlushAtEntry make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::FlushAtExit : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_FLUSH_AT_EXIT;
       friend class NodeclBase;
    public:
    FlushAtExit() : NodeclBase() { }
    FlushAtExit(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FlushAtExit make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::NoFlush : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_NO_FLUSH;
       friend class NodeclBase;
    public:
    NoFlush() : NodeclBase() { }
    NoFlush(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static NoFlush make(const locus_t *location = ::make_locus("", 0, 0));

};
class DefaultArgument : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_DEFAULT_ARGUMENT;
       friend class NodeclBase;
    public:
    DefaultArgument() : NodeclBase() { }
    DefaultArgument(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DefaultArgument make(Nodecl::NodeclBase child_argument, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_argument() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_argument(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxMemberInit : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_MEMBER_INIT;
       friend class NodeclBase;
    public:
    CxxMemberInit() : NodeclBase() { }
    CxxMemberInit(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxMemberInit make(Nodecl::NodeclBase child_name, Nodecl::NodeclBase child_initializer, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_initializer() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_initializer(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class MultiExpressionIterator : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_MULTI_EXPRESSION_ITERATOR;
       friend class NodeclBase;
    public:
    MultiExpressionIterator() : NodeclBase() { }
    MultiExpressionIterator(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MultiExpressionIterator make(Nodecl::NodeclBase child_range, TL::Symbol symbol, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_range() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_range(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Section : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_SECTION;
       friend class NodeclBase;
    public:
    Section() : NodeclBase() { }
    Section(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Section make(Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CompoundStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_COMPOUND_STATEMENT;
       friend class NodeclBase;
    public:
    CompoundStatement() : NodeclBase() { }
    CompoundStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CompoundStatement make(Nodecl::NodeclBase child_statements, Nodecl::NodeclBase child_finally, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_finally() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_finally(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class EmptyStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_EMPTY_STATEMENT;
       friend class NodeclBase;
    public:
    EmptyStatement() : NodeclBase() { }
    EmptyStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static EmptyStatement make(const locus_t *location = ::make_locus("", 0, 0));

};
class ExpressionStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_EXPRESSION_STATEMENT;
       friend class NodeclBase;
    public:
    ExpressionStatement() : NodeclBase() { }
    ExpressionStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ExpressionStatement make(Nodecl::NodeclBase child_nest, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_nest() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_nest(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class DoStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_DO_STATEMENT;
       friend class NodeclBase;
    public:
    DoStatement() : NodeclBase() { }
    DoStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DoStatement make(Nodecl::NodeclBase child_statement, Nodecl::NodeclBase child_condition, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_condition() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_condition(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class WhileStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_WHILE_STATEMENT;
       friend class NodeclBase;
    public:
    WhileStatement() : NodeclBase() { }
    WhileStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static WhileStatement make(Nodecl::NodeclBase child_condition, Nodecl::NodeclBase child_statement, Nodecl::NodeclBase child_loop_name, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_condition() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_condition(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_loop_name() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_loop_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class ForStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FOR_STATEMENT;
       friend class NodeclBase;
    public:
    ForStatement() : NodeclBase() { }
    ForStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ForStatement make(Nodecl::NodeclBase child_loop_header, Nodecl::NodeclBase child_statement, Nodecl::NodeclBase child_loop_name, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_loop_header() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_loop_header(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_loop_name() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_loop_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class IfElseStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_IF_ELSE_STATEMENT;
       friend class NodeclBase;
    public:
    IfElseStatement() : NodeclBase() { }
    IfElseStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IfElseStatement make(Nodecl::NodeclBase child_condition, Nodecl::NodeclBase child_then, Nodecl::NodeclBase child_else, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_condition() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_condition(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_then() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_then(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_else() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_else(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class LabeledStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_LABELED_STATEMENT;
       friend class NodeclBase;
    public:
    LabeledStatement() : NodeclBase() { }
    LabeledStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static LabeledStatement make(Nodecl::NodeclBase child_statement, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class SwitchStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_SWITCH_STATEMENT;
       friend class NodeclBase;
    public:
    SwitchStatement() : NodeclBase() { }
    SwitchStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static SwitchStatement make(Nodecl::NodeclBase child_switch, Nodecl::NodeclBase child_statement, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_switch() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_switch(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class DefaultStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_DEFAULT_STATEMENT;
       friend class NodeclBase;
    public:
    DefaultStatement() : NodeclBase() { }
    DefaultStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DefaultStatement make(Nodecl::NodeclBase child_statement, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CaseStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CASE_STATEMENT;
       friend class NodeclBase;
    public:
    CaseStatement() : NodeclBase() { }
    CaseStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CaseStatement make(Nodecl::NodeclBase child_case, Nodecl::NodeclBase child_statement, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_case() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_case(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BreakStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BREAK_STATEMENT;
       friend class NodeclBase;
    public:
    BreakStatement() : NodeclBase() { }
    BreakStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BreakStatement make(Nodecl::NodeclBase child_construct_name, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_construct_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_construct_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class ContinueStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CONTINUE_STATEMENT;
       friend class NodeclBase;
    public:
    ContinueStatement() : NodeclBase() { }
    ContinueStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ContinueStatement make(Nodecl::NodeclBase child_construct_name, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_construct_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_construct_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class GotoStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_GOTO_STATEMENT;
       friend class NodeclBase;
    public:
    GotoStatement() : NodeclBase() { }
    GotoStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static GotoStatement make(TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

};
class ReturnStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_RETURN_STATEMENT;
       friend class NodeclBase;
    public:
    ReturnStatement() : NodeclBase() { }
    ReturnStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ReturnStatement make(Nodecl::NodeclBase child_value, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_value() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_value(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class ErrStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ERR_STATEMENT;
       friend class NodeclBase;
    public:
    ErrStatement() : NodeclBase() { }
    ErrStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ErrStatement make(const locus_t *location = ::make_locus("", 0, 0));

};
class ObjectInit : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OBJECT_INIT;
       friend class NodeclBase;
    public:
    ObjectInit() : NodeclBase() { }
    ObjectInit(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ObjectInit make(TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

};
class GccAsmSpec : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_GCC_ASM_SPEC;
       friend class NodeclBase;
    public:
    GccAsmSpec() : NodeclBase() { }
    GccAsmSpec(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static GccAsmSpec make(const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

};
class Context : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CONTEXT;
       friend class NodeclBase;
    public:
    Context() : NodeclBase() { }
    Context(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Context make(Nodecl::NodeclBase child_in_context, TL::Scope scope, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_in_context() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_in_context(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Parallel : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_PARALLEL;
       friend class NodeclBase;
    public:
    Parallel() : NodeclBase() { }
    Parallel(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Parallel make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_num_replicas, Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_num_replicas() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_num_replicas(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class FunctionCall : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FUNCTION_CALL;
       friend class NodeclBase;
    public:
    FunctionCall() : NodeclBase() { }
    FunctionCall(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FunctionCall make(Nodecl::NodeclBase child_called, Nodecl::NodeclBase child_arguments, Nodecl::NodeclBase child_alternate_name, Nodecl::NodeclBase child_function_form, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_called() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_called(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_arguments() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_arguments(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_alternate_name() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_alternate_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_function_form() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_function_form(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class ArraySubscript : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ARRAY_SUBSCRIPT;
       friend class NodeclBase;
    public:
    ArraySubscript() : NodeclBase() { }
    ArraySubscript(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ArraySubscript make(Nodecl::NodeclBase child_subscripted, Nodecl::NodeclBase child_subscripts, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_subscripted() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_subscripted(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_subscripts() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_subscripts(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class ClassMemberAccess : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CLASS_MEMBER_ACCESS;
       friend class NodeclBase;
    public:
    ClassMemberAccess() : NodeclBase() { }
    ClassMemberAccess(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ClassMemberAccess make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_member, Nodecl::NodeclBase child_member_literal, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_member() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_member(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_member_literal() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_member_literal(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class Plus : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PLUS;
       friend class NodeclBase;
    public:
    Plus() : NodeclBase() { }
    Plus(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Plus make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Neg : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_NEG;
       friend class NodeclBase;
    public:
    Neg() : NodeclBase() { }
    Neg(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Neg make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Mul : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_MUL;
       friend class NodeclBase;
    public:
    Mul() : NodeclBase() { }
    Mul(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Mul make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Power : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_POWER;
       friend class NodeclBase;
    public:
    Power() : NodeclBase() { }
    Power(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Power make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Div : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_DIV;
       friend class NodeclBase;
    public:
    Div() : NodeclBase() { }
    Div(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Div make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Mod : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_MOD;
       friend class NodeclBase;
    public:
    Mod() : NodeclBase() { }
    Mod(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Mod make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Add : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ADD;
       friend class NodeclBase;
    public:
    Add() : NodeclBase() { }
    Add(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Add make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Minus : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_MINUS;
       friend class NodeclBase;
    public:
    Minus() : NodeclBase() { }
    Minus(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Minus make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Concat : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CONCAT;
       friend class NodeclBase;
    public:
    Concat() : NodeclBase() { }
    Concat(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Concat make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Equal : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_EQUAL;
       friend class NodeclBase;
    public:
    Equal() : NodeclBase() { }
    Equal(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Equal make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Different : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_DIFFERENT;
       friend class NodeclBase;
    public:
    Different() : NodeclBase() { }
    Different(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Different make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class LowerThan : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_LOWER_THAN;
       friend class NodeclBase;
    public:
    LowerThan() : NodeclBase() { }
    LowerThan(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static LowerThan make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class LowerOrEqualThan : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_LOWER_OR_EQUAL_THAN;
       friend class NodeclBase;
    public:
    LowerOrEqualThan() : NodeclBase() { }
    LowerOrEqualThan(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static LowerOrEqualThan make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class GreaterThan : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_GREATER_THAN;
       friend class NodeclBase;
    public:
    GreaterThan() : NodeclBase() { }
    GreaterThan(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static GreaterThan make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class GreaterOrEqualThan : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_GREATER_OR_EQUAL_THAN;
       friend class NodeclBase;
    public:
    GreaterOrEqualThan() : NodeclBase() { }
    GreaterOrEqualThan(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static GreaterOrEqualThan make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class LogicalNot : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_LOGICAL_NOT;
       friend class NodeclBase;
    public:
    LogicalNot() : NodeclBase() { }
    LogicalNot(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static LogicalNot make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class LogicalAnd : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_LOGICAL_AND;
       friend class NodeclBase;
    public:
    LogicalAnd() : NodeclBase() { }
    LogicalAnd(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static LogicalAnd make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class LogicalOr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_LOGICAL_OR;
       friend class NodeclBase;
    public:
    LogicalOr() : NodeclBase() { }
    LogicalOr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static LogicalOr make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BitwiseNot : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_NOT;
       friend class NodeclBase;
    public:
    BitwiseNot() : NodeclBase() { }
    BitwiseNot(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseNot make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class BitwiseAnd : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_AND;
       friend class NodeclBase;
    public:
    BitwiseAnd() : NodeclBase() { }
    BitwiseAnd(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseAnd make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BitwiseOr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_OR;
       friend class NodeclBase;
    public:
    BitwiseOr() : NodeclBase() { }
    BitwiseOr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseOr make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BitwiseXor : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_XOR;
       friend class NodeclBase;
    public:
    BitwiseXor() : NodeclBase() { }
    BitwiseXor(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseXor make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BitwiseShl : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_SHL;
       friend class NodeclBase;
    public:
    BitwiseShl() : NodeclBase() { }
    BitwiseShl(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseShl make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class ArithmeticShr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ARITHMETIC_SHR;
       friend class NodeclBase;
    public:
    ArithmeticShr() : NodeclBase() { }
    ArithmeticShr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ArithmeticShr make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BitwiseShr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_SHR;
       friend class NodeclBase;
    public:
    BitwiseShr() : NodeclBase() { }
    BitwiseShr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseShr make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Assignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ASSIGNMENT;
       friend class NodeclBase;
    public:
    Assignment() : NodeclBase() { }
    Assignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Assignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class ParenthesizedExpression : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PARENTHESIZED_EXPRESSION;
       friend class NodeclBase;
    public:
    ParenthesizedExpression() : NodeclBase() { }
    ParenthesizedExpression(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ParenthesizedExpression make(Nodecl::NodeclBase child_nest, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_nest() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_nest(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Dereference : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_DEREFERENCE;
       friend class NodeclBase;
    public:
    Dereference() : NodeclBase() { }
    Dereference(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Dereference make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CompoundExpression : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_COMPOUND_EXPRESSION;
       friend class NodeclBase;
    public:
    CompoundExpression() : NodeclBase() { }
    CompoundExpression(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CompoundExpression make(Nodecl::NodeclBase child_nest, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_nest() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_nest(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class VectorSubscript : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_SUBSCRIPT;
       friend class NodeclBase;
    public:
    VectorSubscript() : NodeclBase() { }
    VectorSubscript(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorSubscript make(Nodecl::NodeclBase child_subscripted, Nodecl::NodeclBase child_subscript, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_subscripted() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_subscripted(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_subscript() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_subscript(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorAdd : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_ADD;
       friend class NodeclBase;
    public:
    VectorAdd() : NodeclBase() { }
    VectorAdd(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorAdd make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorFmadd : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_FMADD;
       friend class NodeclBase;
    public:
    VectorFmadd() : NodeclBase() { }
    VectorFmadd(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorFmadd make(Nodecl::NodeclBase child_first_op, Nodecl::NodeclBase child_second_op, Nodecl::NodeclBase child_third_op, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_first_op() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_first_op(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_second_op() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_second_op(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_third_op() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_third_op(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class VectorMinus : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MINUS;
       friend class NodeclBase;
    public:
    VectorMinus() : NodeclBase() { }
    VectorMinus(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMinus make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorFmminus : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_FMMINUS;
       friend class NodeclBase;
    public:
    VectorFmminus() : NodeclBase() { }
    VectorFmminus(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorFmminus make(Nodecl::NodeclBase child_first_mul_op, Nodecl::NodeclBase child_second_mul_op, Nodecl::NodeclBase child_minus_op, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_first_mul_op() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_first_mul_op(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_second_mul_op() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_second_mul_op(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_minus_op() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_minus_op(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class VectorMul : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MUL;
       friend class NodeclBase;
    public:
    VectorMul() : NodeclBase() { }
    VectorMul(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMul make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorDiv : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_DIV;
       friend class NodeclBase;
    public:
    VectorDiv() : NodeclBase() { }
    VectorDiv(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorDiv make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorRcp : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_RCP;
       friend class NodeclBase;
    public:
    VectorRcp() : NodeclBase() { }
    VectorRcp(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorRcp make(Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorMod : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MOD;
       friend class NodeclBase;
    public:
    VectorMod() : NodeclBase() { }
    VectorMod(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMod make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorNeg : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_NEG;
       friend class NodeclBase;
    public:
    VectorNeg() : NodeclBase() { }
    VectorNeg(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorNeg make(Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorSqrt : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_SQRT;
       friend class NodeclBase;
    public:
    VectorSqrt() : NodeclBase() { }
    VectorSqrt(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorSqrt make(Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorRsqrt : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_RSQRT;
       friend class NodeclBase;
    public:
    VectorRsqrt() : NodeclBase() { }
    VectorRsqrt(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorRsqrt make(Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorReductionAdd : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_REDUCTION_ADD;
       friend class NodeclBase;
    public:
    VectorReductionAdd() : NodeclBase() { }
    VectorReductionAdd(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorReductionAdd make(Nodecl::NodeclBase child_vector_src, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_vector_src() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_vector_src(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorReductionMinus : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_REDUCTION_MINUS;
       friend class NodeclBase;
    public:
    VectorReductionMinus() : NodeclBase() { }
    VectorReductionMinus(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorReductionMinus make(Nodecl::NodeclBase child_vector_src, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_vector_src() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_vector_src(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorReductionMul : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_REDUCTION_MUL;
       friend class NodeclBase;
    public:
    VectorReductionMul() : NodeclBase() { }
    VectorReductionMul(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorReductionMul make(Nodecl::NodeclBase child_vector_src, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_vector_src() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_vector_src(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorEqual : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_EQUAL;
       friend class NodeclBase;
    public:
    VectorEqual() : NodeclBase() { }
    VectorEqual(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorEqual make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorDifferent : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_DIFFERENT;
       friend class NodeclBase;
    public:
    VectorDifferent() : NodeclBase() { }
    VectorDifferent(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorDifferent make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorLowerThan : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_LOWER_THAN;
       friend class NodeclBase;
    public:
    VectorLowerThan() : NodeclBase() { }
    VectorLowerThan(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLowerThan make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorLowerOrEqualThan : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_LOWER_OR_EQUAL_THAN;
       friend class NodeclBase;
    public:
    VectorLowerOrEqualThan() : NodeclBase() { }
    VectorLowerOrEqualThan(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLowerOrEqualThan make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorGreaterThan : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_GREATER_THAN;
       friend class NodeclBase;
    public:
    VectorGreaterThan() : NodeclBase() { }
    VectorGreaterThan(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorGreaterThan make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorGreaterOrEqualThan : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_GREATER_OR_EQUAL_THAN;
       friend class NodeclBase;
    public:
    VectorGreaterOrEqualThan() : NodeclBase() { }
    VectorGreaterOrEqualThan(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorGreaterOrEqualThan make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorLogicalNot : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_LOGICAL_NOT;
       friend class NodeclBase;
    public:
    VectorLogicalNot() : NodeclBase() { }
    VectorLogicalNot(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLogicalNot make(Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorLogicalAnd : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_LOGICAL_AND;
       friend class NodeclBase;
    public:
    VectorLogicalAnd() : NodeclBase() { }
    VectorLogicalAnd(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLogicalAnd make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorLogicalOr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_LOGICAL_OR;
       friend class NodeclBase;
    public:
    VectorLogicalOr() : NodeclBase() { }
    VectorLogicalOr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLogicalOr make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorBitwiseNot : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_BITWISE_NOT;
       friend class NodeclBase;
    public:
    VectorBitwiseNot() : NodeclBase() { }
    VectorBitwiseNot(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorBitwiseNot make(Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorBitwiseAnd : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_BITWISE_AND;
       friend class NodeclBase;
    public:
    VectorBitwiseAnd() : NodeclBase() { }
    VectorBitwiseAnd(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorBitwiseAnd make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorBitwiseOr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_BITWISE_OR;
       friend class NodeclBase;
    public:
    VectorBitwiseOr() : NodeclBase() { }
    VectorBitwiseOr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorBitwiseOr make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorBitwiseXor : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_BITWISE_XOR;
       friend class NodeclBase;
    public:
    VectorBitwiseXor() : NodeclBase() { }
    VectorBitwiseXor(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorBitwiseXor make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorBitwiseShl : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_BITWISE_SHL;
       friend class NodeclBase;
    public:
    VectorBitwiseShl() : NodeclBase() { }
    VectorBitwiseShl(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorBitwiseShl make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorArithmeticShr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_ARITHMETIC_SHR;
       friend class NodeclBase;
    public:
    VectorArithmeticShr() : NodeclBase() { }
    VectorArithmeticShr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorArithmeticShr make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorBitwiseShr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_BITWISE_SHR;
       friend class NodeclBase;
    public:
    VectorBitwiseShr() : NodeclBase() { }
    VectorBitwiseShr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorBitwiseShr make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorAlignRight : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_ALIGN_RIGHT;
       friend class NodeclBase;
    public:
    VectorAlignRight() : NodeclBase() { }
    VectorAlignRight(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorAlignRight make(Nodecl::NodeclBase child_left_vector, Nodecl::NodeclBase child_right_vector, Nodecl::NodeclBase child_num_elements, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_left_vector() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_left_vector(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_right_vector() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_right_vector(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_num_elements() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_num_elements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class VectorAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_ASSIGNMENT;
       friend class NodeclBase;
    public:
    VectorAssignment() : NodeclBase() { }
    VectorAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, Nodecl::NodeclBase child_has_been_defined, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_has_been_defined() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_has_been_defined(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class VectorStore : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_STORE;
       friend class NodeclBase;
    public:
    VectorStore() : NodeclBase() { }
    VectorStore(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorStore make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, Nodecl::NodeclBase child_flags, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_flags() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_flags(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class VectorScatter : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_SCATTER;
       friend class NodeclBase;
    public:
    VectorScatter() : NodeclBase() { }
    VectorScatter(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorScatter make(Nodecl::NodeclBase child_base, Nodecl::NodeclBase child_strides, Nodecl::NodeclBase child_source, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_base() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_base(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_strides() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_strides(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_source() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_source(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class VectorLoad : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_LOAD;
       friend class NodeclBase;
    public:
    VectorLoad() : NodeclBase() { }
    VectorLoad(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLoad make(Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, Nodecl::NodeclBase child_flags, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_flags() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_flags(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorGather : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_GATHER;
       friend class NodeclBase;
    public:
    VectorGather() : NodeclBase() { }
    VectorGather(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorGather make(Nodecl::NodeclBase child_base, Nodecl::NodeclBase child_strides, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_base() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_base(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_strides() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_strides(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VectorPromotion : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_PROMOTION;
       friend class NodeclBase;
    public:
    VectorPromotion() : NodeclBase() { }
    VectorPromotion(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorPromotion make(Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorPrefetch : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_PREFETCH;
       friend class NodeclBase;
    public:
    VectorPrefetch() : NodeclBase() { }
    VectorPrefetch(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorPrefetch make(Nodecl::NodeclBase child_address, Nodecl::NodeclBase child_prefetch_kind, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_address() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_address(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_prefetch_kind() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_prefetch_kind(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorLiteral : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_LITERAL;
       friend class NodeclBase;
    public:
    VectorLiteral() : NodeclBase() { }
    VectorLiteral(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLiteral make(Nodecl::NodeclBase child_scalar_values, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_scalar_values() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_scalar_values(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorLaneId : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_LANE_ID;
       friend class NodeclBase;
    public:
    VectorLaneId() : NodeclBase() { }
    VectorLaneId(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLaneId make(TL::Type type, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class VectorConversion : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_CONVERSION;
       friend class NodeclBase;
    public:
    VectorConversion() : NodeclBase() { }
    VectorConversion(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorConversion make(Nodecl::NodeclBase child_nest, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_nest() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_nest(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorCast : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_CAST;
       friend class NodeclBase;
    public:
    VectorCast() : NodeclBase() { }
    VectorCast(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorCast make(Nodecl::NodeclBase child_rhs, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorFunctionCall : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_FUNCTION_CALL;
       friend class NodeclBase;
    public:
    VectorFunctionCall() : NodeclBase() { }
    VectorFunctionCall(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorFunctionCall make(Nodecl::NodeclBase child_function_call, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_function_call() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_function_call(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorFabs : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_FABS;
       friend class NodeclBase;
    public:
    VectorFabs() : NodeclBase() { }
    VectorFabs(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorFabs make(Nodecl::NodeclBase child_argument, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_argument() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_argument(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorSincos : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_SINCOS;
       friend class NodeclBase;
    public:
    VectorSincos() : NodeclBase() { }
    VectorSincos(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorSincos make(Nodecl::NodeclBase child_source, Nodecl::NodeclBase child_sin_pointer, Nodecl::NodeclBase child_cos_pointer, Nodecl::NodeclBase child_mask, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_source() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_source(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_sin_pointer() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_sin_pointer(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_cos_pointer() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_cos_pointer(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class VectorMaskAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MASK_ASSIGNMENT;
       friend class NodeclBase;
    public:
    VectorMaskAssignment() : NodeclBase() { }
    VectorMaskAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMaskAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorMaskConversion : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MASK_CONVERSION;
       friend class NodeclBase;
    public:
    VectorMaskConversion() : NodeclBase() { }
    VectorMaskConversion(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMaskConversion make(Nodecl::NodeclBase child_nest, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_nest() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_nest(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class VectorMaskNot : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MASK_NOT;
       friend class NodeclBase;
    public:
    VectorMaskNot() : NodeclBase() { }
    VectorMaskNot(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMaskNot make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class VectorMaskAnd : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MASK_AND;
       friend class NodeclBase;
    public:
    VectorMaskAnd() : NodeclBase() { }
    VectorMaskAnd(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMaskAnd make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorMaskOr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MASK_OR;
       friend class NodeclBase;
    public:
    VectorMaskOr() : NodeclBase() { }
    VectorMaskOr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMaskOr make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorMaskXor : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MASK_XOR;
       friend class NodeclBase;
    public:
    VectorMaskXor() : NodeclBase() { }
    VectorMaskXor(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMaskXor make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorMaskAnd1Not : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MASK_AND_1_NOT;
       friend class NodeclBase;
    public:
    VectorMaskAnd1Not() : NodeclBase() { }
    VectorMaskAnd1Not(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMaskAnd1Not make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorMaskAnd2Not : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_MASK_AND_2_NOT;
       friend class NodeclBase;
    public:
    VectorMaskAnd2Not() : NodeclBase() { }
    VectorMaskAnd2Not(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorMaskAnd2Not make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class VectorLoop : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_LOOP;
       friend class NodeclBase;
    public:
    VectorLoop() : NodeclBase() { }
    VectorLoop(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLoop make(Nodecl::NodeclBase child_peeling, Nodecl::NodeclBase child_main_loop, Nodecl::NodeclBase child_epilog, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_peeling() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_peeling(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_main_loop() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_main_loop(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_epilog() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_epilog(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class NoexceptImplicitTrue : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_NOEXCEPT_IMPLICIT_TRUE;
       friend class NodeclBase;
    public:
    NoexceptImplicitTrue() : NodeclBase() { }
    NoexceptImplicitTrue(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static NoexceptImplicitTrue make(TL::Type type, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class ErrExpr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ERR_EXPR;
       friend class NodeclBase;
    public:
    ErrExpr() : NodeclBase() { }
    ErrExpr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ErrExpr make(const locus_t *location = ::make_locus("", 0, 0));

};
class Conversion : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CONVERSION;
       friend class NodeclBase;
    public:
    Conversion() : NodeclBase() { }
    Conversion(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Conversion make(Nodecl::NodeclBase child_nest, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_nest() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_nest(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Dummy : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_DUMMY;
       friend class NodeclBase;
    public:
    Dummy() : NodeclBase() { }
    Dummy(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Dummy make(TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

};
class MultiExpression : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_MULTI_EXPRESSION;
       friend class NodeclBase;
    public:
    MultiExpression() : NodeclBase() { }
    MultiExpression(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MultiExpression make(Nodecl::NodeclBase child_iterators, Nodecl::NodeclBase child_expr, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_iterators() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_iterators(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Unknown : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_UNKNOWN;
       friend class NodeclBase;
    public:
    Unknown() : NodeclBase() { }
    Unknown(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Unknown make(const locus_t *location = ::make_locus("", 0, 0));

};
class FortranAlternateReturnArgument : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_ALTERNATE_RETURN_ARGUMENT;
       friend class NodeclBase;
    public:
    FortranAlternateReturnArgument() : NodeclBase() { }
    FortranAlternateReturnArgument(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranAlternateReturnArgument make(TL::Symbol symbol, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

};
class RangeDiscrete : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_RANGE_DISCRETE;
       friend class NodeclBase;
    public:
    RangeDiscrete() : NodeclBase() { }
    RangeDiscrete(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static RangeDiscrete make(Nodecl::NodeclBase child_discrete_seq, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_discrete_seq() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_discrete_seq(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranWherePair : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_WHERE_PAIR;
       friend class NodeclBase;
    public:
    FortranWherePair() : NodeclBase() { }
    FortranWherePair(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranWherePair make(Nodecl::NodeclBase child_mask, Nodecl::NodeclBase child_statement, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class GxxTrait : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_GXX_TRAIT;
       friend class NodeclBase;
    public:
    GxxTrait() : NodeclBase() { }
    GxxTrait(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static GxxTrait make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Analysis::InductionVarExpr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_INDUCTION_VAR_EXPR;
       friend class NodeclBase;
    public:
    InductionVarExpr() : NodeclBase() { }
    InductionVarExpr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static InductionVarExpr make(Nodecl::NodeclBase child_variable, Nodecl::NodeclBase child_lower, Nodecl::NodeclBase child_upper, Nodecl::NodeclBase child_stride, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_variable() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_variable(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_lower() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_lower(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_upper() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_upper(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_stride() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_stride(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class OpenMP::CombinedWithParallel : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_COMBINED_WITH_PARALLEL;
       friend class NodeclBase;
    public:
    CombinedWithParallel() : NodeclBase() { }
    CombinedWithParallel(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CombinedWithParallel make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::FunctionTaskParsingContext : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_FUNCTION_TASK_PARSING_CONTEXT;
       friend class NodeclBase;
    public:
    FunctionTaskParsingContext() : NodeclBase() { }
    FunctionTaskParsingContext(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FunctionTaskParsingContext make(Nodecl::NodeclBase child_context, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_context() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_context(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::TaskExpression : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_TASK_EXPRESSION;
       friend class NodeclBase;
    public:
    TaskExpression() : NodeclBase() { }
    TaskExpression(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TaskExpression make(Nodecl::NodeclBase child_join_task, Nodecl::NodeclBase child_task_calls, Nodecl::NodeclBase child_sequential_code, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_join_task() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_join_task(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_task_calls() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_task_calls(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_sequential_code() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_sequential_code(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class OpenMP::NumTasks : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_NUM_TASKS;
       friend class NodeclBase;
    public:
    NumTasks() : NodeclBase() { }
    NumTasks(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static NumTasks make(Nodecl::NodeclBase child_num_tasks, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_num_tasks() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_num_tasks(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Grainsize : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_GRAINSIZE;
       friend class NodeclBase;
    public:
    Grainsize() : NodeclBase() { }
    Grainsize(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Grainsize make(Nodecl::NodeclBase child_grainsize, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_grainsize() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_grainsize(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::Chunksize : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_CHUNKSIZE;
       friend class NodeclBase;
    public:
    Chunksize() : NodeclBase() { }
    Chunksize(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Chunksize make(Nodecl::NodeclBase child_chunksize, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_chunksize() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_chunksize(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class ConditionalExpression : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CONDITIONAL_EXPRESSION;
       friend class NodeclBase;
    public:
    ConditionalExpression() : NodeclBase() { }
    ConditionalExpression(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ConditionalExpression make(Nodecl::NodeclBase child_condition, Nodecl::NodeclBase child_true, Nodecl::NodeclBase child_false, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_condition() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_condition(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_true() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_true(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_false() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_false(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class Reference : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_REFERENCE;
       friend class NodeclBase;
    public:
    Reference() : NodeclBase() { }
    Reference(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Reference make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Comma : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_COMMA;
       friend class NodeclBase;
    public:
    Comma() : NodeclBase() { }
    Comma(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Comma make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Throw : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_THROW;
       friend class NodeclBase;
    public:
    Throw() : NodeclBase() { }
    Throw(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Throw make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class VirtualFunctionCall : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VIRTUAL_FUNCTION_CALL;
       friend class NodeclBase;
    public:
    VirtualFunctionCall() : NodeclBase() { }
    VirtualFunctionCall(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VirtualFunctionCall make(Nodecl::NodeclBase child_called, Nodecl::NodeclBase child_arguments, Nodecl::NodeclBase child_function_form, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_called() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_called(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_arguments() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_arguments(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_function_form() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_function_form(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class MulAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_MUL_ASSIGNMENT;
       friend class NodeclBase;
    public:
    MulAssignment() : NodeclBase() { }
    MulAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MulAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class DivAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_DIV_ASSIGNMENT;
       friend class NodeclBase;
    public:
    DivAssignment() : NodeclBase() { }
    DivAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DivAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class AddAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ADD_ASSIGNMENT;
       friend class NodeclBase;
    public:
    AddAssignment() : NodeclBase() { }
    AddAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static AddAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class MinusAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_MINUS_ASSIGNMENT;
       friend class NodeclBase;
    public:
    MinusAssignment() : NodeclBase() { }
    MinusAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MinusAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BitwiseShlAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_SHL_ASSIGNMENT;
       friend class NodeclBase;
    public:
    BitwiseShlAssignment() : NodeclBase() { }
    BitwiseShlAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseShlAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BitwiseShrAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_SHR_ASSIGNMENT;
       friend class NodeclBase;
    public:
    BitwiseShrAssignment() : NodeclBase() { }
    BitwiseShrAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseShrAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class ArithmeticShrAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ARITHMETIC_SHR_ASSIGNMENT;
       friend class NodeclBase;
    public:
    ArithmeticShrAssignment() : NodeclBase() { }
    ArithmeticShrAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ArithmeticShrAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BitwiseAndAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_AND_ASSIGNMENT;
       friend class NodeclBase;
    public:
    BitwiseAndAssignment() : NodeclBase() { }
    BitwiseAndAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseAndAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BitwiseOrAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_OR_ASSIGNMENT;
       friend class NodeclBase;
    public:
    BitwiseOrAssignment() : NodeclBase() { }
    BitwiseOrAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseOrAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class BitwiseXorAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BITWISE_XOR_ASSIGNMENT;
       friend class NodeclBase;
    public:
    BitwiseXorAssignment() : NodeclBase() { }
    BitwiseXorAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BitwiseXorAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class ModAssignment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_MOD_ASSIGNMENT;
       friend class NodeclBase;
    public:
    ModAssignment() : NodeclBase() { }
    ModAssignment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ModAssignment make(Nodecl::NodeclBase child_lhs, Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_lhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_lhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Preincrement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PREINCREMENT;
       friend class NodeclBase;
    public:
    Preincrement() : NodeclBase() { }
    Preincrement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Preincrement make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Postincrement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_POSTINCREMENT;
       friend class NodeclBase;
    public:
    Postincrement() : NodeclBase() { }
    Postincrement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Postincrement make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Predecrement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PREDECREMENT;
       friend class NodeclBase;
    public:
    Predecrement() : NodeclBase() { }
    Predecrement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Predecrement make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Postdecrement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_POSTDECREMENT;
       friend class NodeclBase;
    public:
    Postdecrement() : NodeclBase() { }
    Postdecrement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Postdecrement make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Sizeof : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_SIZEOF;
       friend class NodeclBase;
    public:
    Sizeof() : NodeclBase() { }
    Sizeof(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Sizeof make(Nodecl::NodeclBase child_size_type, Nodecl::NodeclBase child_expr, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_size_type() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_size_type(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Alignof : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ALIGNOF;
       friend class NodeclBase;
    public:
    Alignof() : NodeclBase() { }
    Alignof(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Alignof make(Nodecl::NodeclBase child_align_type, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_align_type() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_align_type(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Offset : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OFFSET;
       friend class NodeclBase;
    public:
    Offset() : NodeclBase() { }
    Offset(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Offset make(Nodecl::NodeclBase child_base, Nodecl::NodeclBase child_offset, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_base() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_base(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_offset() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_offset(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Typeid : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_TYPEID;
       friend class NodeclBase;
    public:
    Typeid() : NodeclBase() { }
    Typeid(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Typeid make(Nodecl::NodeclBase child_arg, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_arg() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_arg(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class New : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_NEW;
       friend class NodeclBase;
    public:
    New() : NodeclBase() { }
    New(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static New make(Nodecl::NodeclBase child_init, Nodecl::NodeclBase child_init_real_type, Nodecl::NodeclBase child_placement, Nodecl::NodeclBase child_alloc_func, TL::Type type, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_init_real_type() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_init_real_type(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_placement() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_placement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_alloc_func() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_alloc_func(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class Delete : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_DELETE;
       friend class NodeclBase;
    public:
    Delete() : NodeclBase() { }
    Delete(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Delete make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class DeleteArray : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_DELETE_ARRAY;
       friend class NodeclBase;
    public:
    DeleteArray() : NodeclBase() { }
    DeleteArray(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DeleteArray make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class PointerToMember : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_POINTER_TO_MEMBER;
       friend class NodeclBase;
    public:
    PointerToMember() : NodeclBase() { }
    PointerToMember(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PointerToMember make(TL::Symbol symbol, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

};
class RealPart : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_REAL_PART;
       friend class NodeclBase;
    public:
    RealPart() : NodeclBase() { }
    RealPart(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static RealPart make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class ImagPart : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_IMAG_PART;
       friend class NodeclBase;
    public:
    ImagPart() : NodeclBase() { }
    ImagPart(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ImagPart make(Nodecl::NodeclBase child_rhs, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_rhs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_rhs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Offsetof : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OFFSETOF;
       friend class NodeclBase;
    public:
    Offsetof() : NodeclBase() { }
    Offsetof(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Offsetof make(Nodecl::NodeclBase child_offset_type, Nodecl::NodeclBase child_designator, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_offset_type() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_offset_type(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_designator() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_designator(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Shaping : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_SHAPING;
       friend class NodeclBase;
    public:
    Shaping() : NodeclBase() { }
    Shaping(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Shaping make(Nodecl::NodeclBase child_postfix, Nodecl::NodeclBase child_shape, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_postfix() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_postfix(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_shape() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_shape(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class PseudoDestructorName : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PSEUDO_DESTRUCTOR_NAME;
       friend class NodeclBase;
    public:
    PseudoDestructorName() : NodeclBase() { }
    PseudoDestructorName(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PseudoDestructorName make(Nodecl::NodeclBase child_accessed, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_accessed() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_accessed(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class VectorConditionalExpression : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_CONDITIONAL_EXPRESSION;
       friend class NodeclBase;
    public:
    VectorConditionalExpression() : NodeclBase() { }
    VectorConditionalExpression(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorConditionalExpression make(Nodecl::NodeclBase child_condition, Nodecl::NodeclBase child_true, Nodecl::NodeclBase child_false, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_condition() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_condition(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_true() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_true(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_false() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_false(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class VlaWildcard : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VLA_WILDCARD;
       friend class NodeclBase;
    public:
    VlaWildcard() : NodeclBase() { }
    VlaWildcard(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VlaWildcard make(TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

};
class GxxBuiltinAddressof : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_GXX_BUILTIN_ADDRESSOF;
       friend class NodeclBase;
    public:
    GxxBuiltinAddressof() : NodeclBase() { }
    GxxBuiltinAddressof(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static GxxBuiltinAddressof make(Nodecl::NodeclBase child_expr, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class GccAsmOperand : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_GCC_ASM_OPERAND;
       friend class NodeclBase;
    public:
    GccAsmOperand() : NodeclBase() { }
    GccAsmOperand(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static GccAsmOperand make(Nodecl::NodeclBase child_identifier, Nodecl::NodeclBase child_constraint, Nodecl::NodeclBase child_expr, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_identifier() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_identifier(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_constraint() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_constraint(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class Analysis::Assert : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_ASSERT;
       friend class NodeclBase;
    public:
    Assert() : NodeclBase() { }
    Assert(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Assert make(Nodecl::NodeclBase child_statements, Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class IntegerLiteral : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_INTEGER_LITERAL;
       friend class NodeclBase;
    public:
    IntegerLiteral() : NodeclBase() { }
    IntegerLiteral(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IntegerLiteral make(TL::Type type, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class FloatingLiteral : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FLOATING_LITERAL;
       friend class NodeclBase;
    public:
    FloatingLiteral() : NodeclBase() { }
    FloatingLiteral(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FloatingLiteral make(TL::Type type, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class ComplexLiteral : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_COMPLEX_LITERAL;
       friend class NodeclBase;
    public:
    ComplexLiteral() : NodeclBase() { }
    ComplexLiteral(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ComplexLiteral make(TL::Type type, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class BooleanLiteral : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_BOOLEAN_LITERAL;
       friend class NodeclBase;
    public:
    BooleanLiteral() : NodeclBase() { }
    BooleanLiteral(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BooleanLiteral make(TL::Type type, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::DepIn : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_DEP_IN;
       friend class NodeclBase;
    public:
    DepIn() : NodeclBase() { }
    DepIn(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepIn make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::DepOut : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_DEP_OUT;
       friend class NodeclBase;
    public:
    DepOut() : NodeclBase() { }
    DepOut(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepOut make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::DepInout : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_DEP_INOUT;
       friend class NodeclBase;
    public:
    DepInout() : NodeclBase() { }
    DepInout(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepInout make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::DepConcurrent : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_DEP_CONCURRENT;
       friend class NodeclBase;
    public:
    DepConcurrent() : NodeclBase() { }
    DepConcurrent(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepConcurrent make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::DepCommutative : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_DEP_COMMUTATIVE;
       friend class NodeclBase;
    public:
    DepCommutative() : NodeclBase() { }
    DepCommutative(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepCommutative make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::DepReduction : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_DEP_REDUCTION;
       friend class NodeclBase;
    public:
    DepReduction() : NodeclBase() { }
    DepReduction(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepReduction make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::DepWeakReduction : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_DEP_WEAK_REDUCTION;
       friend class NodeclBase;
    public:
    DepWeakReduction() : NodeclBase() { }
    DepWeakReduction(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepWeakReduction make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::DepInPrivate : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_DEP_IN_PRIVATE;
       friend class NodeclBase;
    public:
    DepInPrivate() : NodeclBase() { }
    DepInPrivate(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepInPrivate make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::DepWeakIn : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_DEP_WEAK_IN;
       friend class NodeclBase;
    public:
    DepWeakIn() : NodeclBase() { }
    DepWeakIn(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepWeakIn make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::DepWeakOut : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_DEP_WEAK_OUT;
       friend class NodeclBase;
    public:
    DepWeakOut() : NodeclBase() { }
    DepWeakOut(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepWeakOut make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::DepWeakInout : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_DEP_WEAK_INOUT;
       friend class NodeclBase;
    public:
    DepWeakInout() : NodeclBase() { }
    DepWeakInout(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepWeakInout make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::DepWeakCommutative : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_DEP_WEAK_COMMUTATIVE;
       friend class NodeclBase;
    public:
    DepWeakCommutative() : NodeclBase() { }
    DepWeakCommutative(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DepWeakCommutative make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Type : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_TYPE;
       friend class NodeclBase;
    public:
    Type() : NodeclBase() { }
    Type(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Type make(TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

};
class PragmaCustomClause : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PRAGMA_CUSTOM_CLAUSE;
       friend class NodeclBase;
    public:
    PragmaCustomClause() : NodeclBase() { }
    PragmaCustomClause(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PragmaCustomClause make(Nodecl::NodeclBase child_arguments, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_arguments() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_arguments(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxDecl : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DECL;
       friend class NodeclBase;
    public:
    CxxDecl() : NodeclBase() { }
    CxxDecl(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDecl make(Nodecl::NodeclBase child_context, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_context() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_context(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxDef : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DEF;
       friend class NodeclBase;
    public:
    CxxDef() : NodeclBase() { }
    CxxDef(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDef make(Nodecl::NodeclBase child_context, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_context() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_context(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxExplicitInstantiationDef : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_EXPLICIT_INSTANTIATION_DEF;
       friend class NodeclBase;
    public:
    CxxExplicitInstantiationDef() : NodeclBase() { }
    CxxExplicitInstantiationDef(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxExplicitInstantiationDef make(Nodecl::NodeclBase child_declarator_name, Nodecl::NodeclBase child_context, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_declarator_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_declarator_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_context() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_context(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CxxExplicitInstantiationDecl : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_EXPLICIT_INSTANTIATION_DECL;
       friend class NodeclBase;
    public:
    CxxExplicitInstantiationDecl() : NodeclBase() { }
    CxxExplicitInstantiationDecl(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxExplicitInstantiationDecl make(Nodecl::NodeclBase child_declarator_name, Nodecl::NodeclBase child_context, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_declarator_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_declarator_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_context() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_context(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CxxUsingNamespace : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_USING_NAMESPACE;
       friend class NodeclBase;
    public:
    CxxUsingNamespace() : NodeclBase() { }
    CxxUsingNamespace(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxUsingNamespace make(Nodecl::NodeclBase child_context, Nodecl::NodeclBase child_used_name, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_context() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_context(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_used_name() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_used_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CxxUsingDecl : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_USING_DECL;
       friend class NodeclBase;
    public:
    CxxUsingDecl() : NodeclBase() { }
    CxxUsingDecl(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxUsingDecl make(Nodecl::NodeclBase child_context, Nodecl::NodeclBase child_used_name, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_context() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_context(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_used_name() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_used_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CxxParseLater : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_PARSE_LATER;
       friend class NodeclBase;
    public:
    CxxParseLater() : NodeclBase() { }
    CxxParseLater(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxParseLater make(const locus_t *location = ::make_locus("", 0, 0));

};
class CxxImplicitInstantiation : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_IMPLICIT_INSTANTIATION;
       friend class NodeclBase;
    public:
    CxxImplicitInstantiation() : NodeclBase() { }
    CxxImplicitInstantiation(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxImplicitInstantiation make(TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

};
class TemplateFunctionCode : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_TEMPLATE_FUNCTION_CODE;
       friend class NodeclBase;
    public:
    TemplateFunctionCode() : NodeclBase() { }
    TemplateFunctionCode(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TemplateFunctionCode make(Nodecl::NodeclBase child_statements, Nodecl::NodeclBase child_initializers, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_initializers() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_initializers(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Verbatim : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VERBATIM;
       friend class NodeclBase;
    public:
    Verbatim() : NodeclBase() { }
    Verbatim(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Verbatim make(const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

};
class FortranImpliedDo : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_IMPLIED_DO;
       friend class NodeclBase;
    public:
    FortranImpliedDo() : NodeclBase() { }
    FortranImpliedDo(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranImpliedDo make(Nodecl::NodeclBase child_name, Nodecl::NodeclBase child_range, Nodecl::NodeclBase child_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_range() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_range(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_items() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class OmpSs::Alloca : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_ALLOCA;
       friend class NodeclBase;
    public:
    Alloca() : NodeclBase() { }
    Alloca(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Alloca make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::SharedAndAlloca : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_SHARED_AND_ALLOCA;
       friend class NodeclBase;
    public:
    SharedAndAlloca() : NodeclBase() { }
    SharedAndAlloca(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static SharedAndAlloca make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::WeakReduction : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_WEAK_REDUCTION;
       friend class NodeclBase;
    public:
    WeakReduction() : NodeclBase() { }
    WeakReduction(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static WeakReduction make(Nodecl::NodeclBase child_reductions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_reductions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_reductions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::Cost : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_COST;
       friend class NodeclBase;
    public:
    Cost() : NodeclBase() { }
    Cost(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Cost make(Nodecl::NodeclBase child_cost, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_cost() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_cost(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::TaskLabel : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_TASK_LABEL;
       friend class NodeclBase;
    public:
    TaskLabel() : NodeclBase() { }
    TaskLabel(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TaskLabel make(const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

};
class TryBlock : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_TRY_BLOCK;
       friend class NodeclBase;
    public:
    TryBlock() : NodeclBase() { }
    TryBlock(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TryBlock make(Nodecl::NodeclBase child_statement, Nodecl::NodeclBase child_catch_handlers, Nodecl::NodeclBase child_any, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_catch_handlers() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_catch_handlers(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_any() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_any(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class CxxForRanged : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_FOR_RANGED;
       friend class NodeclBase;
    public:
    CxxForRanged() : NodeclBase() { }
    CxxForRanged(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxForRanged make(Nodecl::NodeclBase child_range, Nodecl::NodeclBase child_statement, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_range() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_range(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CatchHandler : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CATCH_HANDLER;
       friend class NodeclBase;
    public:
    CatchHandler() : NodeclBase() { }
    CatchHandler(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CatchHandler make(Nodecl::NodeclBase child_name, Nodecl::NodeclBase child_statement, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class CxxStaticAssert : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_STATIC_ASSERT;
       friend class NodeclBase;
    public:
    CxxStaticAssert() : NodeclBase() { }
    CxxStaticAssert(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxStaticAssert make(Nodecl::NodeclBase child_predicate, Nodecl::NodeclBase child_message, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_predicate() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_predicate(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_message() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_message(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::Aligned : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_ALIGNED;
       friend class NodeclBase;
    public:
    Aligned() : NodeclBase() { }
    Aligned(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Aligned make(Nodecl::NodeclBase child_aligned_expressions, Nodecl::NodeclBase child_alignment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_aligned_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_aligned_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_alignment() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_alignment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::VectorLength : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_VECTOR_LENGTH;
       friend class NodeclBase;
    public:
    VectorLength() : NodeclBase() { }
    VectorLength(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLength make(Nodecl::NodeclBase child_vector_length, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_vector_length() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_vector_length(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::VectorLengthFor : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_VECTOR_LENGTH_FOR;
       friend class NodeclBase;
    public:
    VectorLengthFor() : NodeclBase() { }
    VectorLengthFor(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorLengthFor make(TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::Uniform : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_UNIFORM;
       friend class NodeclBase;
    public:
    Uniform() : NodeclBase() { }
    Uniform(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Uniform make(Nodecl::NodeclBase child_uniform_expressions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_uniform_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_uniform_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Linear : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_LINEAR;
       friend class NodeclBase;
    public:
    Linear() : NodeclBase() { }
    Linear(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Linear make(Nodecl::NodeclBase child_linear_expressions, Nodecl::NodeclBase child_step, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_linear_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_linear_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_step() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_step(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::Suitable : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_SUITABLE;
       friend class NodeclBase;
    public:
    Suitable() : NodeclBase() { }
    Suitable(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Suitable make(Nodecl::NodeclBase child_suitable_expressions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_suitable_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_suitable_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Overlap : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_OVERLAP;
       friend class NodeclBase;
    public:
    Overlap() : NodeclBase() { }
    Overlap(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Overlap make(Nodecl::NodeclBase child_overlap_expressions, Nodecl::NodeclBase child_min_group_loads, Nodecl::NodeclBase child_max_group_registers, Nodecl::NodeclBase child_max_groups, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_overlap_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_overlap_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_min_group_loads() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_min_group_loads(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_max_group_registers() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_max_group_registers(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_max_groups() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_max_groups(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class OpenMP::Unroll : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_UNROLL;
       friend class NodeclBase;
    public:
    Unroll() : NodeclBase() { }
    Unroll(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Unroll make(Nodecl::NodeclBase child_unroll_factor, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_unroll_factor() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_unroll_factor(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::UnrollAndJam : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_UNROLL_AND_JAM;
       friend class NodeclBase;
    public:
    UnrollAndJam() : NodeclBase() { }
    UnrollAndJam(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static UnrollAndJam make(Nodecl::NodeclBase child_unroll_factor, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_unroll_factor() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_unroll_factor(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Nontemporal : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_NONTEMPORAL;
       friend class NodeclBase;
    public:
    Nontemporal() : NodeclBase() { }
    Nontemporal(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Nontemporal make(Nodecl::NodeclBase child_nontemporal_expressions, Nodecl::NodeclBase child_flags, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_nontemporal_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_nontemporal_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_flags() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_flags(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::Prefetch : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_PREFETCH;
       friend class NodeclBase;
    public:
    Prefetch() : NodeclBase() { }
    Prefetch(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Prefetch make(Nodecl::NodeclBase child_distances, Nodecl::NodeclBase child_strategy, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_distances() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_distances(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_strategy() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_strategy(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::NoPrefetch : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_NO_PREFETCH;
       friend class NodeclBase;
    public:
    NoPrefetch() : NodeclBase() { }
    NoPrefetch(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static NoPrefetch make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::Mask : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_MASK;
       friend class NodeclBase;
    public:
    Mask() : NodeclBase() { }
    Mask(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Mask make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::NoMask : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_NO_MASK;
       friend class NodeclBase;
    public:
    NoMask() : NodeclBase() { }
    NoMask(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static NoMask make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::SimdReduction : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_SIMD_REDUCTION;
       friend class NodeclBase;
    public:
    SimdReduction() : NodeclBase() { }
    SimdReduction(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static SimdReduction make(Nodecl::NodeclBase child_reductions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_reductions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_reductions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::AssertDecl : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_ASSERT_DECL;
       friend class NodeclBase;
    public:
    AssertDecl() : NodeclBase() { }
    AssertDecl(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static AssertDecl make(Nodecl::NodeclBase child_environment, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxCaptureCopy : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_CAPTURE_COPY;
       friend class NodeclBase;
    public:
    CxxCaptureCopy() : NodeclBase() { }
    CxxCaptureCopy(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxCaptureCopy make(Nodecl::NodeclBase child_init, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxCaptureReference : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_CAPTURE_REFERENCE;
       friend class NodeclBase;
    public:
    CxxCaptureReference() : NodeclBase() { }
    CxxCaptureReference(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxCaptureReference make(Nodecl::NodeclBase child_init, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxFunctionFormTemplateId : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_FUNCTION_FORM_TEMPLATE_ID;
       friend class NodeclBase;
    public:
    CxxFunctionFormTemplateId() : NodeclBase() { }
    CxxFunctionFormTemplateId(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxFunctionFormTemplateId make(const locus_t *location = ::make_locus("", 0, 0));

};
class CxxFunctionFormImplicit : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_FUNCTION_FORM_IMPLICIT;
       friend class NodeclBase;
    public:
    CxxFunctionFormImplicit() : NodeclBase() { }
    CxxFunctionFormImplicit(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxFunctionFormImplicit make(const locus_t *location = ::make_locus("", 0, 0));

};
class CxxFunctionFormBinaryInfix : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_FUNCTION_FORM_BINARY_INFIX;
       friend class NodeclBase;
    public:
    CxxFunctionFormBinaryInfix() : NodeclBase() { }
    CxxFunctionFormBinaryInfix(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxFunctionFormBinaryInfix make(const locus_t *location = ::make_locus("", 0, 0));

};
class CxxFunctionFormUnaryPrefix : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_FUNCTION_FORM_UNARY_PREFIX;
       friend class NodeclBase;
    public:
    CxxFunctionFormUnaryPrefix() : NodeclBase() { }
    CxxFunctionFormUnaryPrefix(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxFunctionFormUnaryPrefix make(const locus_t *location = ::make_locus("", 0, 0));

};
class CxxFunctionFormUnaryPostfix : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_FUNCTION_FORM_UNARY_POSTFIX;
       friend class NodeclBase;
    public:
    CxxFunctionFormUnaryPostfix() : NodeclBase() { }
    CxxFunctionFormUnaryPostfix(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxFunctionFormUnaryPostfix make(const locus_t *location = ::make_locus("", 0, 0));

};
class CxxFunctionFormDefaultInit : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_FUNCTION_FORM_DEFAULT_INIT;
       friend class NodeclBase;
    public:
    CxxFunctionFormDefaultInit() : NodeclBase() { }
    CxxFunctionFormDefaultInit(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxFunctionFormDefaultInit make(const locus_t *location = ::make_locus("", 0, 0));

};
class CxxFunctionFormDefaultInitBraced : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_FUNCTION_FORM_DEFAULT_INIT_BRACED;
       friend class NodeclBase;
    public:
    CxxFunctionFormDefaultInitBraced() : NodeclBase() { }
    CxxFunctionFormDefaultInitBraced(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxFunctionFormDefaultInitBraced make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::For : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_FOR;
       friend class NodeclBase;
    public:
    For() : NodeclBase() { }
    For(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static For make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_loop, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_loop() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_loop(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::ForAppendix : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_FOR_APPENDIX;
       friend class NodeclBase;
    public:
    ForAppendix() : NodeclBase() { }
    ForAppendix(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ForAppendix make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_loop, Nodecl::NodeclBase child_prependix, Nodecl::NodeclBase child_appendix, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_loop() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_loop(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_prependix() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_prependix(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_appendix() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_appendix(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class AsmDefinition : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ASM_DEFINITION;
       friend class NodeclBase;
    public:
    AsmDefinition() : NodeclBase() { }
    AsmDefinition(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static AsmDefinition make(Nodecl::NodeclBase child_asm_text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_asm_text() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_asm_text(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::DeclareTarget : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_DECLARE_TARGET;
       friend class NodeclBase;
    public:
    DeclareTarget() : NodeclBase() { }
    DeclareTarget(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static DeclareTarget make(Nodecl::NodeclBase child_declarations, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_declarations() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_declarations(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Taskloop : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TASKLOOP;
       friend class NodeclBase;
    public:
    Taskloop() : NodeclBase() { }
    Taskloop(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Taskloop make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_loop, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_loop() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_loop(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OmpSs::Release : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_RELEASE;
       friend class NodeclBase;
    public:
    Release() : NodeclBase() { }
    Release(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Release make(Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::TaskIsTaskwait : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TASK_IS_TASKWAIT;
       friend class NodeclBase;
    public:
    TaskIsTaskwait() : NodeclBase() { }
    TaskIsTaskwait(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TaskIsTaskwait make(const locus_t *location = ::make_locus("", 0, 0));

};
class OmpSs::TaskIsLoop : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_TASK_IS_LOOP;
       friend class NodeclBase;
    public:
    TaskIsLoop() : NodeclBase() { }
    TaskIsLoop(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TaskIsLoop make(const locus_t *location = ::make_locus("", 0, 0));

};
class OmpSs::TaskIsTaskCall : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_TASK_IS_TASK_CALL;
       friend class NodeclBase;
    public:
    TaskIsTaskCall() : NodeclBase() { }
    TaskIsTaskCall(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TaskIsTaskCall make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::Task : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TASK;
       friend class NodeclBase;
    public:
    Task() : NodeclBase() { }
    Task(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Task make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class Analysis::ReachDefExpr : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_REACH_DEF_EXPR;
       friend class NodeclBase;
    public:
    ReachDefExpr() : NodeclBase() { }
    ReachDefExpr(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ReachDefExpr make(Nodecl::NodeclBase child_expression, Nodecl::NodeclBase child_value, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expression() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expression(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_value() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_value(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::BarrierAtEnd : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_BARRIER_AT_END;
       friend class NodeclBase;
    public:
    BarrierAtEnd() : NodeclBase() { }
    BarrierAtEnd(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static BarrierAtEnd make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::Device : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_DEVICE;
       friend class NodeclBase;
    public:
    Device() : NodeclBase() { }
    Device(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Device make(Nodecl::NodeclBase child_device_id, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_device_id() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_device_id(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::MapTo : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_MAP_TO;
       friend class NodeclBase;
    public:
    MapTo() : NodeclBase() { }
    MapTo(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MapTo make(Nodecl::NodeclBase child_map_to, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_map_to() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_map_to(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::MapFrom : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_MAP_FROM;
       friend class NodeclBase;
    public:
    MapFrom() : NodeclBase() { }
    MapFrom(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MapFrom make(Nodecl::NodeclBase child_map_from, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_map_from() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_map_from(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::MapToFrom : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_MAP_TO_FROM;
       friend class NodeclBase;
    public:
    MapToFrom() : NodeclBase() { }
    MapToFrom(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MapToFrom make(Nodecl::NodeclBase child_map_tofrom, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_map_tofrom() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_map_tofrom(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::MapAlloc : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_MAP_ALLOC;
       friend class NodeclBase;
    public:
    MapAlloc() : NodeclBase() { }
    MapAlloc(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MapAlloc make(Nodecl::NodeclBase child_map_alloc, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_map_alloc() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_map_alloc(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::MotionTo : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_MOTION_TO;
       friend class NodeclBase;
    public:
    MotionTo() : NodeclBase() { }
    MotionTo(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MotionTo make(Nodecl::NodeclBase child_map_to, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_map_to() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_map_to(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::MotionFrom : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_MOTION_FROM;
       friend class NodeclBase;
    public:
    MotionFrom() : NodeclBase() { }
    MotionFrom(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MotionFrom make(Nodecl::NodeclBase child_map_from, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_map_from() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_map_from(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::NumTeams : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_NUM_TEAMS;
       friend class NodeclBase;
    public:
    NumTeams() : NodeclBase() { }
    NumTeams(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static NumTeams make(Nodecl::NodeclBase child_num_teams, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_num_teams() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_num_teams(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::ThreadLimit : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_THREAD_LIMIT;
       friend class NodeclBase;
    public:
    ThreadLimit() : NodeclBase() { }
    ThreadLimit(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ThreadLimit make(Nodecl::NodeclBase child_thread_limit, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_thread_limit() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_thread_limit(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::TargetTaskUndeferred : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TARGET_TASK_UNDEFERRED;
       friend class NodeclBase;
    public:
    TargetTaskUndeferred() : NodeclBase() { }
    TargetTaskUndeferred(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TargetTaskUndeferred make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::Firstprivate : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_FIRSTPRIVATE;
       friend class NodeclBase;
    public:
    Firstprivate() : NodeclBase() { }
    Firstprivate(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Firstprivate make(Nodecl::NodeclBase child_symbols, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_symbols() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_symbols(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Lastprivate : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_LASTPRIVATE;
       friend class NodeclBase;
    public:
    Lastprivate() : NodeclBase() { }
    Lastprivate(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Lastprivate make(Nodecl::NodeclBase child_symbols, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_symbols() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_symbols(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::FirstLastprivate : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_FIRST_LASTPRIVATE;
       friend class NodeclBase;
    public:
    FirstLastprivate() : NodeclBase() { }
    FirstLastprivate(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FirstLastprivate make(Nodecl::NodeclBase child_symbols, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_symbols() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_symbols(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Shared : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_SHARED;
       friend class NodeclBase;
    public:
    Shared() : NodeclBase() { }
    Shared(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Shared make(Nodecl::NodeclBase child_symbols, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_symbols() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_symbols(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Threadprivate : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_THREADPRIVATE;
       friend class NodeclBase;
    public:
    Threadprivate() : NodeclBase() { }
    Threadprivate(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Threadprivate make(Nodecl::NodeclBase child_symbols, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_symbols() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_symbols(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Private : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_PRIVATE;
       friend class NodeclBase;
    public:
    Private() : NodeclBase() { }
    Private(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Private make(Nodecl::NodeclBase child_symbols, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_symbols() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_symbols(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Auto : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_AUTO;
       friend class NodeclBase;
    public:
    Auto() : NodeclBase() { }
    Auto(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Auto make(Nodecl::NodeclBase child_symbols, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_symbols() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_symbols(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Reduction : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_REDUCTION;
       friend class NodeclBase;
    public:
    Reduction() : NodeclBase() { }
    Reduction(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Reduction make(Nodecl::NodeclBase child_reductions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_reductions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_reductions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::TaskReduction : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TASK_REDUCTION;
       friend class NodeclBase;
    public:
    TaskReduction() : NodeclBase() { }
    TaskReduction(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TaskReduction make(Nodecl::NodeclBase child_reductions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_reductions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_reductions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::InReduction : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_IN_REDUCTION;
       friend class NodeclBase;
    public:
    InReduction() : NodeclBase() { }
    InReduction(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static InReduction make(Nodecl::NodeclBase child_reductions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_reductions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_reductions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::PrivateInit : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_PRIVATE_INIT;
       friend class NodeclBase;
    public:
    PrivateInit() : NodeclBase() { }
    PrivateInit(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PrivateInit make(Nodecl::NodeclBase child_value, TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_value() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_value(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranAllocateStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_ALLOCATE_STATEMENT;
       friend class NodeclBase;
    public:
    FortranAllocateStatement() : NodeclBase() { }
    FortranAllocateStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranAllocateStatement make(Nodecl::NodeclBase child_items, Nodecl::NodeclBase child_options, Nodecl::NodeclBase child_allocate_type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_items() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_options() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_options(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_allocate_type() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_allocate_type(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class FortranArithmeticIfStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_ARITHMETIC_IF_STATEMENT;
       friend class NodeclBase;
    public:
    FortranArithmeticIfStatement() : NodeclBase() { }
    FortranArithmeticIfStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranArithmeticIfStatement make(Nodecl::NodeclBase child_expr, Nodecl::NodeclBase child_lower, Nodecl::NodeclBase child_equal, Nodecl::NodeclBase child_upper, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_lower() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_lower(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_equal() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_equal(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_upper() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_upper(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class FortranAssignedGotoStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_ASSIGNED_GOTO_STATEMENT;
       friend class NodeclBase;
    public:
    FortranAssignedGotoStatement() : NodeclBase() { }
    FortranAssignedGotoStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranAssignedGotoStatement make(Nodecl::NodeclBase child_index, Nodecl::NodeclBase child_label_seq, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_index() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_index(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_label_seq() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_label_seq(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranOpenStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_OPEN_STATEMENT;
       friend class NodeclBase;
    public:
    FortranOpenStatement() : NodeclBase() { }
    FortranOpenStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranOpenStatement make(Nodecl::NodeclBase child_io_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_io_items() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_io_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranCloseStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_CLOSE_STATEMENT;
       friend class NodeclBase;
    public:
    FortranCloseStatement() : NodeclBase() { }
    FortranCloseStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranCloseStatement make(Nodecl::NodeclBase child_io_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_io_items() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_io_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranComputedGotoStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_COMPUTED_GOTO_STATEMENT;
       friend class NodeclBase;
    public:
    FortranComputedGotoStatement() : NodeclBase() { }
    FortranComputedGotoStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranComputedGotoStatement make(Nodecl::NodeclBase child_label_seq, Nodecl::NodeclBase child_index, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_label_seq() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_label_seq(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_index() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_index(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranAlternateReturnStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_ALTERNATE_RETURN_STATEMENT;
       friend class NodeclBase;
    public:
    FortranAlternateReturnStatement() : NodeclBase() { }
    FortranAlternateReturnStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranAlternateReturnStatement make(Nodecl::NodeclBase child_index, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_index() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_index(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranDeallocateStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_DEALLOCATE_STATEMENT;
       friend class NodeclBase;
    public:
    FortranDeallocateStatement() : NodeclBase() { }
    FortranDeallocateStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranDeallocateStatement make(Nodecl::NodeclBase child_items, Nodecl::NodeclBase child_options, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_items() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_options() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_options(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranIoStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_IO_STATEMENT;
       friend class NodeclBase;
    public:
    FortranIoStatement() : NodeclBase() { }
    FortranIoStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranIoStatement make(Nodecl::NodeclBase child_io_spec_list, Nodecl::NodeclBase child_io_items, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_io_spec_list() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_io_spec_list(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_io_items() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_io_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranLabelAssignStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_LABEL_ASSIGN_STATEMENT;
       friend class NodeclBase;
    public:
    FortranLabelAssignStatement() : NodeclBase() { }
    FortranLabelAssignStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranLabelAssignStatement make(Nodecl::NodeclBase child_value, Nodecl::NodeclBase child_label_var, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_value() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_value(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_label_var() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_label_var(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranNullifyStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_NULLIFY_STATEMENT;
       friend class NodeclBase;
    public:
    FortranNullifyStatement() : NodeclBase() { }
    FortranNullifyStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranNullifyStatement make(Nodecl::NodeclBase child_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_items() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranPrintStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_PRINT_STATEMENT;
       friend class NodeclBase;
    public:
    FortranPrintStatement() : NodeclBase() { }
    FortranPrintStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranPrintStatement make(Nodecl::NodeclBase child_format, Nodecl::NodeclBase child_io_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_format() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_format(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_io_items() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_io_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranReadStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_READ_STATEMENT;
       friend class NodeclBase;
    public:
    FortranReadStatement() : NodeclBase() { }
    FortranReadStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranReadStatement make(Nodecl::NodeclBase child_io_spec_list, Nodecl::NodeclBase child_io_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_io_spec_list() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_io_spec_list(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_io_items() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_io_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranWriteStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_WRITE_STATEMENT;
       friend class NodeclBase;
    public:
    FortranWriteStatement() : NodeclBase() { }
    FortranWriteStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranWriteStatement make(Nodecl::NodeclBase child_io_spec_list, Nodecl::NodeclBase child_io_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_io_spec_list() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_io_spec_list(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_io_items() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_io_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class FortranStopStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_STOP_STATEMENT;
       friend class NodeclBase;
    public:
    FortranStopStatement() : NodeclBase() { }
    FortranStopStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranStopStatement make(Nodecl::NodeclBase child_stop_code, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_stop_code() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_stop_code(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranPauseStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_PAUSE_STATEMENT;
       friend class NodeclBase;
    public:
    FortranPauseStatement() : NodeclBase() { }
    FortranPauseStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranPauseStatement make(Nodecl::NodeclBase child_pause_code, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_pause_code() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_pause_code(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranEntryStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_ENTRY_STATEMENT;
       friend class NodeclBase;
    public:
    FortranEntryStatement() : NodeclBase() { }
    FortranEntryStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranEntryStatement make(TL::Symbol symbol, const locus_t *location = ::make_locus("", 0, 0));

};
class FortranWhere : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_WHERE;
       friend class NodeclBase;
    public:
    FortranWhere() : NodeclBase() { }
    FortranWhere(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranWhere make(Nodecl::NodeclBase child_where_set, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_where_set() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_where_set(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class FortranForall : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FORTRAN_FORALL;
       friend class NodeclBase;
    public:
    FortranForall() : NodeclBase() { }
    FortranForall(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FortranForall make(Nodecl::NodeclBase child_loop_control, Nodecl::NodeclBase child_mask, Nodecl::NodeclBase child_statement, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_loop_control() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_loop_control(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_mask() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_mask(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_statement() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_statement(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class OpenMP::TargetData : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TARGET_DATA;
       friend class NodeclBase;
    public:
    TargetData() : NodeclBase() { }
    TargetData(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TargetData make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::Target : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TARGET;
       friend class NodeclBase;
    public:
    Target() : NodeclBase() { }
    Target(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Target make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::TargetUpdate : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TARGET_UPDATE;
       friend class NodeclBase;
    public:
    TargetUpdate() : NodeclBase() { }
    TargetUpdate(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static TargetUpdate make(Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Teams : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_TEAMS;
       friend class NodeclBase;
    public:
    Teams() : NodeclBase() { }
    Teams(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Teams make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_statements, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_statements() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_statements(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::Distribute : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_DISTRIBUTE;
       friend class NodeclBase;
    public:
    Distribute() : NodeclBase() { }
    Distribute(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Distribute make(Nodecl::NodeclBase child_environment, Nodecl::NodeclBase child_loop, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_loop() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_loop(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class MaskLiteral : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_MASK_LITERAL;
       friend class NodeclBase;
    public:
    MaskLiteral() : NodeclBase() { }
    MaskLiteral(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static MaskLiteral make(TL::Type type, const_value_t* cval, const locus_t *location = ::make_locus("", 0, 0));

};
class Checkpoint::Store : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CHECKPOINT_STORE;
       friend class NodeclBase;
    public:
    Store() : NodeclBase() { }
    Store(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Store make(Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Checkpoint::Load : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CHECKPOINT_LOAD;
       friend class NodeclBase;
    public:
    Load() : NodeclBase() { }
    Load(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Load make(Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Checkpoint::Init : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CHECKPOINT_INIT;
       friend class NodeclBase;
    public:
    Init() : NodeclBase() { }
    Init(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Init make(Nodecl::NodeclBase child_environment, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_environment() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_environment(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Checkpoint::Shutdown : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CHECKPOINT_SHUTDOWN;
       friend class NodeclBase;
    public:
    Shutdown() : NodeclBase() { }
    Shutdown(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Shutdown make(const locus_t *location = ::make_locus("", 0, 0));

};
class Checkpoint::Data : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CHECKPOINT_DATA;
       friend class NodeclBase;
    public:
    Data() : NodeclBase() { }
    Data(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Data make(Nodecl::NodeclBase child_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Checkpoint::Level : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CHECKPOINT_LEVEL;
       friend class NodeclBase;
    public:
    Level() : NodeclBase() { }
    Level(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Level make(Nodecl::NodeclBase child_expr, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Checkpoint::Id : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CHECKPOINT_ID;
       friend class NodeclBase;
    public:
    Id() : NodeclBase() { }
    Id(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Id make(Nodecl::NodeclBase child_expr, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Checkpoint::Comm : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CHECKPOINT_COMM;
       friend class NodeclBase;
    public:
    Comm() : NodeclBase() { }
    Comm(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Comm make(Nodecl::NodeclBase child_expr, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Checkpoint::If : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CHECKPOINT_IF;
       friend class NodeclBase;
    public:
    If() : NodeclBase() { }
    If(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static If make(Nodecl::NodeclBase child_expr, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Checkpoint::Kind : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CHECKPOINT_KIND;
       friend class NodeclBase;
    public:
    Kind() : NodeclBase() { }
    Kind(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Kind make(Nodecl::NodeclBase child_expr, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class SourceComment : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_SOURCE_COMMENT;
       friend class NodeclBase;
    public:
    SourceComment() : NodeclBase() { }
    SourceComment(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static SourceComment make(const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

};
class OmpSs::Target : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_TARGET;
       friend class NodeclBase;
    public:
    Target() : NodeclBase() { }
    Target(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Target make(Nodecl::NodeclBase child_devices, Nodecl::NodeclBase child_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_devices() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_devices(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_items() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class RangeLoopControl : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_RANGE_LOOP_CONTROL;
       friend class NodeclBase;
    public:
    RangeLoopControl() : NodeclBase() { }
    RangeLoopControl(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static RangeLoopControl make(Nodecl::NodeclBase child_induction_variable, Nodecl::NodeclBase child_lower, Nodecl::NodeclBase child_upper, Nodecl::NodeclBase child_step, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_induction_variable() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_induction_variable(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_lower() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_lower(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_upper() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_upper(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
    NodeclBase get_step() const { return NodeclBase(nodecl_get_child(_n, 3)); } 
    void set_step(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 3, n.get_internal_nodecl()); } 
};
class IteratorLoopControl : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ITERATOR_LOOP_CONTROL;
       friend class NodeclBase;
    public:
    IteratorLoopControl() : NodeclBase() { }
    IteratorLoopControl(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IteratorLoopControl make(Nodecl::NodeclBase child_range_iterator, Nodecl::NodeclBase child_initializer, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_range_iterator() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_range_iterator(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_initializer() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_initializer(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class OpenMP::CriticalName : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_CRITICAL_NAME;
       friend class NodeclBase;
    public:
    CriticalName() : NodeclBase() { }
    CriticalName(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CriticalName make(const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

};
class CxxDepNameSimple : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DEP_NAME_SIMPLE;
       friend class NodeclBase;
    public:
    CxxDepNameSimple() : NodeclBase() { }
    CxxDepNameSimple(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDepNameSimple make(const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

};
class Analysis::UpperExposed : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_UPPER_EXPOSED;
       friend class NodeclBase;
    public:
    UpperExposed() : NodeclBase() { }
    UpperExposed(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static UpperExposed make(Nodecl::NodeclBase child_upper_exposed_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_upper_exposed_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_upper_exposed_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Defined : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_DEFINED;
       friend class NodeclBase;
    public:
    Defined() : NodeclBase() { }
    Defined(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Defined make(Nodecl::NodeclBase child_defined_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_defined_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_defined_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Undefined : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_UNDEFINED;
       friend class NodeclBase;
    public:
    Undefined() : NodeclBase() { }
    Undefined(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Undefined make(Nodecl::NodeclBase child_undefined_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_undefined_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_undefined_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::LiveIn : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_LIVE_IN;
       friend class NodeclBase;
    public:
    LiveIn() : NodeclBase() { }
    LiveIn(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static LiveIn make(Nodecl::NodeclBase child_live_in_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_live_in_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_live_in_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::LiveOut : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_LIVE_OUT;
       friend class NodeclBase;
    public:
    LiveOut() : NodeclBase() { }
    LiveOut(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static LiveOut make(Nodecl::NodeclBase child_live_out_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_live_out_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_live_out_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Dead : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_DEAD;
       friend class NodeclBase;
    public:
    Dead() : NodeclBase() { }
    Dead(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Dead make(Nodecl::NodeclBase child_dead_exprs, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_dead_exprs() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_dead_exprs(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::ReachingDefinitionIn : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_REACHING_DEFINITION_IN;
       friend class NodeclBase;
    public:
    ReachingDefinitionIn() : NodeclBase() { }
    ReachingDefinitionIn(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ReachingDefinitionIn make(Nodecl::NodeclBase child_reaching_definitions_in, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_reaching_definitions_in() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_reaching_definitions_in(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::ReachingDefinitionOut : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_REACHING_DEFINITION_OUT;
       friend class NodeclBase;
    public:
    ReachingDefinitionOut() : NodeclBase() { }
    ReachingDefinitionOut(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ReachingDefinitionOut make(Nodecl::NodeclBase child_reaching_definitions_out, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_reaching_definitions_out() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_reaching_definitions_out(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::InductionVariable : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_INDUCTION_VARIABLE;
       friend class NodeclBase;
    public:
    InductionVariable() : NodeclBase() { }
    InductionVariable(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static InductionVariable make(Nodecl::NodeclBase child_induction_variables, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_induction_variables() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_induction_variables(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::AutoScope::Firstprivate : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_AUTO_SCOPE_FIRSTPRIVATE;
       friend class NodeclBase;
    public:
    Firstprivate() : NodeclBase() { }
    Firstprivate(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Firstprivate make(Nodecl::NodeclBase child_scoped_variables, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_scoped_variables() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_scoped_variables(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::AutoScope::Private : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_AUTO_SCOPE_PRIVATE;
       friend class NodeclBase;
    public:
    Private() : NodeclBase() { }
    Private(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Private make(Nodecl::NodeclBase child_scoped_variables, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_scoped_variables() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_scoped_variables(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::AutoScope::Shared : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_AUTO_SCOPE_SHARED;
       friend class NodeclBase;
    public:
    Shared() : NodeclBase() { }
    Shared(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Shared make(Nodecl::NodeclBase child_scoped_variables, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_scoped_variables() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_scoped_variables(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Range : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_RANGE;
       friend class NodeclBase;
    public:
    Range() : NodeclBase() { }
    Range(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Range make(Nodecl::NodeclBase child_range_variables, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_range_variables() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_range_variables(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Correctness::AutoStorage : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_CORRECTNESS_AUTO_STORAGE;
       friend class NodeclBase;
    public:
    AutoStorage() : NodeclBase() { }
    AutoStorage(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static AutoStorage make(Nodecl::NodeclBase child_correctness_vars, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_correctness_vars() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_correctness_vars(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Correctness::Dead : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_CORRECTNESS_DEAD;
       friend class NodeclBase;
    public:
    Dead() : NodeclBase() { }
    Dead(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Dead make(Nodecl::NodeclBase child_correctness_vars, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_correctness_vars() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_correctness_vars(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Correctness::IncoherentFp : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_FP;
       friend class NodeclBase;
    public:
    IncoherentFp() : NodeclBase() { }
    IncoherentFp(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IncoherentFp make(Nodecl::NodeclBase child_correctness_vars, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_correctness_vars() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_correctness_vars(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Correctness::IncoherentP : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_P;
       friend class NodeclBase;
    public:
    IncoherentP() : NodeclBase() { }
    IncoherentP(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IncoherentP make(Nodecl::NodeclBase child_correctness_vars, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_correctness_vars() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_correctness_vars(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Correctness::IncoherentIn : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_IN;
       friend class NodeclBase;
    public:
    IncoherentIn() : NodeclBase() { }
    IncoherentIn(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IncoherentIn make(Nodecl::NodeclBase child_correctness_vars, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_correctness_vars() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_correctness_vars(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Correctness::IncoherentOut : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_OUT;
       friend class NodeclBase;
    public:
    IncoherentOut() : NodeclBase() { }
    IncoherentOut(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IncoherentOut make(Nodecl::NodeclBase child_correctness_vars, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_correctness_vars() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_correctness_vars(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Correctness::IncoherentInPointed : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_IN_POINTED;
       friend class NodeclBase;
    public:
    IncoherentInPointed() : NodeclBase() { }
    IncoherentInPointed(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IncoherentInPointed make(Nodecl::NodeclBase child_correctness_vars, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_correctness_vars() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_correctness_vars(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Correctness::IncoherentOutPointed : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_OUT_POINTED;
       friend class NodeclBase;
    public:
    IncoherentOutPointed() : NodeclBase() { }
    IncoherentOutPointed(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IncoherentOutPointed make(Nodecl::NodeclBase child_correctness_vars, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_correctness_vars() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_correctness_vars(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class Analysis::Correctness::Race : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_ANALYSIS_CORRECTNESS_RACE;
       friend class NodeclBase;
    public:
    Race() : NodeclBase() { }
    Race(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Race make(Nodecl::NodeclBase child_correctness_vars, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_correctness_vars() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_correctness_vars(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class VectorFunctionCode : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_VECTOR_FUNCTION_CODE;
       friend class NodeclBase;
    public:
    VectorFunctionCode() : NodeclBase() { }
    VectorFunctionCode(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static VectorFunctionCode make(Nodecl::NodeclBase child_function_code, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_function_code() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_function_code(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class UpcSyncStatement : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_UPC_SYNC_STATEMENT;
       friend class NodeclBase;
    public:
    UpcSyncStatement() : NodeclBase() { }
    UpcSyncStatement(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static UpcSyncStatement make(Nodecl::NodeclBase child_expr, const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxDepGlobalNameNested : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DEP_GLOBAL_NAME_NESTED;
       friend class NodeclBase;
    public:
    CxxDepGlobalNameNested() : NodeclBase() { }
    CxxDepGlobalNameNested(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDepGlobalNameNested make(Nodecl::NodeclBase child_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_items() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxDepNameNested : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_DEP_NAME_NESTED;
       friend class NodeclBase;
    public:
    CxxDepNameNested() : NodeclBase() { }
    CxxDepNameNested(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxDepNameNested make(Nodecl::NodeclBase child_items, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_items() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_items(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class UnknownPragma : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_UNKNOWN_PRAGMA;
       friend class NodeclBase;
    public:
    UnknownPragma() : NodeclBase() { }
    UnknownPragma(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static UnknownPragma make(const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

};
class FieldDesignator : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_FIELD_DESIGNATOR;
       friend class NodeclBase;
    public:
    FieldDesignator() : NodeclBase() { }
    FieldDesignator(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static FieldDesignator make(Nodecl::NodeclBase child_field, Nodecl::NodeclBase child_next, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_field() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_field(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_next() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_next(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class IndexDesignator : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_INDEX_DESIGNATOR;
       friend class NodeclBase;
    public:
    IndexDesignator() : NodeclBase() { }
    IndexDesignator(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static IndexDesignator make(Nodecl::NodeclBase child_index, Nodecl::NodeclBase child_next, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_index() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_index(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_next() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_next(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class PreprocessorLine : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_PREPROCESSOR_LINE;
       friend class NodeclBase;
    public:
    PreprocessorLine() : NodeclBase() { }
    PreprocessorLine(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static PreprocessorLine make(const std::string& text, const locus_t *location = ::make_locus("", 0, 0));

};
class CxxInitializer : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_INITIALIZER;
       friend class NodeclBase;
    public:
    CxxInitializer() : NodeclBase() { }
    CxxInitializer(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxInitializer make(Nodecl::NodeclBase child_init, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxBracedInitializer : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_BRACED_INITIALIZER;
       friend class NodeclBase;
    public:
    CxxBracedInitializer() : NodeclBase() { }
    CxxBracedInitializer(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxBracedInitializer make(Nodecl::NodeclBase child_init, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxEqualInitializer : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_EQUAL_INITIALIZER;
       friend class NodeclBase;
    public:
    CxxEqualInitializer() : NodeclBase() { }
    CxxEqualInitializer(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxEqualInitializer make(Nodecl::NodeclBase child_init, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxParenthesizedInitializer : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_PARENTHESIZED_INITIALIZER;
       friend class NodeclBase;
    public:
    CxxParenthesizedInitializer() : NodeclBase() { }
    CxxParenthesizedInitializer(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxParenthesizedInitializer make(Nodecl::NodeclBase child_init, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_init() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_init(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class C99DesignatedInitializer : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_C99_DESIGNATED_INITIALIZER;
       friend class NodeclBase;
    public:
    C99DesignatedInitializer() : NodeclBase() { }
    C99DesignatedInitializer(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static C99DesignatedInitializer make(Nodecl::NodeclBase child_designation, Nodecl::NodeclBase child_init, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_designation() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_designation(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_init() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_init(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};
class C99FieldDesignator : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_C99_FIELD_DESIGNATOR;
       friend class NodeclBase;
    public:
    C99FieldDesignator() : NodeclBase() { }
    C99FieldDesignator(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static C99FieldDesignator make(Nodecl::NodeclBase child_name, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class C99IndexDesignator : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_C99_INDEX_DESIGNATOR;
       friend class NodeclBase;
    public:
    C99IndexDesignator() : NodeclBase() { }
    C99IndexDesignator(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static C99IndexDesignator make(Nodecl::NodeclBase child_expr, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_expr() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_expr(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxValuePack : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_VALUE_PACK;
       friend class NodeclBase;
    public:
    CxxValuePack() : NodeclBase() { }
    CxxValuePack(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxValuePack make(Nodecl::NodeclBase child_pack, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_pack() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_pack(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class CxxValuePackExpanded : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_CXX_VALUE_PACK_EXPANDED;
       friend class NodeclBase;
    public:
    CxxValuePackExpanded() : NodeclBase() { }
    CxxValuePackExpanded(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CxxValuePackExpanded make(Nodecl::NodeclBase child_values, TL::Type type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_values() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_values(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::If : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_IF;
       friend class NodeclBase;
    public:
    If() : NodeclBase() { }
    If(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static If make(Nodecl::NodeclBase child_condition, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_condition() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_condition(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Final : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_FINAL;
       friend class NodeclBase;
    public:
    Final() : NodeclBase() { }
    Final(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Final make(Nodecl::NodeclBase child_condition, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_condition() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_condition(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Priority : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_PRIORITY;
       friend class NodeclBase;
    public:
    Priority() : NodeclBase() { }
    Priority(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Priority make(Nodecl::NodeclBase child_priority, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_priority() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_priority(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OpenMP::Mergeable : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_MERGEABLE;
       friend class NodeclBase;
    public:
    Mergeable() : NodeclBase() { }
    Mergeable(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Mergeable make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::Untied : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_UNTIED;
       friend class NodeclBase;
    public:
    Untied() : NodeclBase() { }
    Untied(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Untied make(const locus_t *location = ::make_locus("", 0, 0));

};
class OmpSs::Wait : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_WAIT;
       friend class NodeclBase;
    public:
    Wait() : NodeclBase() { }
    Wait(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Wait make(const locus_t *location = ::make_locus("", 0, 0));

};
class OpenMP::ReductionItem : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OPEN_M_P_REDUCTION_ITEM;
       friend class NodeclBase;
    public:
    ReductionItem() : NodeclBase() { }
    ReductionItem(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ReductionItem make(Nodecl::NodeclBase child_reductor, Nodecl::NodeclBase child_reduced_symbol, Nodecl::NodeclBase child_reduction_type, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_reductor() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_reductor(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_reduced_symbol() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_reduced_symbol(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
    NodeclBase get_reduction_type() const { return NodeclBase(nodecl_get_child(_n, 2)); } 
    void set_reduction_type(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 2, n.get_internal_nodecl()); } 
};
class OmpSs::CopyIn : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_COPY_IN;
       friend class NodeclBase;
    public:
    CopyIn() : NodeclBase() { }
    CopyIn(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CopyIn make(Nodecl::NodeclBase child_input_copies, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_input_copies() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_input_copies(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::CopyOut : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_COPY_OUT;
       friend class NodeclBase;
    public:
    CopyOut() : NodeclBase() { }
    CopyOut(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CopyOut make(Nodecl::NodeclBase child_output_copies, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_output_copies() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_output_copies(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::CopyInout : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_COPY_INOUT;
       friend class NodeclBase;
    public:
    CopyInout() : NodeclBase() { }
    CopyInout(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static CopyInout make(Nodecl::NodeclBase child_inout_copies, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_inout_copies() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_inout_copies(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::NDRange : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_N_D_RANGE;
       friend class NodeclBase;
    public:
    NDRange() : NodeclBase() { }
    NDRange(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static NDRange make(Nodecl::NodeclBase child_ndrange_expressions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_ndrange_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_ndrange_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::ShMem : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_SH_MEM;
       friend class NodeclBase;
    public:
    ShMem() : NodeclBase() { }
    ShMem(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static ShMem make(Nodecl::NodeclBase child_shmem_expressions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_shmem_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_shmem_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::File : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_FILE;
       friend class NodeclBase;
    public:
    File() : NodeclBase() { }
    File(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static File make(Nodecl::NodeclBase child_filename, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_filename() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_filename(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::Name : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_NAME;
       friend class NodeclBase;
    public:
    Name() : NodeclBase() { }
    Name(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Name make(Nodecl::NodeclBase child_name, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_name() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::Onto : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_ONTO;
       friend class NodeclBase;
    public:
    Onto() : NodeclBase() { }
    Onto(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Onto make(Nodecl::NodeclBase child_onto_expressions, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_onto_expressions() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_onto_expressions(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
};
class OmpSs::Implements : public NodeclBase
{
    private:
       static const int _kind = ::NODECL_OMP_SS_IMPLEMENTS;
       friend class NodeclBase;
    public:
    Implements() : NodeclBase() { }
    Implements(const nodecl_t& a) : NodeclBase(a) { }

    // Factory method
    static Implements make(Nodecl::NodeclBase child_device, Nodecl::NodeclBase child_function_name, const locus_t *location = ::make_locus("", 0, 0));

    // Children getters and setters 
    NodeclBase get_device() const { return NodeclBase(nodecl_get_child(_n, 0)); } 
    void set_device(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 0, n.get_internal_nodecl()); } 
    NodeclBase get_function_name() const { return NodeclBase(nodecl_get_child(_n, 1)); } 
    void set_function_name(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, 1, n.get_internal_nodecl()); } 
};

} /* namespace Nodecl */
#endif
