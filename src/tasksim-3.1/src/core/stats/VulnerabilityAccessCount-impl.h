/*
 * Copyright - Barcelona Supercomputing Center.
 * All rights reserved.
 *
 * Redistribution in source and binary forms, with or without
 * modification, is not permitted.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#ifndef STATS_VULNERABILITYACCESSRATIO_IMPL_H
#define STATS_VULNERABILITYACCESSRATIO_IMPL_H

#include <cmath>
#include <iomanip>
#include <unistd.h>
#include <stdlib.h>
#include <algorithm>

namespace sim {
namespace stats {

template<typename T>
inline
VulnerabilityAccessCount::VulnerabilityAccessCount(const T &obj, const std::string &name, unsigned num_bits_ignored,
                                                   engine::cycles_t stat_period, engine::addr_t stat_granularity,
                                                   const std::string &range_map) :
        VulnerabilityStat(obj, name, num_bits_ignored, stat_period, stat_granularity, range_map),
        data_(),
        memory_map_(),
        cur_period_(0),
        start_period_(0),
        end_period_(stat_period)
{
}

inline
VulnerabilityAccessCount::~VulnerabilityAccessCount()
{
    char f[] = "vulnerability.XXXXXX";
    int fd = mkstemp(f);
    if (fd < 0) {
        std::cerr << "[TASKSIM ERROR] Unable to create output file for vulnerability statistics " << f << std::endl;
        exit(-1);
    }

    std::ofstream data_out(f);
    close(fd);

    Stat::out_ << this->name_ << ":" << this->class_ << ":" << this->id_ << std::endl;
    Stat::out_ << "time:" << sizeof(engine::cycles_t) << ":address:" << sizeof(engine::addr_t)
               << ":loads:" << sizeof(uint64_t) << ":stores:" << sizeof(uint64_t) << std::endl;
    Stat::out_ << "addr_grain:" << (~this->address_mask_)+1 << ":map_size:" << map_size_
               << ":stat_period:" << this->stat_period_ << ":end_stats:" << this->end_time_ << std::endl;
    Stat::out_ << "filename:" << f << std::endl;

    std::map<unsigned, size_t> range_sizes;
    std::map<unsigned, std::vector<engine::addr_t>> range_addrs;
    for (auto &period_data: data_) {
        for (auto &address_avg_pair: period_data) {
            int range_index = this->range_map_.get_range_index(address_avg_pair.first);
            if (range_index < 0) {
                range_index = this->range_map_.get_range_index(address_avg_pair.first + ~this->stat_mask_);
                assert(static_cast<size_t>(range_index) < this->range_map_.size());
            }
            range_sizes[range_index] += address_avg_pair.second.loads + address_avg_pair.second.stores;
            range_addrs[range_index].push_back(address_avg_pair.first);
        }
    }

    size_t n_periods = data_.size();
    for (auto &range_size_pair: range_sizes) {
        if (!range_size_pair.second) {
            continue;
        }
        data_out << this->range_map_.name_at(range_size_pair.first);
        for (size_t n = 1; n < n_periods; n++) {
            data_out << " " << n * this->stat_period_;
        }
        data_out << " " << this->end_time_ << '\n';

        for (auto address: range_addrs[range_size_pair.first]) {
            data_out << std::hex << address << std::dec;
            for (size_t n = 0; n < n_periods; n++) {
                auto value = data_[n].find(address);
                if (value == data_[n].end()) {
                    data_out << " 0,0";
                }
                else {
                    data_out << ' ' << value->second.loads << ',' << value->second.stores;
                    data_[n].erase(value);
                }
            }
            data_out << '\n';
        }
        data_out << '\n';
    }
}

inline
void VulnerabilityAccessCount::aggregate(engine::addr_t address, engine::cycles_t period,
                                                       uint64_t reads, uint64_t writes)
{
    if (period >= data_.size()) {
        data_.resize(period + 1);
    }
    accesses_t &acc = data_[period][address & this->stat_mask_];
    acc.loads += reads;
    acc.stores += writes;
}

inline
void VulnerabilityAccessCount::periodic_output(engine::addr_t address, access_counter_t &A, engine::cycles_t time)
{
    if (this->stat_period_ == 0) return;

    if (time > end_period_) {
        cur_period_ = time / this->stat_period_;
        start_period_ = cur_period_ - time % this->stat_period_;
        end_period_ = start_period_ + this->stat_period_;
    }

    if (A.last < start_period_ && A.read + A.write) {
        aggregate(address, A.last / this->stat_period_, A.read, A.write);
    }
}

inline
void VulnerabilityAccessCount::mem_access(engine::cycles_t time, sim::logic::coherence::single::Request &req)
{
    // NB : A will be zero initialized if 'address & this->address_mask_' is not in map
    engine::addr_t address = req.get_tag() & this->address_mask_;
    int range_index = this->range_map_.get_range_index(address);

    if (range_index < 0) {
        return;
    }

    access_counter_t &A = memory_map_[address];
    const bool safe = req.get_op() == sim::logic::coherence::single::req_op_t::WRITE;

    periodic_output(address, A, time);

    if (safe) {
        A.write++;
    } else {
        A.read++;
    }

    A.last = time;
}

inline
void VulnerabilityAccessCount::finalize(engine::cycles_t time)
{
    this->end_time_ = time;
    map_size_ = memory_map_.size();

    const engine::cycles_t div = this->stat_period_ ? this->stat_period_ : (time + 1);
    for (auto &address_stats_pair: memory_map_) {
        assert (this->range_map_.get_range_index(address_stats_pair.first) >= 0);
        aggregate(address_stats_pair.first,
                  address_stats_pair.second.last / div,
                  address_stats_pair.second.read,
                  address_stats_pair.second.write);
    }
}

}
}

#endif // STATS_VULNERABILITYACCESSRATIO_IMPL_H
