/*
 * Copyright - Barcelona Supercomputing Center.
 * All rights reserved.
 *
 * Redistribution in source and binary forms, with or without
 * modification, is not permitted.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#ifndef STATS_VULNERABILITYHISTOGRAM_IMPL_H
#define STATS_VULNERABILITYHISTOGRAM_IMPL_H

#include <iomanip>
#include <unistd.h>
#include <stdlib.h>
#include <algorithm>

namespace sim {
namespace stats {

template<typename T>
inline
VulnerabilityHistogram::VulnerabilityHistogram(const T &obj, const std::string &name, unsigned num_bits_ignored,
                                               engine::cycles_t stat_period, engine::addr_t stat_granularity,
                                               const std::string& range_map, unsigned bins) :
        VulnerabilityStat(obj, name, num_bits_ignored, stat_period, stat_granularity, range_map),
        memory_map_(),
        data_(),
        data_initializer_(),
        bins_(bins)
{
    // prepare all the {range,0} and {range,1} which are very common
    for (size_t i = 0; i < this->range_map_.size(); i++) {
        data_initializer_[std::pair<unsigned,unsigned>(i, 0        )] = 0;
        data_initializer_[std::pair<unsigned,unsigned>(i, bins_ - 1)] = 0;
    }
    worth_writing_.resize(this->range_map_.size(), false);
}

inline
VulnerabilityHistogram::~VulnerabilityHistogram()
{
    char f[] = "vulnerability.XXXXXX";
    int fd = mkstemp(f);
    if (fd < 0) {
        std::cerr << "[TASKSIM ERROR] Unable to create output file for vulnerability statistics " << f << std::endl;
        exit(-1);
    }

    std::ofstream data_out(f);
    close(fd);

    Stat::out_ << this->name_ << ":" << this->class_ << ":" << this->id_ << std::endl;
    Stat::out_ << "time:" << sizeof(engine::cycles_t) << ":address:" << sizeof(engine::addr_t)
               << ":safe_ratio:" << sizeof(float) << std::endl;
    Stat::out_ << "addr_grain:" << (~this->address_mask_)+1 << ":map_size:" << map_size_
               << ":stat_period:" << this->stat_period_ << ":end_stats:" << this->end_time_ << std::endl;
    Stat::out_ << "filename:" << f << std::endl;

    unsigned long long data_size = 0;
    for (size_t i = 0; i < this->range_map_.size(); i++) {
        if (worth_writing_[i]) {
            data_out << this->range_map_.name_at(i) << " ";
            data_size += data_[i].size();
        }
    }
    data_out << std::endl;

    size_t n_times = data_.size();
    std::pair<unsigned,unsigned> key;

    for (size_t name_index = 0; name_index < this->range_map_.size(); name_index++) {
        if (not worth_writing_[name_index]) {
            continue;
        }

        data_out << std::endl << n_times;
        for (size_t t = 1; t < n_times; t++) {
            data_out << " " << t * this->stat_period_;
        }
        data_out << " " << this->end_time_ << std::endl;
        key.first = name_index;

        for (size_t d = 0; d < bins_; d++) {
            data_out << d;
            key.second = d;
            for (engine::cycles_t p = 0; p < n_times; p++) {
                auto value = data_[p].find(key);
                if (value == data_[p].end()) {
                    data_out << " 0";
                }
                else {
                    data_out << " " << value->second;
                    data_[p].erase(value);
                }
            }
            data_out << std::endl;
        }
    }
}

inline
void VulnerabilityHistogram::aggregate(size_t range_index, engine::cycles_t period,
                                                     engine::cycles_t safe_duration, engine::cycles_t total_duration)
{
    while (period > data_.size()) {
        data_.push_back(std::map< std::pair<unsigned,unsigned>, unsigned>(data_initializer_));
    }
    unsigned category = std::min(bins_ - 1, static_cast<unsigned>(safe_duration * bins_ / total_duration));
    data_[period - 1][std::pair<unsigned,unsigned>(range_index,category)] += 1;
    worth_writing_[range_index] = true;
}

inline
void VulnerabilityHistogram::periodic_output(int data_type, address_stats_t &A, engine::cycles_t time,
    bool safe)
{
    if (this->stat_period_ == 0) return;
    engine::cycles_t last_period, last_time;

    last_period = (A.last + this->stat_period_ - 1) / this->stat_period_;
    last_time   = (A.last + this->stat_period_ - 1) - (A.last + this->stat_period_ - 1) % this->stat_period_;

    if (time < last_time) return;

    for (engine::cycles_t p = last_period, t = last_time; t < time; p++, t += this->stat_period_) {
        if (t == 0) {
            continue;
        }

        if (safe) {
            A.safe += t - A.last;
        }

        aggregate(data_type, p, A.safe, this->stat_period_);

        A.last = t;
        A.safe = 0;
    }
}

inline
void VulnerabilityHistogram::mem_access(engine::cycles_t time, sim::logic::coherence::single::Request &req)
{
    // NB : A will be zero initialized if 'address & this->address_mask_' is not in map
    engine::addr_t address = req.get_tag() & this->address_mask_;
    int range_index = this->range_map_.get_range_index(address);

    if (range_index < 0) {
        return;
    }

    address_stats_t &A = memory_map_[address];
    const bool safe = req.get_op() == sim::logic::coherence::single::req_op_t::WRITE;

    periodic_output(range_index, A, time, safe);

    if (safe) {
        A.safe += time - A.last;
    }

    A.last = time;
}

inline
void VulnerabilityHistogram::finalize(engine::cycles_t time)
{
    this->end_time_ = time;
    map_size_ = memory_map_.size();

    if (this->stat_period_ == 0) {
        for (auto it=memory_map_.begin(); it!=memory_map_.end(); it=memory_map_.erase(it)) {
            int range_index = this->range_map_.get_range_index(it->first);
            assert (range_index >= 0);

            it->second.safe += (time - it->second.last);
            aggregate(range_index, 1, it->second.safe, time);
        }
        return;
    }
    else {
        engine::cycles_t end_period, end_duration, last_period, last_time;

        end_period   = (time + this->stat_period_ - 1) / this->stat_period_,
        end_duration = (time + this->stat_period_ - 1) % this->stat_period_ + 1;

        for (auto it=memory_map_.begin(); it!=memory_map_.end(); it=memory_map_.erase(it)) {
            int range_index = this->range_map_.get_range_index(it->first);
            assert (range_index >= 0);

            last_period = (it->second.last + this->stat_period_ - 1) / this->stat_period_;
            last_time   = (it->second.last + this->stat_period_ - 1) - (it->second.last + this->stat_period_ - 1) % this->stat_period_;

            assert(last_period * this->stat_period_ == last_time);

            if (last_period == end_period) {
                it->second.safe += (time - it->second.last);
                aggregate(range_index, last_period, it->second.safe, end_duration);
            }
            else {
                it->second.safe += (last_time - it->second.last);
                aggregate(range_index, last_period, it->second.safe, this->stat_period_);
                for (size_t p=last_period + 1; p < end_period; p++) {
                    aggregate(range_index, p, this->stat_period_, this->stat_period_);
                }
                aggregate(range_index, end_period, end_duration, end_duration);
            }
        }
    }
}

}
}

#endif // STATS_VULNERABILITYHISTOGRAM_IMPL_H
