/* Autogenerated file. DO NOT MODIFY. */
/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */

#include "cxx-nodecl.h"
#include "cxx-utils.h"
#include "cxx-exprtype.h"
#include "mem.h"

static inline void nodecl_check_nullable_rule(nodecl_t n, void (*fun)(nodecl_t))
{
   if (nodecl_is_null(n)) return;
   fun(n);
}
static inline void nodecl_check_list_rule(nodecl_t n, void (*fun)(nodecl_t))
{
   ERROR_CONDITION(!nodecl_is_list(n), "Node must be a list", 0);
   int num_items = 0;
   nodecl_t* list = nodecl_unpack_list(n, &num_items);
   int i;
   for (i = 0; i < num_items; i++)
   {
      fun(list[i]);
   }
   DELETE(list);
}
static inline void nodecl_check_nullable_list_rule(nodecl_t n, void (*fun)(nodecl_t))
{
   if (nodecl_is_null(n)) return;
   nodecl_check_list_rule(n, fun);
}
static void nodecl_check_STRUCTURED_VALUE_PARENTHESIZED(nodecl_t);
static void nodecl_check_STRUCTURED_VALUE_BRACED_TYPECAST(nodecl_t);
static void nodecl_check_STRUCTURED_VALUE_BRACED_IMPLICIT(nodecl_t);
static void nodecl_check_STRUCTURED_VALUE_COMPOUND_LITERAL(nodecl_t);
static void nodecl_check_STRUCTURED_VALUE_FORTRAN_TYPESPEC_ARRAY_CONSTRUCTOR(nodecl_t);
static void nodecl_check_CXX_DEP_TEMPLATE_ID(nodecl_t);
static void nodecl_check_CXX_DEP_NAME_CONVERSION(nodecl_t);
static void nodecl_check_CXX_DEP_DECLTYPE(nodecl_t);
static void nodecl_check_TEXT(nodecl_t);
static void nodecl_check_CUDA_KERNEL_CALL(nodecl_t);
static void nodecl_check_PRAGMA_CUSTOM_DIRECTIVE(nodecl_t);
static void nodecl_check_PRAGMA_CONTEXT(nodecl_t);
static void nodecl_check_RANGE(nodecl_t);
static void nodecl_check_OPEN_M_P_SECTIONS(nodecl_t);
static void nodecl_check_OPEN_M_P_MASTER(nodecl_t);
static void nodecl_check_PRAGMA_CUSTOM_LINE(nodecl_t);
static void nodecl_check_GCC_BUILTIN_VA_ARG(nodecl_t);
static void nodecl_check_OPEN_M_P_CRITICAL(nodecl_t);
static void nodecl_check_PRAGMA_CUSTOM_STATEMENT(nodecl_t);
static void nodecl_check_OMP_SS_LOOP(nodecl_t);
static void nodecl_check_TOP_LEVEL(nodecl_t);
static void nodecl_check_INTEL_ASSUME_ALIGNED(nodecl_t);
static void nodecl_check_INTEL_ASSUME(nodecl_t);
static void nodecl_check_OMP_SS_REGISTER(nodecl_t);
static void nodecl_check_OMP_SS_UNREGISTER(nodecl_t);
static void nodecl_check_OPEN_M_P_SIMD_FOR(nodecl_t);
static void nodecl_check_ANALYSIS_PHI(nodecl_t);
static void nodecl_check_ANALYSIS_RANGE_UNION(nodecl_t);
static void nodecl_check_ANALYSIS_RANGE_INTERSECTION(nodecl_t);
static void nodecl_check_ANALYSIS_RANGE_SUB(nodecl_t);
static void nodecl_check_ANALYSIS_EMPTY_RANGE(nodecl_t);
static void nodecl_check_ANALYSIS_MINUS_INFINITY(nodecl_t);
static void nodecl_check_ANALYSIS_PLUS_INFINITY(nodecl_t);
static void nodecl_check_ANALYSIS_MINIMUM(nodecl_t);
static void nodecl_check_ANALYSIS_MAXIMUM(nodecl_t);
static void nodecl_check_STRING_LITERAL(nodecl_t);
static void nodecl_check_OPEN_M_P_SCHEDULE(nodecl_t);
static void nodecl_check_OPEN_M_P_DIST_SCHEDULE(nodecl_t);
static void nodecl_check_OMP_SS_TARGET_DECLARATION(nodecl_t);
static void nodecl_check_GCC_ASM_DEFINITION(nodecl_t);
static void nodecl_check_OPEN_M_P_TASKWAIT(nodecl_t);
static void nodecl_check_OPEN_M_P_TASKGROUP(nodecl_t);
static void nodecl_check_OPEN_M_P_FLUSH_MEMORY(nodecl_t);
static void nodecl_check_OPEN_M_P_BARRIER_FULL(nodecl_t);
static void nodecl_check_OPEN_M_P_BARRIER_SIGNAL(nodecl_t);
static void nodecl_check_OPEN_M_P_BARRIER_WAIT(nodecl_t);
static void nodecl_check_OPEN_M_P_PARALLEL_SIMD_FOR(nodecl_t);
static void nodecl_check_PRAGMA_CUSTOM_DECLARATION(nodecl_t);
static void nodecl_check_LOOP_CONTROL(nodecl_t);
static void nodecl_check_UNBOUNDED_LOOP_CONTROL(nodecl_t);
static void nodecl_check_SYMBOL(nodecl_t);
static void nodecl_check_FORTRAN_IO_SPEC(nodecl_t);
static void nodecl_check_OPEN_M_P_SINGLE(nodecl_t);
static void nodecl_check_ALIGNED_FLAG(nodecl_t);
static void nodecl_check_ALIGNMENT_INFO(nodecl_t);
static void nodecl_check_IN_PLACE_FLAG(nodecl_t);
static void nodecl_check_ON_TOP_FLAG(nodecl_t);
static void nodecl_check_EVICT_FLAG(nodecl_t);
static void nodecl_check_RELAXED_FLAG(nodecl_t);
static void nodecl_check_NONTEMPORAL_FLAG(nodecl_t);
static void nodecl_check_HAS_BEEN_DEFINED_FLAG(nodecl_t);
static void nodecl_check_FUNCTION_CODE(nodecl_t);
static void nodecl_check_OMP_SS_TASK_CALL(nodecl_t);
static void nodecl_check_OPEN_M_P_TASKYIELD(nodecl_t);
static void nodecl_check_OPEN_M_P_WORKSHARE(nodecl_t);
static void nodecl_check_PRAGMA_CLAUSE_ARG(nodecl_t);
static void nodecl_check_OPEN_M_P_SIMD_FUNCTION(nodecl_t);
static void nodecl_check_MEMBER_INIT(nodecl_t);
static void nodecl_check_IMPLICIT_MEMBER_INIT(nodecl_t);
static void nodecl_check_OPEN_M_P_ATOMIC(nodecl_t);
static void nodecl_check_CXX_CLASS_MEMBER_ACCESS(nodecl_t);
static void nodecl_check_CXX_ARROW(nodecl_t);
static void nodecl_check_CXX_DOT_PTR_MEMBER(nodecl_t);
static void nodecl_check_CXX_ARROW_PTR_MEMBER(nodecl_t);
static void nodecl_check_CXX_SIZEOF(nodecl_t);
static void nodecl_check_CXX_SIZEOF_PACK(nodecl_t);
static void nodecl_check_CXX_ALIGNOF(nodecl_t);
static void nodecl_check_CXX_POSTFIX_INITIALIZER(nodecl_t);
static void nodecl_check_CXX_CAST(nodecl_t);
static void nodecl_check_CXX_EXPLICIT_TYPE_CAST(nodecl_t);
static void nodecl_check_CXX_DEP_FUNCTION_CALL(nodecl_t);
static void nodecl_check_CXX_DEP_NEW(nodecl_t);
static void nodecl_check_CXX_NOEXCEPT(nodecl_t);
static void nodecl_check_CXX_LAMBDA(nodecl_t);
static void nodecl_check_CXX_ALIGNAS(nodecl_t);
static void nodecl_check_STRUCTURED_VALUE(nodecl_t);
static void nodecl_check_FORTRAN_DATA(nodecl_t);
static void nodecl_check_FORTRAN_EQUIVALENCE(nodecl_t);
static void nodecl_check_FORTRAN_BOZ_LITERAL(nodecl_t);
static void nodecl_check_FORTRAN_BIND_C(nodecl_t);
static void nodecl_check_FORTRAN_HOLLERITH(nodecl_t);
static void nodecl_check_FORTRAN_USE(nodecl_t);
static void nodecl_check_FORTRAN_USE_ONLY(nodecl_t);
static void nodecl_check_OPEN_M_P_SIMD(nodecl_t);
static void nodecl_check_FORTRAN_ACTUAL_ARGUMENT(nodecl_t);
static void nodecl_check_FORTRAN_NOT_PRESENT(nodecl_t);
static void nodecl_check_OPEN_M_P_FLUSH_AT_ENTRY(nodecl_t);
static void nodecl_check_OPEN_M_P_FLUSH_AT_EXIT(nodecl_t);
static void nodecl_check_OPEN_M_P_NO_FLUSH(nodecl_t);
static void nodecl_check_DEFAULT_ARGUMENT(nodecl_t);
static void nodecl_check_CXX_MEMBER_INIT(nodecl_t);
static void nodecl_check_MULTI_EXPRESSION_ITERATOR(nodecl_t);
static void nodecl_check_OPEN_M_P_SECTION(nodecl_t);
static void nodecl_check_COMPOUND_STATEMENT(nodecl_t);
static void nodecl_check_EMPTY_STATEMENT(nodecl_t);
static void nodecl_check_EXPRESSION_STATEMENT(nodecl_t);
static void nodecl_check_DO_STATEMENT(nodecl_t);
static void nodecl_check_WHILE_STATEMENT(nodecl_t);
static void nodecl_check_FOR_STATEMENT(nodecl_t);
static void nodecl_check_IF_ELSE_STATEMENT(nodecl_t);
static void nodecl_check_LABELED_STATEMENT(nodecl_t);
static void nodecl_check_SWITCH_STATEMENT(nodecl_t);
static void nodecl_check_DEFAULT_STATEMENT(nodecl_t);
static void nodecl_check_CASE_STATEMENT(nodecl_t);
static void nodecl_check_BREAK_STATEMENT(nodecl_t);
static void nodecl_check_CONTINUE_STATEMENT(nodecl_t);
static void nodecl_check_GOTO_STATEMENT(nodecl_t);
static void nodecl_check_RETURN_STATEMENT(nodecl_t);
static void nodecl_check_ERR_STATEMENT(nodecl_t);
static void nodecl_check_OBJECT_INIT(nodecl_t);
static void nodecl_check_GCC_ASM_SPEC(nodecl_t);
static void nodecl_check_CONTEXT(nodecl_t);
static void nodecl_check_OPEN_M_P_PARALLEL(nodecl_t);
static void nodecl_check_FUNCTION_CALL(nodecl_t);
static void nodecl_check_ARRAY_SUBSCRIPT(nodecl_t);
static void nodecl_check_CLASS_MEMBER_ACCESS(nodecl_t);
static void nodecl_check_PLUS(nodecl_t);
static void nodecl_check_NEG(nodecl_t);
static void nodecl_check_MUL(nodecl_t);
static void nodecl_check_POWER(nodecl_t);
static void nodecl_check_DIV(nodecl_t);
static void nodecl_check_MOD(nodecl_t);
static void nodecl_check_ADD(nodecl_t);
static void nodecl_check_MINUS(nodecl_t);
static void nodecl_check_CONCAT(nodecl_t);
static void nodecl_check_EQUAL(nodecl_t);
static void nodecl_check_DIFFERENT(nodecl_t);
static void nodecl_check_LOWER_THAN(nodecl_t);
static void nodecl_check_LOWER_OR_EQUAL_THAN(nodecl_t);
static void nodecl_check_GREATER_THAN(nodecl_t);
static void nodecl_check_GREATER_OR_EQUAL_THAN(nodecl_t);
static void nodecl_check_LOGICAL_NOT(nodecl_t);
static void nodecl_check_LOGICAL_AND(nodecl_t);
static void nodecl_check_LOGICAL_OR(nodecl_t);
static void nodecl_check_BITWISE_NOT(nodecl_t);
static void nodecl_check_BITWISE_AND(nodecl_t);
static void nodecl_check_BITWISE_OR(nodecl_t);
static void nodecl_check_BITWISE_XOR(nodecl_t);
static void nodecl_check_BITWISE_SHL(nodecl_t);
static void nodecl_check_ARITHMETIC_SHR(nodecl_t);
static void nodecl_check_BITWISE_SHR(nodecl_t);
static void nodecl_check_ASSIGNMENT(nodecl_t);
static void nodecl_check_PARENTHESIZED_EXPRESSION(nodecl_t);
static void nodecl_check_DEREFERENCE(nodecl_t);
static void nodecl_check_COMPOUND_EXPRESSION(nodecl_t);
static void nodecl_check_VECTOR_SUBSCRIPT(nodecl_t);
static void nodecl_check_VECTOR_ADD(nodecl_t);
static void nodecl_check_VECTOR_FMADD(nodecl_t);
static void nodecl_check_VECTOR_MINUS(nodecl_t);
static void nodecl_check_VECTOR_FMMINUS(nodecl_t);
static void nodecl_check_VECTOR_MUL(nodecl_t);
static void nodecl_check_VECTOR_DIV(nodecl_t);
static void nodecl_check_VECTOR_RCP(nodecl_t);
static void nodecl_check_VECTOR_MOD(nodecl_t);
static void nodecl_check_VECTOR_NEG(nodecl_t);
static void nodecl_check_VECTOR_SQRT(nodecl_t);
static void nodecl_check_VECTOR_RSQRT(nodecl_t);
static void nodecl_check_VECTOR_REDUCTION_ADD(nodecl_t);
static void nodecl_check_VECTOR_REDUCTION_MINUS(nodecl_t);
static void nodecl_check_VECTOR_REDUCTION_MUL(nodecl_t);
static void nodecl_check_VECTOR_EQUAL(nodecl_t);
static void nodecl_check_VECTOR_DIFFERENT(nodecl_t);
static void nodecl_check_VECTOR_LOWER_THAN(nodecl_t);
static void nodecl_check_VECTOR_LOWER_OR_EQUAL_THAN(nodecl_t);
static void nodecl_check_VECTOR_GREATER_THAN(nodecl_t);
static void nodecl_check_VECTOR_GREATER_OR_EQUAL_THAN(nodecl_t);
static void nodecl_check_VECTOR_LOGICAL_NOT(nodecl_t);
static void nodecl_check_VECTOR_LOGICAL_AND(nodecl_t);
static void nodecl_check_VECTOR_LOGICAL_OR(nodecl_t);
static void nodecl_check_VECTOR_BITWISE_NOT(nodecl_t);
static void nodecl_check_VECTOR_BITWISE_AND(nodecl_t);
static void nodecl_check_VECTOR_BITWISE_OR(nodecl_t);
static void nodecl_check_VECTOR_BITWISE_XOR(nodecl_t);
static void nodecl_check_VECTOR_BITWISE_SHL(nodecl_t);
static void nodecl_check_VECTOR_ARITHMETIC_SHR(nodecl_t);
static void nodecl_check_VECTOR_BITWISE_SHR(nodecl_t);
static void nodecl_check_VECTOR_ALIGN_RIGHT(nodecl_t);
static void nodecl_check_VECTOR_ASSIGNMENT(nodecl_t);
static void nodecl_check_VECTOR_STORE(nodecl_t);
static void nodecl_check_VECTOR_SCATTER(nodecl_t);
static void nodecl_check_VECTOR_LOAD(nodecl_t);
static void nodecl_check_VECTOR_GATHER(nodecl_t);
static void nodecl_check_VECTOR_PROMOTION(nodecl_t);
static void nodecl_check_VECTOR_PREFETCH(nodecl_t);
static void nodecl_check_VECTOR_LITERAL(nodecl_t);
static void nodecl_check_VECTOR_LANE_ID(nodecl_t);
static void nodecl_check_VECTOR_CONVERSION(nodecl_t);
static void nodecl_check_VECTOR_CAST(nodecl_t);
static void nodecl_check_VECTOR_FUNCTION_CALL(nodecl_t);
static void nodecl_check_VECTOR_FABS(nodecl_t);
static void nodecl_check_VECTOR_SINCOS(nodecl_t);
static void nodecl_check_VECTOR_MASK_ASSIGNMENT(nodecl_t);
static void nodecl_check_VECTOR_MASK_CONVERSION(nodecl_t);
static void nodecl_check_VECTOR_MASK_NOT(nodecl_t);
static void nodecl_check_VECTOR_MASK_AND(nodecl_t);
static void nodecl_check_VECTOR_MASK_OR(nodecl_t);
static void nodecl_check_VECTOR_MASK_XOR(nodecl_t);
static void nodecl_check_VECTOR_MASK_AND_1_NOT(nodecl_t);
static void nodecl_check_VECTOR_MASK_AND_2_NOT(nodecl_t);
static void nodecl_check_VECTOR_LOOP(nodecl_t);
static void nodecl_check_NOEXCEPT_IMPLICIT_TRUE(nodecl_t);
static void nodecl_check_ERR_EXPR(nodecl_t);
static void nodecl_check_CONVERSION(nodecl_t);
static void nodecl_check_DUMMY(nodecl_t);
static void nodecl_check_MULTI_EXPRESSION(nodecl_t);
static void nodecl_check_UNKNOWN(nodecl_t);
static void nodecl_check_FORTRAN_ALTERNATE_RETURN_ARGUMENT(nodecl_t);
static void nodecl_check_RANGE_DISCRETE(nodecl_t);
static void nodecl_check_FORTRAN_WHERE_PAIR(nodecl_t);
static void nodecl_check_GXX_TRAIT(nodecl_t);
static void nodecl_check_ANALYSIS_INDUCTION_VAR_EXPR(nodecl_t);
static void nodecl_check_OPEN_M_P_COMBINED_WITH_PARALLEL(nodecl_t);
static void nodecl_check_OPEN_M_P_FUNCTION_TASK_PARSING_CONTEXT(nodecl_t);
static void nodecl_check_OMP_SS_TASK_EXPRESSION(nodecl_t);
static void nodecl_check_OPEN_M_P_NUM_TASKS(nodecl_t);
static void nodecl_check_OPEN_M_P_GRAINSIZE(nodecl_t);
static void nodecl_check_OMP_SS_CHUNKSIZE(nodecl_t);
static void nodecl_check_CONDITIONAL_EXPRESSION(nodecl_t);
static void nodecl_check_REFERENCE(nodecl_t);
static void nodecl_check_COMMA(nodecl_t);
static void nodecl_check_THROW(nodecl_t);
static void nodecl_check_VIRTUAL_FUNCTION_CALL(nodecl_t);
static void nodecl_check_MUL_ASSIGNMENT(nodecl_t);
static void nodecl_check_DIV_ASSIGNMENT(nodecl_t);
static void nodecl_check_ADD_ASSIGNMENT(nodecl_t);
static void nodecl_check_MINUS_ASSIGNMENT(nodecl_t);
static void nodecl_check_BITWISE_SHL_ASSIGNMENT(nodecl_t);
static void nodecl_check_BITWISE_SHR_ASSIGNMENT(nodecl_t);
static void nodecl_check_ARITHMETIC_SHR_ASSIGNMENT(nodecl_t);
static void nodecl_check_BITWISE_AND_ASSIGNMENT(nodecl_t);
static void nodecl_check_BITWISE_OR_ASSIGNMENT(nodecl_t);
static void nodecl_check_BITWISE_XOR_ASSIGNMENT(nodecl_t);
static void nodecl_check_MOD_ASSIGNMENT(nodecl_t);
static void nodecl_check_PREINCREMENT(nodecl_t);
static void nodecl_check_POSTINCREMENT(nodecl_t);
static void nodecl_check_PREDECREMENT(nodecl_t);
static void nodecl_check_POSTDECREMENT(nodecl_t);
static void nodecl_check_SIZEOF(nodecl_t);
static void nodecl_check_ALIGNOF(nodecl_t);
static void nodecl_check_OFFSET(nodecl_t);
static void nodecl_check_TYPEID(nodecl_t);
static void nodecl_check_NEW(nodecl_t);
static void nodecl_check_DELETE(nodecl_t);
static void nodecl_check_DELETE_ARRAY(nodecl_t);
static void nodecl_check_POINTER_TO_MEMBER(nodecl_t);
static void nodecl_check_REAL_PART(nodecl_t);
static void nodecl_check_IMAG_PART(nodecl_t);
static void nodecl_check_OFFSETOF(nodecl_t);
static void nodecl_check_SHAPING(nodecl_t);
static void nodecl_check_PSEUDO_DESTRUCTOR_NAME(nodecl_t);
static void nodecl_check_VECTOR_CONDITIONAL_EXPRESSION(nodecl_t);
static void nodecl_check_VLA_WILDCARD(nodecl_t);
static void nodecl_check_GXX_BUILTIN_ADDRESSOF(nodecl_t);
static void nodecl_check_GCC_ASM_OPERAND(nodecl_t);
static void nodecl_check_ANALYSIS_ASSERT(nodecl_t);
static void nodecl_check_INTEGER_LITERAL(nodecl_t);
static void nodecl_check_FLOATING_LITERAL(nodecl_t);
static void nodecl_check_COMPLEX_LITERAL(nodecl_t);
static void nodecl_check_BOOLEAN_LITERAL(nodecl_t);
static void nodecl_check_OPEN_M_P_DEP_IN(nodecl_t);
static void nodecl_check_OPEN_M_P_DEP_OUT(nodecl_t);
static void nodecl_check_OPEN_M_P_DEP_INOUT(nodecl_t);
static void nodecl_check_OMP_SS_DEP_CONCURRENT(nodecl_t);
static void nodecl_check_OMP_SS_DEP_COMMUTATIVE(nodecl_t);
static void nodecl_check_OMP_SS_DEP_REDUCTION(nodecl_t);
static void nodecl_check_OMP_SS_DEP_WEAK_REDUCTION(nodecl_t);
static void nodecl_check_OMP_SS_DEP_IN_PRIVATE(nodecl_t);
static void nodecl_check_OMP_SS_DEP_WEAK_IN(nodecl_t);
static void nodecl_check_OMP_SS_DEP_WEAK_OUT(nodecl_t);
static void nodecl_check_OMP_SS_DEP_WEAK_INOUT(nodecl_t);
static void nodecl_check_OMP_SS_DEP_WEAK_COMMUTATIVE(nodecl_t);
static void nodecl_check_TYPE(nodecl_t);
static void nodecl_check_PRAGMA_CUSTOM_CLAUSE(nodecl_t);
static void nodecl_check_CXX_DECL(nodecl_t);
static void nodecl_check_CXX_DEF(nodecl_t);
static void nodecl_check_CXX_EXPLICIT_INSTANTIATION_DEF(nodecl_t);
static void nodecl_check_CXX_EXPLICIT_INSTANTIATION_DECL(nodecl_t);
static void nodecl_check_CXX_USING_NAMESPACE(nodecl_t);
static void nodecl_check_CXX_USING_DECL(nodecl_t);
static void nodecl_check_CXX_PARSE_LATER(nodecl_t);
static void nodecl_check_CXX_IMPLICIT_INSTANTIATION(nodecl_t);
static void nodecl_check_TEMPLATE_FUNCTION_CODE(nodecl_t);
static void nodecl_check_VERBATIM(nodecl_t);
static void nodecl_check_FORTRAN_IMPLIED_DO(nodecl_t);
static void nodecl_check_OMP_SS_ALLOCA(nodecl_t);
static void nodecl_check_OMP_SS_SHARED_AND_ALLOCA(nodecl_t);
static void nodecl_check_OMP_SS_WEAK_REDUCTION(nodecl_t);
static void nodecl_check_OMP_SS_COST(nodecl_t);
static void nodecl_check_OMP_SS_TASK_LABEL(nodecl_t);
static void nodecl_check_TRY_BLOCK(nodecl_t);
static void nodecl_check_CXX_FOR_RANGED(nodecl_t);
static void nodecl_check_CATCH_HANDLER(nodecl_t);
static void nodecl_check_CXX_STATIC_ASSERT(nodecl_t);
static void nodecl_check_OPEN_M_P_ALIGNED(nodecl_t);
static void nodecl_check_OPEN_M_P_VECTOR_LENGTH(nodecl_t);
static void nodecl_check_OPEN_M_P_VECTOR_LENGTH_FOR(nodecl_t);
static void nodecl_check_OPEN_M_P_UNIFORM(nodecl_t);
static void nodecl_check_OPEN_M_P_LINEAR(nodecl_t);
static void nodecl_check_OPEN_M_P_SUITABLE(nodecl_t);
static void nodecl_check_OPEN_M_P_OVERLAP(nodecl_t);
static void nodecl_check_OPEN_M_P_UNROLL(nodecl_t);
static void nodecl_check_OPEN_M_P_UNROLL_AND_JAM(nodecl_t);
static void nodecl_check_OPEN_M_P_NONTEMPORAL(nodecl_t);
static void nodecl_check_OPEN_M_P_PREFETCH(nodecl_t);
static void nodecl_check_OPEN_M_P_NO_PREFETCH(nodecl_t);
static void nodecl_check_OPEN_M_P_MASK(nodecl_t);
static void nodecl_check_OPEN_M_P_NO_MASK(nodecl_t);
static void nodecl_check_OPEN_M_P_SIMD_REDUCTION(nodecl_t);
static void nodecl_check_ANALYSIS_ASSERT_DECL(nodecl_t);
static void nodecl_check_CXX_CAPTURE_COPY(nodecl_t);
static void nodecl_check_CXX_CAPTURE_REFERENCE(nodecl_t);
static void nodecl_check_CXX_FUNCTION_FORM_TEMPLATE_ID(nodecl_t);
static void nodecl_check_CXX_FUNCTION_FORM_IMPLICIT(nodecl_t);
static void nodecl_check_CXX_FUNCTION_FORM_BINARY_INFIX(nodecl_t);
static void nodecl_check_CXX_FUNCTION_FORM_UNARY_PREFIX(nodecl_t);
static void nodecl_check_CXX_FUNCTION_FORM_UNARY_POSTFIX(nodecl_t);
static void nodecl_check_CXX_FUNCTION_FORM_DEFAULT_INIT(nodecl_t);
static void nodecl_check_CXX_FUNCTION_FORM_DEFAULT_INIT_BRACED(nodecl_t);
static void nodecl_check_OPEN_M_P_FOR(nodecl_t);
static void nodecl_check_OPEN_M_P_FOR_APPENDIX(nodecl_t);
static void nodecl_check_ASM_DEFINITION(nodecl_t);
static void nodecl_check_OPEN_M_P_DECLARE_TARGET(nodecl_t);
static void nodecl_check_OPEN_M_P_TASKLOOP(nodecl_t);
static void nodecl_check_OMP_SS_RELEASE(nodecl_t);
static void nodecl_check_OPEN_M_P_TASK_IS_TASKWAIT(nodecl_t);
static void nodecl_check_OMP_SS_TASK_IS_LOOP(nodecl_t);
static void nodecl_check_OMP_SS_TASK_IS_TASK_CALL(nodecl_t);
static void nodecl_check_OPEN_M_P_TASK(nodecl_t);
static void nodecl_check_ANALYSIS_REACH_DEF_EXPR(nodecl_t);
static void nodecl_check_OPEN_M_P_BARRIER_AT_END(nodecl_t);
static void nodecl_check_OPEN_M_P_DEVICE(nodecl_t);
static void nodecl_check_OPEN_M_P_MAP_TO(nodecl_t);
static void nodecl_check_OPEN_M_P_MAP_FROM(nodecl_t);
static void nodecl_check_OPEN_M_P_MAP_TO_FROM(nodecl_t);
static void nodecl_check_OPEN_M_P_MAP_ALLOC(nodecl_t);
static void nodecl_check_OPEN_M_P_MOTION_TO(nodecl_t);
static void nodecl_check_OPEN_M_P_MOTION_FROM(nodecl_t);
static void nodecl_check_OPEN_M_P_NUM_TEAMS(nodecl_t);
static void nodecl_check_OPEN_M_P_THREAD_LIMIT(nodecl_t);
static void nodecl_check_OPEN_M_P_TARGET_TASK_UNDEFERRED(nodecl_t);
static void nodecl_check_OPEN_M_P_FIRSTPRIVATE(nodecl_t);
static void nodecl_check_OPEN_M_P_LASTPRIVATE(nodecl_t);
static void nodecl_check_OPEN_M_P_FIRST_LASTPRIVATE(nodecl_t);
static void nodecl_check_OPEN_M_P_SHARED(nodecl_t);
static void nodecl_check_OPEN_M_P_THREADPRIVATE(nodecl_t);
static void nodecl_check_OPEN_M_P_PRIVATE(nodecl_t);
static void nodecl_check_OPEN_M_P_AUTO(nodecl_t);
static void nodecl_check_OPEN_M_P_REDUCTION(nodecl_t);
static void nodecl_check_OPEN_M_P_TASK_REDUCTION(nodecl_t);
static void nodecl_check_OPEN_M_P_IN_REDUCTION(nodecl_t);
static void nodecl_check_OPEN_M_P_PRIVATE_INIT(nodecl_t);
static void nodecl_check_FORTRAN_ALLOCATE_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_ARITHMETIC_IF_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_ASSIGNED_GOTO_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_OPEN_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_CLOSE_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_COMPUTED_GOTO_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_ALTERNATE_RETURN_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_DEALLOCATE_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_IO_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_LABEL_ASSIGN_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_NULLIFY_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_PRINT_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_READ_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_WRITE_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_STOP_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_PAUSE_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_ENTRY_STATEMENT(nodecl_t);
static void nodecl_check_FORTRAN_WHERE(nodecl_t);
static void nodecl_check_FORTRAN_FORALL(nodecl_t);
static void nodecl_check_OPEN_M_P_TARGET_DATA(nodecl_t);
static void nodecl_check_OPEN_M_P_TARGET(nodecl_t);
static void nodecl_check_OPEN_M_P_TARGET_UPDATE(nodecl_t);
static void nodecl_check_OPEN_M_P_TEAMS(nodecl_t);
static void nodecl_check_OPEN_M_P_DISTRIBUTE(nodecl_t);
static void nodecl_check_MASK_LITERAL(nodecl_t);
static void nodecl_check_CHECKPOINT_STORE(nodecl_t);
static void nodecl_check_CHECKPOINT_LOAD(nodecl_t);
static void nodecl_check_CHECKPOINT_INIT(nodecl_t);
static void nodecl_check_CHECKPOINT_SHUTDOWN(nodecl_t);
static void nodecl_check_CHECKPOINT_DATA(nodecl_t);
static void nodecl_check_CHECKPOINT_LEVEL(nodecl_t);
static void nodecl_check_CHECKPOINT_ID(nodecl_t);
static void nodecl_check_CHECKPOINT_COMM(nodecl_t);
static void nodecl_check_CHECKPOINT_IF(nodecl_t);
static void nodecl_check_CHECKPOINT_KIND(nodecl_t);
static void nodecl_check_SOURCE_COMMENT(nodecl_t);
static void nodecl_check_OMP_SS_TARGET(nodecl_t);
static void nodecl_check_RANGE_LOOP_CONTROL(nodecl_t);
static void nodecl_check_ITERATOR_LOOP_CONTROL(nodecl_t);
static void nodecl_check_OPEN_M_P_CRITICAL_NAME(nodecl_t);
static void nodecl_check_CXX_DEP_NAME_SIMPLE(nodecl_t);
static void nodecl_check_ANALYSIS_UPPER_EXPOSED(nodecl_t);
static void nodecl_check_ANALYSIS_DEFINED(nodecl_t);
static void nodecl_check_ANALYSIS_UNDEFINED(nodecl_t);
static void nodecl_check_ANALYSIS_LIVE_IN(nodecl_t);
static void nodecl_check_ANALYSIS_LIVE_OUT(nodecl_t);
static void nodecl_check_ANALYSIS_DEAD(nodecl_t);
static void nodecl_check_ANALYSIS_REACHING_DEFINITION_IN(nodecl_t);
static void nodecl_check_ANALYSIS_REACHING_DEFINITION_OUT(nodecl_t);
static void nodecl_check_ANALYSIS_INDUCTION_VARIABLE(nodecl_t);
static void nodecl_check_ANALYSIS_AUTO_SCOPE_FIRSTPRIVATE(nodecl_t);
static void nodecl_check_ANALYSIS_AUTO_SCOPE_PRIVATE(nodecl_t);
static void nodecl_check_ANALYSIS_AUTO_SCOPE_SHARED(nodecl_t);
static void nodecl_check_ANALYSIS_RANGE(nodecl_t);
static void nodecl_check_ANALYSIS_CORRECTNESS_AUTO_STORAGE(nodecl_t);
static void nodecl_check_ANALYSIS_CORRECTNESS_DEAD(nodecl_t);
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_FP(nodecl_t);
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_P(nodecl_t);
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_IN(nodecl_t);
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_OUT(nodecl_t);
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_IN_POINTED(nodecl_t);
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_OUT_POINTED(nodecl_t);
static void nodecl_check_ANALYSIS_CORRECTNESS_RACE(nodecl_t);
static void nodecl_check_VECTOR_FUNCTION_CODE(nodecl_t);
static void nodecl_check_UPC_SYNC_STATEMENT(nodecl_t);
static void nodecl_check_CXX_DEP_GLOBAL_NAME_NESTED(nodecl_t);
static void nodecl_check_CXX_DEP_NAME_NESTED(nodecl_t);
static void nodecl_check_UNKNOWN_PRAGMA(nodecl_t);
static void nodecl_check_FIELD_DESIGNATOR(nodecl_t);
static void nodecl_check_INDEX_DESIGNATOR(nodecl_t);
static void nodecl_check_PREPROCESSOR_LINE(nodecl_t);
static void nodecl_check_CXX_INITIALIZER(nodecl_t);
static void nodecl_check_CXX_BRACED_INITIALIZER(nodecl_t);
static void nodecl_check_CXX_EQUAL_INITIALIZER(nodecl_t);
static void nodecl_check_CXX_PARENTHESIZED_INITIALIZER(nodecl_t);
static void nodecl_check_C99_DESIGNATED_INITIALIZER(nodecl_t);
static void nodecl_check_C99_FIELD_DESIGNATOR(nodecl_t);
static void nodecl_check_C99_INDEX_DESIGNATOR(nodecl_t);
static void nodecl_check_CXX_VALUE_PACK(nodecl_t);
static void nodecl_check_CXX_VALUE_PACK_EXPANDED(nodecl_t);
static void nodecl_check_OPEN_M_P_IF(nodecl_t);
static void nodecl_check_OPEN_M_P_FINAL(nodecl_t);
static void nodecl_check_OPEN_M_P_PRIORITY(nodecl_t);
static void nodecl_check_OPEN_M_P_MERGEABLE(nodecl_t);
static void nodecl_check_OPEN_M_P_UNTIED(nodecl_t);
static void nodecl_check_OMP_SS_WAIT(nodecl_t);
static void nodecl_check_OPEN_M_P_REDUCTION_ITEM(nodecl_t);
static void nodecl_check_OMP_SS_COPY_IN(nodecl_t);
static void nodecl_check_OMP_SS_COPY_OUT(nodecl_t);
static void nodecl_check_OMP_SS_COPY_INOUT(nodecl_t);
static void nodecl_check_OMP_SS_N_D_RANGE(nodecl_t);
static void nodecl_check_OMP_SS_SH_MEM(nodecl_t);
static void nodecl_check_OMP_SS_FILE(nodecl_t);
static void nodecl_check_OMP_SS_NAME(nodecl_t);
static void nodecl_check_OMP_SS_ONTO(nodecl_t);
static void nodecl_check_OMP_SS_IMPLEMENTS(nodecl_t);
static void nodecl_check_structured_value_form(nodecl_t);
static void nodecl_check_cxx_atom_dependent_name(nodecl_t);
static void nodecl_check_text(nodecl_t);
static void nodecl_check_cuda_expressions(nodecl_t);
static void nodecl_check_pragma_directive(nodecl_t);
static void nodecl_check_pragma_context(nodecl_t);
static void nodecl_check_range_expression(nodecl_t);
static void nodecl_check_sections_construct(nodecl_t);
static void nodecl_check_fortran_data_item(nodecl_t);
static void nodecl_check_master_construct(nodecl_t);
static void nodecl_check_pragma_line(nodecl_t);
static void nodecl_check_gcc_builtin_va_arg(nodecl_t);
static void nodecl_check_critical_construct(nodecl_t);
static void nodecl_check_pragma_statement(nodecl_t);
static void nodecl_check_oss_specific_constructs(nodecl_t);
static void nodecl_check_nodecl(nodecl_t);
static void nodecl_check_intel_expressions(nodecl_t);
static void nodecl_check_data_coordination_constructs(nodecl_t);
static void nodecl_check_simd_for_construct(nodecl_t);
static void nodecl_check_constraint_expression(nodecl_t);
static void nodecl_check_string_literal(nodecl_t);
static void nodecl_check_omp_loop_info(nodecl_t);
static void nodecl_check_target_declaration(nodecl_t);
static void nodecl_check_gcc_asm_definition(nodecl_t);
static void nodecl_check_synchronization(nodecl_t);
static void nodecl_check_parallel_simd_for_construct(nodecl_t);
static void nodecl_check_pragma_declaration(nodecl_t);
static void nodecl_check_loop_control(nodecl_t);
static void nodecl_check_name(nodecl_t);
static void nodecl_check_fortran_io_spec(nodecl_t);
static void nodecl_check_single_construct(nodecl_t);
static void nodecl_check_vector_flags(nodecl_t);
static void nodecl_check_regular_function_code(nodecl_t);
static void nodecl_check_fortran_io_item(nodecl_t);
static void nodecl_check_task_call(nodecl_t);
static void nodecl_check_simd_constructs(nodecl_t);
static void nodecl_check_cxx_expr_dependent_nodecls(nodecl_t);
static void nodecl_check_taskyield_construct(nodecl_t);
static void nodecl_check_workshare_construct(nodecl_t);
static void nodecl_check_top_level(nodecl_t);
static void nodecl_check_pragma_clause_arg(nodecl_t);
static void nodecl_check_simd_func_construct(nodecl_t);
static void nodecl_check_mem_init(nodecl_t);
static void nodecl_check_atomic_construct(nodecl_t);
static void nodecl_check_cxx_dependent_expressions(nodecl_t);
static void nodecl_check_structured_value(nodecl_t);
static void nodecl_check_fortran_expressions(nodecl_t);
static void nodecl_check_simd_construct(nodecl_t);
static void nodecl_check_fortran_actual_argument(nodecl_t);
static void nodecl_check_omp_memory_info(nodecl_t);
static void nodecl_check_default_arg(nodecl_t);
static void nodecl_check_cxx_mem_init(nodecl_t);
static void nodecl_check_multi_expr_iterator(nodecl_t);
static void nodecl_check_section_construct(nodecl_t);
static void nodecl_check_compound_statement(nodecl_t);
static void nodecl_check_statement_but_object_init(nodecl_t);
static void nodecl_check_object_init(nodecl_t);
static void nodecl_check_gcc_asm_spec(nodecl_t);
static void nodecl_check_context(nodecl_t);
static void nodecl_check_parallel_construct(nodecl_t);
static void nodecl_check_fortran_argument(nodecl_t);
static void nodecl_check_expression(nodecl_t);
static void nodecl_check_alt_return(nodecl_t);
static void nodecl_check_range_discrete(nodecl_t);
static void nodecl_check_parallel_execution(nodecl_t);
static void nodecl_check_where_pair(nodecl_t);
static void nodecl_check_gxx_traits(nodecl_t);
static void nodecl_check_induction_var_expression(nodecl_t);
static void nodecl_check_omp_construct_info(nodecl_t);
static void nodecl_check_task_expression(nodecl_t);
static void nodecl_check_omp_taskloop_info(nodecl_t);
static void nodecl_check_c_cxx_expressions(nodecl_t);
static void nodecl_check_type_or_expr(nodecl_t);
static void nodecl_check_gcc_asm_operand(nodecl_t);
static void nodecl_check_assert_construct(nodecl_t);
static void nodecl_check_literal(nodecl_t);
static void nodecl_check_statement(nodecl_t);
static void nodecl_check_omp_deps_info(nodecl_t);
static void nodecl_check_type(nodecl_t);
static void nodecl_check_pragma_custom_clause(nodecl_t);
static void nodecl_check_cxx_decl(nodecl_t);
static void nodecl_check_template_function_code(nodecl_t);
static void nodecl_check_verbatim(nodecl_t);
static void nodecl_check_fortran_implied_do(nodecl_t);
static void nodecl_check_omp_exec_environment(nodecl_t);
static void nodecl_check_parallel_statements(nodecl_t);
static void nodecl_check_c_cxx_only_statements(nodecl_t);
static void nodecl_check_omp_simd_info(nodecl_t);
static void nodecl_check_assert_directive(nodecl_t);
static void nodecl_check_explicit_capture(nodecl_t);
static void nodecl_check_function_form(nodecl_t);
static void nodecl_check_omp_for_construct(nodecl_t);
static void nodecl_check_asm_definition(nodecl_t);
static void nodecl_check_device_constructs_top_level(nodecl_t);
static void nodecl_check_taskloop_construct(nodecl_t);
static void nodecl_check_release_deps_construct(nodecl_t);
static void nodecl_check_omp_task_flags(nodecl_t);
static void nodecl_check_task_construct(nodecl_t);
static void nodecl_check_reach_def_expression(nodecl_t);
static void nodecl_check_omp_sync_info(nodecl_t);
static void nodecl_check_omp_device_info(nodecl_t);
static void nodecl_check_argument(nodecl_t);
static void nodecl_check_omp_data_sharings_info(nodecl_t);
static void nodecl_check_fortran_only_statements(nodecl_t);
static void nodecl_check_any(nodecl_t);
static void nodecl_check_device_constructs(nodecl_t);
static void nodecl_check_mask_expressions(nodecl_t);
static void nodecl_check_checkpoint_directives(nodecl_t);
static void nodecl_check_checkpoint_environment(nodecl_t);
static void nodecl_check_source_comment(nodecl_t);
static void nodecl_check_ompss_device_info(nodecl_t);
static void nodecl_check_function_code(nodecl_t);
static void nodecl_check_range_loop_control(nodecl_t);
static void nodecl_check_omp_critical_info(nodecl_t);
static void nodecl_check_cxx_simple_name(nodecl_t);
static void nodecl_check_analysis_exec_environment(nodecl_t);
static void nodecl_check_vector_regular_function_code(nodecl_t);
static void nodecl_check_compatibility(nodecl_t);
static void nodecl_check_upc_sync_statement(nodecl_t);
static void nodecl_check_multi_expr_range_expression(nodecl_t);
static void nodecl_check_cxx_dependent_name(nodecl_t);
static void nodecl_check_unknown_pragma(nodecl_t);
static void nodecl_check_initializer_item(nodecl_t);
static void nodecl_check_preprocessor_text(nodecl_t);
static void nodecl_check_cxx_dependent_initializer(nodecl_t);
static void nodecl_check_cxx_pack(nodecl_t);
static void nodecl_check_omp_execution_control(nodecl_t);
static void nodecl_check_omp_reduction_item(nodecl_t);
static void nodecl_check_ompss_device_info_clauses(nodecl_t);

static void nodecl_check_STRUCTURED_VALUE_PARENTHESIZED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_STRUCTURED_VALUE_PARENTHESIZED, "Invalid node", 0);
}
static void nodecl_check_STRUCTURED_VALUE_BRACED_TYPECAST(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_STRUCTURED_VALUE_BRACED_TYPECAST, "Invalid node", 0);
}
static void nodecl_check_STRUCTURED_VALUE_BRACED_IMPLICIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_STRUCTURED_VALUE_BRACED_IMPLICIT, "Invalid node", 0);
}
static void nodecl_check_STRUCTURED_VALUE_COMPOUND_LITERAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_STRUCTURED_VALUE_COMPOUND_LITERAL, "Invalid node", 0);
}
static void nodecl_check_STRUCTURED_VALUE_FORTRAN_TYPESPEC_ARRAY_CONSTRUCTOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_STRUCTURED_VALUE_FORTRAN_TYPESPEC_ARRAY_CONSTRUCTOR, "Invalid node", 0);
}
static void nodecl_check_CXX_DEP_TEMPLATE_ID(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DEP_TEMPLATE_ID, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_cxx_atom_dependent_name(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_DEP_NAME_CONVERSION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DEP_NAME_CONVERSION, "Invalid node", 0);
nodecl_check_context(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_type);
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_any);
}
static void nodecl_check_CXX_DEP_DECLTYPE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DEP_DECLTYPE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
}
static void nodecl_check_TEXT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_TEXT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
}
static void nodecl_check_CUDA_KERNEL_CALL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CUDA_KERNEL_CALL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_PRAGMA_CUSTOM_DIRECTIVE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PRAGMA_CUSTOM_DIRECTIVE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_pragma_line(nodecl_get_child(n, 0));
nodecl_check_pragma_context(nodecl_get_child(n, 1));
}
static void nodecl_check_PRAGMA_CONTEXT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PRAGMA_CONTEXT, "Invalid node", 0);
}
static void nodecl_check_RANGE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_RANGE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
nodecl_check_expression(nodecl_get_child(n, 2));
}
static void nodecl_check_OPEN_M_P_SECTIONS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_SECTIONS, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_section_construct);
}
static void nodecl_check_OPEN_M_P_MASTER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_MASTER, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_statement);
}
static void nodecl_check_PRAGMA_CUSTOM_LINE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PRAGMA_CUSTOM_LINE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_pragma_clause_arg);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_pragma_custom_clause);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 2), nodecl_check_pragma_custom_clause);
}
static void nodecl_check_GCC_BUILTIN_VA_ARG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_GCC_BUILTIN_VA_ARG, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_type(nodecl_get_child(n, 1));
}
static void nodecl_check_OPEN_M_P_CRITICAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_CRITICAL, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_PRAGMA_CUSTOM_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PRAGMA_CUSTOM_STATEMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_pragma_line(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_OMP_SS_LOOP(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_LOOP, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_statement(nodecl_get_child(n, 1));
}
static void nodecl_check_TOP_LEVEL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_TOP_LEVEL, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_top_level);
}
static void nodecl_check_INTEL_ASSUME_ALIGNED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_INTEL_ASSUME_ALIGNED, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_INTEL_ASSUME(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_INTEL_ASSUME, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OMP_SS_REGISTER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_REGISTER, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_UNREGISTER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_UNREGISTER, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_SIMD_FOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_SIMD_FOR, "Invalid node", 0);
nodecl_check_omp_for_construct(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_omp_exec_environment);
}
static void nodecl_check_ANALYSIS_PHI(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_PHI, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_RANGE_UNION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_RANGE_UNION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_ANALYSIS_RANGE_INTERSECTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_RANGE_INTERSECTION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_ANALYSIS_RANGE_SUB(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_RANGE_SUB, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_ANALYSIS_EMPTY_RANGE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_EMPTY_RANGE, "Invalid node", 0);
}
static void nodecl_check_ANALYSIS_MINUS_INFINITY(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_MINUS_INFINITY, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_ANALYSIS_PLUS_INFINITY(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_PLUS_INFINITY, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_ANALYSIS_MINIMUM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_MINIMUM, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_MAXIMUM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_MAXIMUM, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_STRING_LITERAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_STRING_LITERAL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_OPEN_M_P_SCHEDULE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_SCHEDULE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_DIST_SCHEDULE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_DIST_SCHEDULE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_TARGET_DECLARATION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_TARGET_DECLARATION, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_text);
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_name);
}
static void nodecl_check_GCC_ASM_DEFINITION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_GCC_ASM_DEFINITION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_gcc_asm_operand);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_gcc_asm_operand);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 2), nodecl_check_gcc_asm_operand);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 3), nodecl_check_text);
}
static void nodecl_check_OPEN_M_P_TASKWAIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TASKWAIT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
}
static void nodecl_check_OPEN_M_P_TASKGROUP(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TASKGROUP, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_OPEN_M_P_FLUSH_MEMORY(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_FLUSH_MEMORY, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_BARRIER_FULL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_BARRIER_FULL, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
}
static void nodecl_check_OPEN_M_P_BARRIER_SIGNAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_BARRIER_SIGNAL, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_BARRIER_WAIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_BARRIER_WAIT, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_PARALLEL_SIMD_FOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_PARALLEL_SIMD_FOR, "Invalid node", 0);
nodecl_check_statement(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_omp_exec_environment);
}
static void nodecl_check_PRAGMA_CUSTOM_DECLARATION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PRAGMA_CUSTOM_DECLARATION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_pragma_line(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_pragma_declaration);
nodecl_check_pragma_context(nodecl_get_child(n, 2));
nodecl_check_nullable_rule(nodecl_get_child(n, 3), nodecl_check_pragma_context);
}
static void nodecl_check_LOOP_CONTROL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_LOOP_CONTROL, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_UNBOUNDED_LOOP_CONTROL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_UNBOUNDED_LOOP_CONTROL, "Invalid node", 0);
}
static void nodecl_check_SYMBOL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_SYMBOL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
}
static void nodecl_check_FORTRAN_IO_SPEC(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_IO_SPEC, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_SINGLE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_SINGLE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_ALIGNED_FLAG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ALIGNED_FLAG, "Invalid node", 0);
}
static void nodecl_check_ALIGNMENT_INFO(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ALIGNMENT_INFO, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_IN_PLACE_FLAG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_IN_PLACE_FLAG, "Invalid node", 0);
}
static void nodecl_check_ON_TOP_FLAG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ON_TOP_FLAG, "Invalid node", 0);
}
static void nodecl_check_EVICT_FLAG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_EVICT_FLAG, "Invalid node", 0);
}
static void nodecl_check_RELAXED_FLAG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_RELAXED_FLAG, "Invalid node", 0);
}
static void nodecl_check_NONTEMPORAL_FLAG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_NONTEMPORAL_FLAG, "Invalid node", 0);
}
static void nodecl_check_HAS_BEEN_DEFINED_FLAG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_HAS_BEEN_DEFINED_FLAG, "Invalid node", 0);
}
static void nodecl_check_FUNCTION_CODE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FUNCTION_CODE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_context(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_mem_init);
}
static void nodecl_check_OMP_SS_TASK_CALL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_TASK_CALL, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 2), nodecl_check_omp_exec_environment);
}
static void nodecl_check_OPEN_M_P_TASKYIELD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TASKYIELD, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_WORKSHARE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_WORKSHARE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_PRAGMA_CLAUSE_ARG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PRAGMA_CLAUSE_ARG, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
}
static void nodecl_check_OPEN_M_P_SIMD_FUNCTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_SIMD_FUNCTION, "Invalid node", 0);
nodecl_check_statement(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_omp_exec_environment);
}
static void nodecl_check_MEMBER_INIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_MEMBER_INIT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_IMPLICIT_MEMBER_INIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_IMPLICIT_MEMBER_INIT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_ATOMIC(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_ATOMIC, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_CXX_CLASS_MEMBER_ACCESS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_CLASS_MEMBER_ACCESS, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_CXX_ARROW(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_ARROW, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_CXX_DOT_PTR_MEMBER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DOT_PTR_MEMBER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_CXX_ARROW_PTR_MEMBER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_ARROW_PTR_MEMBER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_CXX_SIZEOF(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_SIZEOF, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_SIZEOF_PACK(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_SIZEOF_PACK, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_ALIGNOF(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_ALIGNOF, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_POSTFIX_INITIALIZER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_POSTFIX_INITIALIZER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_CAST(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_CAST, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_EXPLICIT_TYPE_CAST(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_EXPLICIT_TYPE_CAST, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_cxx_dependent_initializer(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_DEP_FUNCTION_CALL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DEP_FUNCTION_CALL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_argument);
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_name);
}
static void nodecl_check_CXX_DEP_NEW(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DEP_NEW, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_type);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_CXX_NOEXCEPT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_NOEXCEPT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_LAMBDA(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_LAMBDA, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_explicit_capture);
}
static void nodecl_check_CXX_ALIGNAS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_ALIGNAS, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_STRUCTURED_VALUE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_STRUCTURED_VALUE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_initializer_item);
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_structured_value_form);
}
static void nodecl_check_FORTRAN_DATA(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_DATA, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_fortran_data_item);
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_fortran_data_item);
}
static void nodecl_check_FORTRAN_EQUIVALENCE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_EQUIVALENCE, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_FORTRAN_BOZ_LITERAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_BOZ_LITERAL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_FORTRAN_BIND_C(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_BIND_C, "Invalid node", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_FORTRAN_HOLLERITH(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_HOLLERITH, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_FORTRAN_USE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_USE, "Invalid node", 0);
nodecl_check_name(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_name);
}
static void nodecl_check_FORTRAN_USE_ONLY(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_USE_ONLY, "Invalid node", 0);
nodecl_check_name(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_name);
}
static void nodecl_check_OPEN_M_P_SIMD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_SIMD, "Invalid node", 0);
nodecl_check_statement(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_omp_exec_environment);
}
static void nodecl_check_FORTRAN_ACTUAL_ARGUMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_ACTUAL_ARGUMENT, "Invalid node", 0);
nodecl_check_fortran_argument(nodecl_get_child(n, 0));
}
static void nodecl_check_FORTRAN_NOT_PRESENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_NOT_PRESENT, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_FLUSH_AT_ENTRY(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_FLUSH_AT_ENTRY, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_FLUSH_AT_EXIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_FLUSH_AT_EXIT, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_NO_FLUSH(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_NO_FLUSH, "Invalid node", 0);
}
static void nodecl_check_DEFAULT_ARGUMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_DEFAULT_ARGUMENT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_MEMBER_INIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_MEMBER_INIT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_cxx_dependent_name(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_MULTI_EXPRESSION_ITERATOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_MULTI_EXPRESSION_ITERATOR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_multi_expr_range_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_SECTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_SECTION, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_statement);
}
static void nodecl_check_COMPOUND_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_COMPOUND_STATEMENT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_statement);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_EMPTY_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_EMPTY_STATEMENT, "Invalid node", 0);
}
static void nodecl_check_EXPRESSION_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_EXPRESSION_STATEMENT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_DO_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_DO_STATEMENT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_statement);
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_WHILE_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_WHILE_STATEMENT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_name);
}
static void nodecl_check_FOR_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FOR_STATEMENT, "Invalid node", 0);
nodecl_check_loop_control(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_name);
}
static void nodecl_check_IF_ELSE_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_IF_ELSE_STATEMENT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 2), nodecl_check_statement);
}
static void nodecl_check_LABELED_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_LABELED_STATEMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_statement);
}
static void nodecl_check_SWITCH_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_SWITCH_STATEMENT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_DEFAULT_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_DEFAULT_STATEMENT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_statement);
}
static void nodecl_check_CASE_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CASE_STATEMENT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_BREAK_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BREAK_STATEMENT, "Invalid node", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_name);
}
static void nodecl_check_CONTINUE_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CONTINUE_STATEMENT, "Invalid node", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_name);
}
static void nodecl_check_GOTO_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_GOTO_STATEMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
}
static void nodecl_check_RETURN_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_RETURN_STATEMENT, "Invalid node", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ERR_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ERR_STATEMENT, "Invalid node", 0);
}
static void nodecl_check_OBJECT_INIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OBJECT_INIT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
}
static void nodecl_check_GCC_ASM_SPEC(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_GCC_ASM_SPEC, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
}
static void nodecl_check_CONTEXT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CONTEXT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_statement);
}
static void nodecl_check_OPEN_M_P_PARALLEL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_PARALLEL, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
nodecl_check_list_rule(nodecl_get_child(n, 2), nodecl_check_statement);
}
static void nodecl_check_FUNCTION_CALL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FUNCTION_CALL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_argument);
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
nodecl_check_nullable_rule(nodecl_get_child(n, 3), nodecl_check_function_form);
}
static void nodecl_check_ARRAY_SUBSCRIPT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ARRAY_SUBSCRIPT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_CLASS_MEMBER_ACCESS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CLASS_MEMBER_ACCESS, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_name(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_cxx_dependent_name);
}
static void nodecl_check_PLUS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PLUS, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_NEG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_NEG, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_MUL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_MUL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_POWER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_POWER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_DIV(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_DIV, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_MOD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_MOD, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_ADD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ADD, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_MINUS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_MINUS, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_CONCAT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CONCAT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_EQUAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_EQUAL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_DIFFERENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_DIFFERENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_LOWER_THAN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_LOWER_THAN, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_LOWER_OR_EQUAL_THAN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_LOWER_OR_EQUAL_THAN, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_GREATER_THAN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_GREATER_THAN, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_GREATER_OR_EQUAL_THAN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_GREATER_OR_EQUAL_THAN, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_LOGICAL_NOT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_LOGICAL_NOT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_LOGICAL_AND(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_LOGICAL_AND, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_LOGICAL_OR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_LOGICAL_OR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_BITWISE_NOT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_NOT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_BITWISE_AND(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_AND, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_BITWISE_OR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_OR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_BITWISE_XOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_XOR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_BITWISE_SHL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_SHL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_ARITHMETIC_SHR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ARITHMETIC_SHR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_BITWISE_SHR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_SHR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_PARENTHESIZED_EXPRESSION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PARENTHESIZED_EXPRESSION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_DEREFERENCE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_DEREFERENCE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_COMPOUND_EXPRESSION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_COMPOUND_EXPRESSION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_context(nodecl_get_child(n, 0));
}
static void nodecl_check_VECTOR_SUBSCRIPT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_SUBSCRIPT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_VECTOR_ADD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_ADD, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_FMADD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_FMADD, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_expression(nodecl_get_child(n, 2));
nodecl_check_nullable_rule(nodecl_get_child(n, 3), nodecl_check_expression);
}
static void nodecl_check_VECTOR_MINUS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MINUS, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_FMMINUS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_FMMINUS, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
nodecl_check_nullable_rule(nodecl_get_child(n, 3), nodecl_check_expression);
}
static void nodecl_check_VECTOR_MUL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MUL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_DIV(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_DIV, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_RCP(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_RCP, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_MOD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MOD, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_NEG(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_NEG, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_SQRT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_SQRT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_RSQRT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_RSQRT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_REDUCTION_ADD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_REDUCTION_ADD, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_REDUCTION_MINUS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_REDUCTION_MINUS, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_REDUCTION_MUL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_REDUCTION_MUL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_EQUAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_EQUAL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_DIFFERENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_DIFFERENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_LOWER_THAN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_LOWER_THAN, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_LOWER_OR_EQUAL_THAN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_LOWER_OR_EQUAL_THAN, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_GREATER_THAN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_GREATER_THAN, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_GREATER_OR_EQUAL_THAN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_GREATER_OR_EQUAL_THAN, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_LOGICAL_NOT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_LOGICAL_NOT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_LOGICAL_AND(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_LOGICAL_AND, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_LOGICAL_OR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_LOGICAL_OR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_BITWISE_NOT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_BITWISE_NOT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_BITWISE_AND(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_BITWISE_AND, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_BITWISE_OR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_BITWISE_OR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_BITWISE_XOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_BITWISE_XOR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_BITWISE_SHL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_BITWISE_SHL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_ARITHMETIC_SHR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_ARITHMETIC_SHR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_BITWISE_SHR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_BITWISE_SHR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_ALIGN_RIGHT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_ALIGN_RIGHT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_expression(nodecl_get_child(n, 2));
nodecl_check_nullable_rule(nodecl_get_child(n, 3), nodecl_check_expression);
}
static void nodecl_check_VECTOR_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
nodecl_check_nullable_rule(nodecl_get_child(n, 3), nodecl_check_vector_flags);
}
static void nodecl_check_VECTOR_STORE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_STORE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 3), nodecl_check_vector_flags);
}
static void nodecl_check_VECTOR_SCATTER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_SCATTER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_expression(nodecl_get_child(n, 2));
nodecl_check_nullable_rule(nodecl_get_child(n, 3), nodecl_check_expression);
}
static void nodecl_check_VECTOR_LOAD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_LOAD, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 2), nodecl_check_vector_flags);
}
static void nodecl_check_VECTOR_GATHER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_GATHER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_VECTOR_PROMOTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_PROMOTION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_PREFETCH(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_PREFETCH, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_VECTOR_LITERAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_LITERAL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_LANE_ID(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_LANE_ID, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_VECTOR_CONVERSION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_CONVERSION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_CAST(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_CAST, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_FUNCTION_CALL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_FUNCTION_CALL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_FABS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_FABS, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_argument(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_VECTOR_SINCOS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_SINCOS, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_argument(nodecl_get_child(n, 0));
nodecl_check_argument(nodecl_get_child(n, 1));
nodecl_check_argument(nodecl_get_child(n, 2));
nodecl_check_nullable_rule(nodecl_get_child(n, 3), nodecl_check_expression);
}
static void nodecl_check_VECTOR_MASK_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MASK_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_VECTOR_MASK_CONVERSION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MASK_CONVERSION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_VECTOR_MASK_NOT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MASK_NOT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_VECTOR_MASK_AND(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MASK_AND, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_VECTOR_MASK_OR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MASK_OR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_VECTOR_MASK_XOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MASK_XOR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_VECTOR_MASK_AND_1_NOT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MASK_AND_1_NOT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_VECTOR_MASK_AND_2_NOT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_MASK_AND_2_NOT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_VECTOR_LOOP(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_LOOP, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_expression(nodecl_get_child(n, 2));
}
static void nodecl_check_NOEXCEPT_IMPLICIT_TRUE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_NOEXCEPT_IMPLICIT_TRUE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_ERR_EXPR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ERR_EXPR, "Invalid node", 0);
}
static void nodecl_check_CONVERSION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CONVERSION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_DUMMY(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_DUMMY, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
}
static void nodecl_check_MULTI_EXPRESSION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_MULTI_EXPRESSION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_multi_expr_iterator);
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_UNKNOWN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_UNKNOWN, "Invalid node", 0);
}
static void nodecl_check_FORTRAN_ALTERNATE_RETURN_ARGUMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_ALTERNATE_RETURN_ARGUMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
}
static void nodecl_check_RANGE_DISCRETE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_RANGE_DISCRETE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_FORTRAN_WHERE_PAIR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_WHERE_PAIR, "Invalid node", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_GXX_TRAIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_GXX_TRAIT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_type(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_type);
}
static void nodecl_check_ANALYSIS_INDUCTION_VAR_EXPR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_INDUCTION_VAR_EXPR, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_expression);
nodecl_check_list_rule(nodecl_get_child(n, 2), nodecl_check_expression);
nodecl_check_expression(nodecl_get_child(n, 3));
}
static void nodecl_check_OPEN_M_P_COMBINED_WITH_PARALLEL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_COMBINED_WITH_PARALLEL, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_FUNCTION_TASK_PARSING_CONTEXT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_FUNCTION_TASK_PARSING_CONTEXT, "Invalid node", 0);
nodecl_check_pragma_context(nodecl_get_child(n, 0));
}
static void nodecl_check_OMP_SS_TASK_EXPRESSION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_TASK_EXPRESSION, "Invalid node", 0);
nodecl_check_statement(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
nodecl_check_statement(nodecl_get_child(n, 2));
}
static void nodecl_check_OPEN_M_P_NUM_TASKS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_NUM_TASKS, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_GRAINSIZE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_GRAINSIZE, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OMP_SS_CHUNKSIZE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_CHUNKSIZE, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CONDITIONAL_EXPRESSION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CONDITIONAL_EXPRESSION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_expression(nodecl_get_child(n, 2));
}
static void nodecl_check_REFERENCE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_REFERENCE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_COMMA(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_COMMA, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_THROW(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_THROW, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_VIRTUAL_FUNCTION_CALL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VIRTUAL_FUNCTION_CALL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_argument);
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_function_form);
}
static void nodecl_check_MUL_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_MUL_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_DIV_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_DIV_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_ADD_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ADD_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_MINUS_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_MINUS_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_BITWISE_SHL_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_SHL_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_BITWISE_SHR_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_SHR_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_ARITHMETIC_SHR_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ARITHMETIC_SHR_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_BITWISE_AND_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_AND_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_BITWISE_OR_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_OR_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_BITWISE_XOR_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BITWISE_XOR_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_MOD_ASSIGNMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_MOD_ASSIGNMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_PREINCREMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PREINCREMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_POSTINCREMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_POSTINCREMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_PREDECREMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PREDECREMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_POSTDECREMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_POSTDECREMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_SIZEOF(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_SIZEOF, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_type(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_ALIGNOF(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ALIGNOF, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_type_or_expr(nodecl_get_child(n, 0));
}
static void nodecl_check_OFFSET(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OFFSET, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_TYPEID(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_TYPEID, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_type_or_expr(nodecl_get_child(n, 0));
}
static void nodecl_check_NEW(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_NEW, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_type);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 2), nodecl_check_expression);
nodecl_check_nullable_rule(nodecl_get_child(n, 3), nodecl_check_name);
}
static void nodecl_check_DELETE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_DELETE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_DELETE_ARRAY(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_DELETE_ARRAY, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_POINTER_TO_MEMBER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_POINTER_TO_MEMBER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
}
static void nodecl_check_REAL_PART(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_REAL_PART, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_IMAG_PART(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_IMAG_PART, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OFFSETOF(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OFFSETOF, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_type(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_cxx_dependent_initializer);
}
static void nodecl_check_SHAPING(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_SHAPING, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_PSEUDO_DESTRUCTOR_NAME(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PSEUDO_DESTRUCTOR_NAME, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_VECTOR_CONDITIONAL_EXPRESSION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_CONDITIONAL_EXPRESSION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_expression(nodecl_get_child(n, 2));
}
static void nodecl_check_VLA_WILDCARD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VLA_WILDCARD, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
}
static void nodecl_check_GXX_BUILTIN_ADDRESSOF(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_GXX_BUILTIN_ADDRESSOF, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_GCC_ASM_OPERAND(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_GCC_ASM_OPERAND, "Invalid node", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_text);
nodecl_check_text(nodecl_get_child(n, 1));
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_ASSERT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_ASSERT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_statement);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_analysis_exec_environment);
}
static void nodecl_check_INTEGER_LITERAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_INTEGER_LITERAL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_FLOATING_LITERAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FLOATING_LITERAL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_COMPLEX_LITERAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_COMPLEX_LITERAL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_BOOLEAN_LITERAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_BOOLEAN_LITERAL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_OPEN_M_P_DEP_IN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_DEP_IN, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_DEP_OUT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_DEP_OUT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_DEP_INOUT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_DEP_INOUT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_DEP_CONCURRENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_DEP_CONCURRENT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_DEP_COMMUTATIVE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_DEP_COMMUTATIVE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_DEP_REDUCTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_DEP_REDUCTION, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_DEP_WEAK_REDUCTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_DEP_WEAK_REDUCTION, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_DEP_IN_PRIVATE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_DEP_IN_PRIVATE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_DEP_WEAK_IN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_DEP_WEAK_IN, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_DEP_WEAK_OUT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_DEP_WEAK_OUT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_DEP_WEAK_INOUT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_DEP_WEAK_INOUT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_DEP_WEAK_COMMUTATIVE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_DEP_WEAK_COMMUTATIVE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_TYPE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_TYPE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
}
static void nodecl_check_PRAGMA_CUSTOM_CLAUSE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PRAGMA_CUSTOM_CLAUSE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_pragma_clause_arg);
}
static void nodecl_check_CXX_DECL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DECL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_context);
}
static void nodecl_check_CXX_DEF(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DEF, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_context);
}
static void nodecl_check_CXX_EXPLICIT_INSTANTIATION_DEF(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_EXPLICIT_INSTANTIATION_DEF, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_cxx_dependent_name);
nodecl_check_context(nodecl_get_child(n, 1));
}
static void nodecl_check_CXX_EXPLICIT_INSTANTIATION_DECL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_EXPLICIT_INSTANTIATION_DECL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_cxx_dependent_name);
nodecl_check_context(nodecl_get_child(n, 1));
}
static void nodecl_check_CXX_USING_NAMESPACE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_USING_NAMESPACE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_context(nodecl_get_child(n, 0));
nodecl_check_cxx_dependent_name(nodecl_get_child(n, 1));
}
static void nodecl_check_CXX_USING_DECL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_USING_DECL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_context(nodecl_get_child(n, 0));
nodecl_check_cxx_dependent_name(nodecl_get_child(n, 1));
}
static void nodecl_check_CXX_PARSE_LATER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_PARSE_LATER, "Invalid node", 0);
}
static void nodecl_check_CXX_IMPLICIT_INSTANTIATION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_IMPLICIT_INSTANTIATION, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
}
static void nodecl_check_TEMPLATE_FUNCTION_CODE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_TEMPLATE_FUNCTION_CODE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_context(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_mem_init);
}
static void nodecl_check_VERBATIM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VERBATIM, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
}
static void nodecl_check_FORTRAN_IMPLIED_DO(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_IMPLIED_DO, "Invalid node", 0);
nodecl_check_name(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_list_rule(nodecl_get_child(n, 2), nodecl_check_initializer_item);
}
static void nodecl_check_OMP_SS_ALLOCA(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_ALLOCA, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_SHARED_AND_ALLOCA(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_SHARED_AND_ALLOCA, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_WEAK_REDUCTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_WEAK_REDUCTION, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_reduction_item);
}
static void nodecl_check_OMP_SS_COST(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_COST, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OMP_SS_TASK_LABEL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_TASK_LABEL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
}
static void nodecl_check_TRY_BLOCK(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_TRY_BLOCK, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_statement);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 2), nodecl_check_statement);
}
static void nodecl_check_CXX_FOR_RANGED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_FOR_RANGED, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_CATCH_HANDLER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CATCH_HANDLER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_object_init);
nodecl_check_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_CXX_STATIC_ASSERT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_STATIC_ASSERT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_ALIGNED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_ALIGNED, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_OPEN_M_P_VECTOR_LENGTH(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_VECTOR_LENGTH, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_VECTOR_LENGTH_FOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_VECTOR_LENGTH_FOR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
}
static void nodecl_check_OPEN_M_P_UNIFORM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_UNIFORM, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_LINEAR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_LINEAR, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_OPEN_M_P_SUITABLE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_SUITABLE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_OVERLAP(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_OVERLAP, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_expression(nodecl_get_child(n, 2));
nodecl_check_expression(nodecl_get_child(n, 3));
}
static void nodecl_check_OPEN_M_P_UNROLL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_UNROLL, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_UNROLL_AND_JAM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_UNROLL_AND_JAM, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_NONTEMPORAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_NONTEMPORAL, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_vector_flags);
}
static void nodecl_check_OPEN_M_P_PREFETCH(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_PREFETCH, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_vector_flags(nodecl_get_child(n, 1));
}
static void nodecl_check_OPEN_M_P_NO_PREFETCH(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_NO_PREFETCH, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_MASK(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_MASK, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_NO_MASK(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_NO_MASK, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_SIMD_REDUCTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_SIMD_REDUCTION, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_reduction_item);
}
static void nodecl_check_ANALYSIS_ASSERT_DECL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_ASSERT_DECL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_analysis_exec_environment);
}
static void nodecl_check_CXX_CAPTURE_COPY(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_CAPTURE_COPY, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_CXX_CAPTURE_REFERENCE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_CAPTURE_REFERENCE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_CXX_FUNCTION_FORM_TEMPLATE_ID(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_FUNCTION_FORM_TEMPLATE_ID, "Invalid node", 0);
}
static void nodecl_check_CXX_FUNCTION_FORM_IMPLICIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_FUNCTION_FORM_IMPLICIT, "Invalid node", 0);
}
static void nodecl_check_CXX_FUNCTION_FORM_BINARY_INFIX(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_FUNCTION_FORM_BINARY_INFIX, "Invalid node", 0);
}
static void nodecl_check_CXX_FUNCTION_FORM_UNARY_PREFIX(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_FUNCTION_FORM_UNARY_PREFIX, "Invalid node", 0);
}
static void nodecl_check_CXX_FUNCTION_FORM_UNARY_POSTFIX(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_FUNCTION_FORM_UNARY_POSTFIX, "Invalid node", 0);
}
static void nodecl_check_CXX_FUNCTION_FORM_DEFAULT_INIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_FUNCTION_FORM_DEFAULT_INIT, "Invalid node", 0);
}
static void nodecl_check_CXX_FUNCTION_FORM_DEFAULT_INIT_BRACED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_FUNCTION_FORM_DEFAULT_INIT_BRACED, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_FOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_FOR, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_statement(nodecl_get_child(n, 1));
}
static void nodecl_check_OPEN_M_P_FOR_APPENDIX(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_FOR_APPENDIX, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_statement(nodecl_get_child(n, 1));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 2), nodecl_check_statement);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 3), nodecl_check_statement);
}
static void nodecl_check_ASM_DEFINITION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ASM_DEFINITION, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_text);
}
static void nodecl_check_OPEN_M_P_DECLARE_TARGET(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_DECLARE_TARGET, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_name);
}
static void nodecl_check_OPEN_M_P_TASKLOOP(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TASKLOOP, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_statement(nodecl_get_child(n, 1));
}
static void nodecl_check_OMP_SS_RELEASE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_RELEASE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
}
static void nodecl_check_OPEN_M_P_TASK_IS_TASKWAIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TASK_IS_TASKWAIT, "Invalid node", 0);
}
static void nodecl_check_OMP_SS_TASK_IS_LOOP(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_TASK_IS_LOOP, "Invalid node", 0);
}
static void nodecl_check_OMP_SS_TASK_IS_TASK_CALL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_TASK_IS_TASK_CALL, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_TASK(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TASK, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_ANALYSIS_REACH_DEF_EXPR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_REACH_DEF_EXPR, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_OPEN_M_P_BARRIER_AT_END(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_BARRIER_AT_END, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_DEVICE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_DEVICE, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_MAP_TO(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_MAP_TO, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_MAP_FROM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_MAP_FROM, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_MAP_TO_FROM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_MAP_TO_FROM, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_MAP_ALLOC(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_MAP_ALLOC, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_MOTION_TO(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_MOTION_TO, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_MOTION_FROM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_MOTION_FROM, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_NUM_TEAMS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_NUM_TEAMS, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_THREAD_LIMIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_THREAD_LIMIT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_TARGET_TASK_UNDEFERRED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TARGET_TASK_UNDEFERRED, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_FIRSTPRIVATE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_FIRSTPRIVATE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_name);
}
static void nodecl_check_OPEN_M_P_LASTPRIVATE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_LASTPRIVATE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_name);
}
static void nodecl_check_OPEN_M_P_FIRST_LASTPRIVATE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_FIRST_LASTPRIVATE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_name);
}
static void nodecl_check_OPEN_M_P_SHARED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_SHARED, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_name);
}
static void nodecl_check_OPEN_M_P_THREADPRIVATE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_THREADPRIVATE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_name);
}
static void nodecl_check_OPEN_M_P_PRIVATE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_PRIVATE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_name);
}
static void nodecl_check_OPEN_M_P_AUTO(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_AUTO, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_name);
}
static void nodecl_check_OPEN_M_P_REDUCTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_REDUCTION, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_reduction_item);
}
static void nodecl_check_OPEN_M_P_TASK_REDUCTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TASK_REDUCTION, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_reduction_item);
}
static void nodecl_check_OPEN_M_P_IN_REDUCTION(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_IN_REDUCTION, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_reduction_item);
}
static void nodecl_check_OPEN_M_P_PRIVATE_INIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_PRIVATE_INIT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_FORTRAN_ALLOCATE_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_ALLOCATE_STATEMENT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_fortran_io_spec);
nodecl_check_nullable_rule(nodecl_get_child(n, 2), nodecl_check_type);
}
static void nodecl_check_FORTRAN_ARITHMETIC_IF_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_ARITHMETIC_IF_STATEMENT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_name(nodecl_get_child(n, 1));
nodecl_check_name(nodecl_get_child(n, 2));
nodecl_check_name(nodecl_get_child(n, 3));
}
static void nodecl_check_FORTRAN_ASSIGNED_GOTO_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_ASSIGNED_GOTO_STATEMENT, "Invalid node", 0);
nodecl_check_name(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_name);
}
static void nodecl_check_FORTRAN_OPEN_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_OPEN_STATEMENT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_fortran_io_spec);
}
static void nodecl_check_FORTRAN_CLOSE_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_CLOSE_STATEMENT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_fortran_io_spec);
}
static void nodecl_check_FORTRAN_COMPUTED_GOTO_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_COMPUTED_GOTO_STATEMENT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_name);
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_FORTRAN_ALTERNATE_RETURN_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_ALTERNATE_RETURN_STATEMENT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_FORTRAN_DEALLOCATE_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_DEALLOCATE_STATEMENT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_fortran_io_spec);
}
static void nodecl_check_FORTRAN_IO_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_IO_STATEMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_fortran_io_spec);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_fortran_io_item);
}
static void nodecl_check_FORTRAN_LABEL_ASSIGN_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_LABEL_ASSIGN_STATEMENT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_name(nodecl_get_child(n, 1));
}
static void nodecl_check_FORTRAN_NULLIFY_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_NULLIFY_STATEMENT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_FORTRAN_PRINT_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_PRINT_STATEMENT, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_fortran_io_item);
}
static void nodecl_check_FORTRAN_READ_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_READ_STATEMENT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_fortran_io_spec);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_fortran_io_item);
}
static void nodecl_check_FORTRAN_WRITE_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_WRITE_STATEMENT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_fortran_io_spec);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_fortran_io_item);
}
static void nodecl_check_FORTRAN_STOP_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_STOP_STATEMENT, "Invalid node", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_FORTRAN_PAUSE_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_PAUSE_STATEMENT, "Invalid node", 0);
nodecl_check_nullable_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_FORTRAN_ENTRY_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_ENTRY_STATEMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, "Tree lacks a symbol", 0);
}
static void nodecl_check_FORTRAN_WHERE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_WHERE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_where_pair);
}
static void nodecl_check_FORTRAN_FORALL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FORTRAN_FORALL, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_loop_control);
nodecl_check_nullable_rule(nodecl_get_child(n, 1), nodecl_check_expression);
nodecl_check_list_rule(nodecl_get_child(n, 2), nodecl_check_statement);
}
static void nodecl_check_OPEN_M_P_TARGET_DATA(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TARGET_DATA, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_OPEN_M_P_TARGET(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TARGET, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_OPEN_M_P_TARGET_UPDATE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TARGET_UPDATE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
}
static void nodecl_check_OPEN_M_P_TEAMS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_TEAMS, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_statement);
}
static void nodecl_check_OPEN_M_P_DISTRIBUTE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_DISTRIBUTE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_omp_exec_environment);
nodecl_check_statement(nodecl_get_child(n, 1));
}
static void nodecl_check_MASK_LITERAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_MASK_LITERAL, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
   ERROR_CONDITION(nodecl_get_constant(n) == NULL, "Tree lacks a constant value", 0);
}
static void nodecl_check_CHECKPOINT_STORE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CHECKPOINT_STORE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_checkpoint_environment);
}
static void nodecl_check_CHECKPOINT_LOAD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CHECKPOINT_LOAD, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_checkpoint_environment);
}
static void nodecl_check_CHECKPOINT_INIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CHECKPOINT_INIT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_checkpoint_environment);
}
static void nodecl_check_CHECKPOINT_SHUTDOWN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CHECKPOINT_SHUTDOWN, "Invalid node", 0);
}
static void nodecl_check_CHECKPOINT_DATA(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CHECKPOINT_DATA, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_CHECKPOINT_LEVEL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CHECKPOINT_LEVEL, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CHECKPOINT_ID(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CHECKPOINT_ID, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CHECKPOINT_COMM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CHECKPOINT_COMM, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CHECKPOINT_IF(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CHECKPOINT_IF, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CHECKPOINT_KIND(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CHECKPOINT_KIND, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_SOURCE_COMMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_SOURCE_COMMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
}
static void nodecl_check_OMP_SS_TARGET(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_TARGET, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_text);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 1), nodecl_check_ompss_device_info_clauses);
}
static void nodecl_check_RANGE_LOOP_CONTROL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_RANGE_LOOP_CONTROL, "Invalid node", 0);
nodecl_check_name(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
nodecl_check_expression(nodecl_get_child(n, 2));
nodecl_check_nullable_rule(nodecl_get_child(n, 3), nodecl_check_expression);
}
static void nodecl_check_ITERATOR_LOOP_CONTROL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ITERATOR_LOOP_CONTROL, "Invalid node", 0);
nodecl_check_name(nodecl_get_child(n, 0));
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_OPEN_M_P_CRITICAL_NAME(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_CRITICAL_NAME, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
}
static void nodecl_check_CXX_DEP_NAME_SIMPLE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DEP_NAME_SIMPLE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
}
static void nodecl_check_ANALYSIS_UPPER_EXPOSED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_UPPER_EXPOSED, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_DEFINED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_DEFINED, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_UNDEFINED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_UNDEFINED, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_LIVE_IN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_LIVE_IN, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_LIVE_OUT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_LIVE_OUT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_DEAD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_DEAD, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_REACHING_DEFINITION_IN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_REACHING_DEFINITION_IN, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_reach_def_expression);
}
static void nodecl_check_ANALYSIS_REACHING_DEFINITION_OUT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_REACHING_DEFINITION_OUT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_reach_def_expression);
}
static void nodecl_check_ANALYSIS_INDUCTION_VARIABLE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_INDUCTION_VARIABLE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_induction_var_expression);
}
static void nodecl_check_ANALYSIS_AUTO_SCOPE_FIRSTPRIVATE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_AUTO_SCOPE_FIRSTPRIVATE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_AUTO_SCOPE_PRIVATE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_AUTO_SCOPE_PRIVATE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_AUTO_SCOPE_SHARED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_AUTO_SCOPE_SHARED, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_RANGE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_RANGE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_induction_var_expression);
}
static void nodecl_check_ANALYSIS_CORRECTNESS_AUTO_STORAGE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_CORRECTNESS_AUTO_STORAGE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_CORRECTNESS_DEAD(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_CORRECTNESS_DEAD, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_FP(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_FP, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_P(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_P, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_IN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_IN, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_OUT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_OUT, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_IN_POINTED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_IN_POINTED, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_OUT_POINTED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_OUT_POINTED, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_ANALYSIS_CORRECTNESS_RACE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_ANALYSIS_CORRECTNESS_RACE, "Invalid node", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_VECTOR_FUNCTION_CODE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_VECTOR_FUNCTION_CODE, "Invalid node", 0);
nodecl_check_regular_function_code(nodecl_get_child(n, 0));
}
static void nodecl_check_UPC_SYNC_STATEMENT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_UPC_SYNC_STATEMENT, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_DEP_GLOBAL_NAME_NESTED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DEP_GLOBAL_NAME_NESTED, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_cxx_atom_dependent_name);
}
static void nodecl_check_CXX_DEP_NAME_NESTED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_DEP_NAME_NESTED, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_cxx_atom_dependent_name);
}
static void nodecl_check_UNKNOWN_PRAGMA(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_UNKNOWN_PRAGMA, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
}
static void nodecl_check_FIELD_DESIGNATOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_FIELD_DESIGNATOR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_name(nodecl_get_child(n, 0));
nodecl_check_initializer_item(nodecl_get_child(n, 1));
}
static void nodecl_check_INDEX_DESIGNATOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_INDEX_DESIGNATOR, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
nodecl_check_initializer_item(nodecl_get_child(n, 1));
}
static void nodecl_check_PREPROCESSOR_LINE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_PREPROCESSOR_LINE, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_text(n) == NULL, "Tree lacks an associated text", 0);
}
static void nodecl_check_CXX_INITIALIZER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_INITIALIZER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_BRACED_INITIALIZER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_BRACED_INITIALIZER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_CXX_EQUAL_INITIALIZER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_EQUAL_INITIALIZER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_PARENTHESIZED_INITIALIZER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_PARENTHESIZED_INITIALIZER, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_C99_DESIGNATED_INITIALIZER(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_C99_DESIGNATED_INITIALIZER, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_cxx_dependent_initializer);
nodecl_check_expression(nodecl_get_child(n, 1));
}
static void nodecl_check_C99_FIELD_DESIGNATOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_C99_FIELD_DESIGNATOR, "Invalid node", 0);
nodecl_check_cxx_simple_name(nodecl_get_child(n, 0));
}
static void nodecl_check_C99_INDEX_DESIGNATOR(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_C99_INDEX_DESIGNATOR, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_VALUE_PACK(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_VALUE_PACK, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_CXX_VALUE_PACK_EXPANDED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_CXX_VALUE_PACK_EXPANDED, "Invalid node", 0);
   ERROR_CONDITION(nodecl_get_type(n) == NULL, "Tree lacks a type", 0);
nodecl_check_nullable_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OPEN_M_P_IF(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_IF, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_FINAL(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_FINAL, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_PRIORITY(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_PRIORITY, "Invalid node", 0);
nodecl_check_expression(nodecl_get_child(n, 0));
}
static void nodecl_check_OPEN_M_P_MERGEABLE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_MERGEABLE, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_UNTIED(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_UNTIED, "Invalid node", 0);
}
static void nodecl_check_OMP_SS_WAIT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_WAIT, "Invalid node", 0);
}
static void nodecl_check_OPEN_M_P_REDUCTION_ITEM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OPEN_M_P_REDUCTION_ITEM, "Invalid node", 0);
nodecl_check_name(nodecl_get_child(n, 0));
nodecl_check_name(nodecl_get_child(n, 1));
nodecl_check_type(nodecl_get_child(n, 2));
}
static void nodecl_check_OMP_SS_COPY_IN(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_COPY_IN, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_COPY_OUT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_COPY_OUT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_COPY_INOUT(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_COPY_INOUT, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_N_D_RANGE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_N_D_RANGE, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_SH_MEM(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_SH_MEM, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_FILE(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_FILE, "Invalid node", 0);
nodecl_check_text(nodecl_get_child(n, 0));
}
static void nodecl_check_OMP_SS_NAME(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_NAME, "Invalid node", 0);
nodecl_check_text(nodecl_get_child(n, 0));
}
static void nodecl_check_OMP_SS_ONTO(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_ONTO, "Invalid node", 0);
nodecl_check_list_rule(nodecl_get_child(n, 0), nodecl_check_expression);
}
static void nodecl_check_OMP_SS_IMPLEMENTS(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
ERROR_CONDITION(nodecl_get_kind(n) != NODECL_OMP_SS_IMPLEMENTS, "Invalid node", 0);
nodecl_check_text(nodecl_get_child(n, 0));
nodecl_check_name(nodecl_get_child(n, 1));
}
static void nodecl_check_structured_value_form(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_STRUCTURED_VALUE_PARENTHESIZED:
{
nodecl_check_STRUCTURED_VALUE_PARENTHESIZED(n);
break;
}
case NODECL_STRUCTURED_VALUE_BRACED_TYPECAST:
{
nodecl_check_STRUCTURED_VALUE_BRACED_TYPECAST(n);
break;
}
case NODECL_STRUCTURED_VALUE_BRACED_IMPLICIT:
{
nodecl_check_STRUCTURED_VALUE_BRACED_IMPLICIT(n);
break;
}
case NODECL_STRUCTURED_VALUE_COMPOUND_LITERAL:
{
nodecl_check_STRUCTURED_VALUE_COMPOUND_LITERAL(n);
break;
}
case NODECL_STRUCTURED_VALUE_FORTRAN_TYPESPEC_ARRAY_CONSTRUCTOR:
{
nodecl_check_STRUCTURED_VALUE_FORTRAN_TYPESPEC_ARRAY_CONSTRUCTOR(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_cxx_atom_dependent_name(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_DEP_NAME_SIMPLE:
{
nodecl_check_cxx_simple_name(n);
break;
}
case NODECL_CXX_DEP_TEMPLATE_ID:
{
nodecl_check_CXX_DEP_TEMPLATE_ID(n);
break;
}
case NODECL_CXX_DEP_NAME_CONVERSION:
{
nodecl_check_CXX_DEP_NAME_CONVERSION(n);
break;
}
case NODECL_CXX_DEP_DECLTYPE:
{
nodecl_check_CXX_DEP_DECLTYPE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_text(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_TEXT:
{
nodecl_check_TEXT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_cuda_expressions(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CUDA_KERNEL_CALL:
{
nodecl_check_CUDA_KERNEL_CALL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_pragma_directive(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_PRAGMA_CUSTOM_DIRECTIVE:
{
nodecl_check_PRAGMA_CUSTOM_DIRECTIVE(n);
break;
}
case NODECL_PRAGMA_CUSTOM_DECLARATION:
{
nodecl_check_pragma_declaration(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_pragma_context(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_PRAGMA_CONTEXT:
{
nodecl_check_PRAGMA_CONTEXT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_range_expression(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_RANGE:
{
nodecl_check_RANGE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_sections_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_SECTIONS:
{
nodecl_check_OPEN_M_P_SECTIONS(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_fortran_data_item(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ARRAY_SUBSCRIPT:
case NODECL_DELETE:
case NODECL_C99_FIELD_DESIGNATOR:
case NODECL_SYMBOL:
case NODECL_VECTOR_BITWISE_XOR:
case NODECL_VECTOR_SUBSCRIPT:
case NODECL_PREPROCESSOR_LINE:
case NODECL_FUNCTION_CALL:
case NODECL_LOGICAL_AND:
case NODECL_CXX_EQUAL_INITIALIZER:
case NODECL_OMP_SS_TASK_EXPRESSION:
case NODECL_CXX_INITIALIZER:
case NODECL_VECTOR_CONDITIONAL_EXPRESSION:
case NODECL_IMAG_PART:
case NODECL_VECTOR_FMADD:
case NODECL_ANALYSIS_MAXIMUM:
case NODECL_SHAPING:
case NODECL_THROW:
case NODECL_DUMMY:
case NODECL_VECTOR_LOWER_OR_EQUAL_THAN:
case NODECL_VECTOR_CONVERSION:
case NODECL_INTEL_ASSUME:
case NODECL_CXX_CAST:
case NODECL_ANALYSIS_RANGE_INTERSECTION:
case NODECL_CXX_DEP_NAME_NESTED:
case NODECL_NEG:
case NODECL_VECTOR_ARITHMETIC_SHR:
case NODECL_CXX_CLASS_MEMBER_ACCESS:
case NODECL_CXX_LAMBDA:
case NODECL_OFFSETOF:
case NODECL_NEW:
case NODECL_VECTOR_MASK_OR:
case NODECL_FORTRAN_BIND_C:
case NODECL_GXX_TRAIT:
case NODECL_VECTOR_SCATTER:
case NODECL_MOD_ASSIGNMENT:
case NODECL_DIFFERENT:
case NODECL_VECTOR_MASK_AND:
case NODECL_CXX_ALIGNOF:
case NODECL_LOWER_OR_EQUAL_THAN:
case NODECL_SIZEOF:
case NODECL_COMPOUND_EXPRESSION:
case NODECL_VECTOR_STORE:
case NODECL_ADD_ASSIGNMENT:
case NODECL_VECTOR_GATHER:
case NODECL_LOWER_THAN:
case NODECL_VECTOR_SINCOS:
case NODECL_BITWISE_AND:
case NODECL_LOGICAL_OR:
case NODECL_FORTRAN_BOZ_LITERAL:
case NODECL_COMPLEX_LITERAL:
case NODECL_BITWISE_XOR:
case NODECL_BITWISE_NOT:
case NODECL_MINUS:
case NODECL_MINUS_ASSIGNMENT:
case NODECL_VECTOR_LANE_ID:
case NODECL_BOOLEAN_LITERAL:
case NODECL_POWER:
case NODECL_FORTRAN_USE:
case NODECL_EQUAL:
case NODECL_CONDITIONAL_EXPRESSION:
case NODECL_CONCAT:
case NODECL_VECTOR_LOGICAL_AND:
case NODECL_CLASS_MEMBER_ACCESS:
case NODECL_REFERENCE:
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_VECTOR_FABS:
case NODECL_FORTRAN_HOLLERITH:
case NODECL_VLA_WILDCARD:
case NODECL_PREINCREMENT:
case NODECL_TYPEID:
case NODECL_ANALYSIS_PLUS_INFINITY:
case NODECL_OFFSET:
case NODECL_CXX_SIZEOF_PACK:
case NODECL_UNKNOWN:
case NODECL_ANALYSIS_RANGE_UNION:
case NODECL_ARITHMETIC_SHR:
case NODECL_CXX_VALUE_PACK_EXPANDED:
case NODECL_VECTOR_EQUAL:
case NODECL_ADD:
case NODECL_ANALYSIS_MINUS_INFINITY:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_C99_DESIGNATED_INITIALIZER:
case NODECL_POSTINCREMENT:
case NODECL_VECTOR_MINUS:
case NODECL_VECTOR_BITWISE_NOT:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_STRING_LITERAL:
case NODECL_VECTOR_MASK_NOT:
case NODECL_BITWISE_OR:
case NODECL_CXX_POSTFIX_INITIALIZER:
case NODECL_TEXT:
case NODECL_CXX_DEP_DECLTYPE:
case NODECL_MUL:
case NODECL_VECTOR_LOAD:
case NODECL_CXX_SIZEOF:
case NODECL_VECTOR_PROMOTION:
case NODECL_VECTOR_GREATER_THAN:
case NODECL_GREATER_THAN:
case NODECL_BITWISE_XOR_ASSIGNMENT:
case NODECL_VECTOR_BITWISE_SHR:
case NODECL_BITWISE_SHL_ASSIGNMENT:
case NODECL_C99_INDEX_DESIGNATOR:
case NODECL_VECTOR_BITWISE_OR:
case NODECL_POSTDECREMENT:
case NODECL_CONTEXT:
case NODECL_VECTOR_BITWISE_SHL:
case NODECL_OMP_SS_TASK_CALL:
case NODECL_VECTOR_CAST:
case NODECL_DELETE_ARRAY:
case NODECL_ANALYSIS_EMPTY_RANGE:
case NODECL_ANALYSIS_PHI:
case NODECL_CXX_ALIGNAS:
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
case NODECL_VIRTUAL_FUNCTION_CALL:
case NODECL_VECTOR_BITWISE_AND:
case NODECL_MASK_LITERAL:
case NODECL_VECTOR_DIV:
case NODECL_BITWISE_OR_ASSIGNMENT:
case NODECL_VECTOR_RCP:
case NODECL_CXX_VALUE_PACK:
case NODECL_VECTOR_MASK_XOR:
case NODECL_VECTOR_MASK_ASSIGNMENT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_VECTOR_FMMINUS:
case NODECL_GREATER_OR_EQUAL_THAN:
case NODECL_VECTOR_GREATER_OR_EQUAL_THAN:
case NODECL_POINTER_TO_MEMBER:
case NODECL_VECTOR_MASK_CONVERSION:
case NODECL_VECTOR_LOOP:
case NODECL_VECTOR_ASSIGNMENT:
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
case NODECL_VECTOR_MOD:
case NODECL_VECTOR_REDUCTION_ADD:
case NODECL_BITWISE_SHR:
case NODECL_VECTOR_ADD:
case NODECL_FLOATING_LITERAL:
case NODECL_GCC_ASM_SPEC:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_VECTOR_LOGICAL_OR:
case NODECL_OBJECT_INIT:
case NODECL_VECTOR_ALIGN_RIGHT:
case NODECL_VECTOR_NEG:
case NODECL_BITWISE_SHL:
case NODECL_ASSIGNMENT:
case NODECL_MUL_ASSIGNMENT:
case NODECL_VECTOR_DIFFERENT:
case NODECL_BITWISE_SHR_ASSIGNMENT:
case NODECL_VECTOR_RSQRT:
case NODECL_FORTRAN_EQUIVALENCE:
case NODECL_VECTOR_MUL:
case NODECL_CUDA_KERNEL_CALL:
case NODECL_VECTOR_LOGICAL_NOT:
case NODECL_CXX_EXPLICIT_TYPE_CAST:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_RANGE:
case NODECL_ANALYSIS_MINIMUM:
case NODECL_VERBATIM:
case NODECL_DEREFERENCE:
case NODECL_DIV:
case NODECL_CXX_ARROW_PTR_MEMBER:
case NODECL_VECTOR_REDUCTION_MINUS:
case NODECL_VECTOR_SQRT:
case NODECL_DIV_ASSIGNMENT:
case NODECL_CXX_BRACED_INITIALIZER:
case NODECL_MOD:
case NODECL_VECTOR_REDUCTION_MUL:
case NODECL_PSEUDO_DESTRUCTOR_NAME:
case NODECL_CXX_DEP_NEW:
case NODECL_VECTOR_MASK_AND_2_NOT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_VECTOR_FUNCTION_CALL:
case NODECL_ERR_EXPR:
case NODECL_NOEXCEPT_IMPLICIT_TRUE:
case NODECL_SOURCE_COMMENT:
case NODECL_FORTRAN_USE_ONLY:
case NODECL_ASM_DEFINITION:
case NODECL_VECTOR_LITERAL:
case NODECL_ALIGNOF:
case NODECL_GXX_BUILTIN_ADDRESSOF:
case NODECL_MULTI_EXPRESSION:
case NODECL_CXX_DOT_PTR_MEMBER:
case NODECL_VECTOR_LOWER_THAN:
case NODECL_PARENTHESIZED_EXPRESSION:
case NODECL_CONVERSION:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_ANALYSIS_RANGE_SUB:
case NODECL_ARITHMETIC_SHR_ASSIGNMENT:
case NODECL_INTEGER_LITERAL:
case NODECL_LOGICAL_NOT:
case NODECL_STRUCTURED_VALUE:
case NODECL_FORTRAN_DATA:
case NODECL_CXX_DEP_FUNCTION_CALL:
case NODECL_CXX_NOEXCEPT:
case NODECL_PREDECREMENT:
case NODECL_VECTOR_PREFETCH:
case NODECL_COMMA:
case NODECL_REAL_PART:
case NODECL_VECTOR_MASK_AND_1_NOT:
case NODECL_PLUS:
case NODECL_BITWISE_AND_ASSIGNMENT:
case NODECL_CXX_ARROW:
{
nodecl_check_expression(n);
break;
}
case NODECL_FORTRAN_IMPLIED_DO:
{
nodecl_check_fortran_implied_do(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_master_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_MASTER:
{
nodecl_check_OPEN_M_P_MASTER(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_pragma_line(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_PRAGMA_CUSTOM_LINE:
{
nodecl_check_PRAGMA_CUSTOM_LINE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_gcc_builtin_va_arg(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_GCC_BUILTIN_VA_ARG:
{
nodecl_check_GCC_BUILTIN_VA_ARG(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_critical_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_CRITICAL:
{
nodecl_check_OPEN_M_P_CRITICAL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_pragma_statement(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_PRAGMA_CUSTOM_STATEMENT:
{
nodecl_check_PRAGMA_CUSTOM_STATEMENT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_oss_specific_constructs(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OMP_SS_LOOP:
{
nodecl_check_OMP_SS_LOOP(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_nodecl(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_TOP_LEVEL:
{
nodecl_check_TOP_LEVEL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_intel_expressions(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_INTEL_ASSUME_ALIGNED:
{
nodecl_check_INTEL_ASSUME_ALIGNED(n);
break;
}
case NODECL_INTEL_ASSUME:
{
nodecl_check_INTEL_ASSUME(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_data_coordination_constructs(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OMP_SS_REGISTER:
{
nodecl_check_OMP_SS_REGISTER(n);
break;
}
case NODECL_OMP_SS_UNREGISTER:
{
nodecl_check_OMP_SS_UNREGISTER(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_simd_for_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_SIMD_FOR:
{
nodecl_check_OPEN_M_P_SIMD_FOR(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_constraint_expression(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ANALYSIS_PHI:
{
nodecl_check_ANALYSIS_PHI(n);
break;
}
case NODECL_ANALYSIS_RANGE_UNION:
{
nodecl_check_ANALYSIS_RANGE_UNION(n);
break;
}
case NODECL_ANALYSIS_RANGE_INTERSECTION:
{
nodecl_check_ANALYSIS_RANGE_INTERSECTION(n);
break;
}
case NODECL_ANALYSIS_RANGE_SUB:
{
nodecl_check_ANALYSIS_RANGE_SUB(n);
break;
}
case NODECL_ANALYSIS_EMPTY_RANGE:
{
nodecl_check_ANALYSIS_EMPTY_RANGE(n);
break;
}
case NODECL_ANALYSIS_MINUS_INFINITY:
{
nodecl_check_ANALYSIS_MINUS_INFINITY(n);
break;
}
case NODECL_ANALYSIS_PLUS_INFINITY:
{
nodecl_check_ANALYSIS_PLUS_INFINITY(n);
break;
}
case NODECL_ANALYSIS_MINIMUM:
{
nodecl_check_ANALYSIS_MINIMUM(n);
break;
}
case NODECL_ANALYSIS_MAXIMUM:
{
nodecl_check_ANALYSIS_MAXIMUM(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_string_literal(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_STRING_LITERAL:
{
nodecl_check_STRING_LITERAL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_loop_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_SCHEDULE:
{
nodecl_check_OPEN_M_P_SCHEDULE(n);
break;
}
case NODECL_OPEN_M_P_DIST_SCHEDULE:
{
nodecl_check_OPEN_M_P_DIST_SCHEDULE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_target_declaration(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OMP_SS_TARGET_DECLARATION:
{
nodecl_check_OMP_SS_TARGET_DECLARATION(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_gcc_asm_definition(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_GCC_ASM_DEFINITION:
{
nodecl_check_GCC_ASM_DEFINITION(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_synchronization(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_TASKWAIT:
{
nodecl_check_OPEN_M_P_TASKWAIT(n);
break;
}
case NODECL_OPEN_M_P_TASKGROUP:
{
nodecl_check_OPEN_M_P_TASKGROUP(n);
break;
}
case NODECL_OPEN_M_P_FLUSH_MEMORY:
{
nodecl_check_OPEN_M_P_FLUSH_MEMORY(n);
break;
}
case NODECL_OPEN_M_P_BARRIER_FULL:
{
nodecl_check_OPEN_M_P_BARRIER_FULL(n);
break;
}
case NODECL_OPEN_M_P_BARRIER_SIGNAL:
{
nodecl_check_OPEN_M_P_BARRIER_SIGNAL(n);
break;
}
case NODECL_OPEN_M_P_BARRIER_WAIT:
{
nodecl_check_OPEN_M_P_BARRIER_WAIT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_parallel_simd_for_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_PARALLEL_SIMD_FOR:
{
nodecl_check_OPEN_M_P_PARALLEL_SIMD_FOR(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_pragma_declaration(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_PRAGMA_CUSTOM_DECLARATION:
{
nodecl_check_PRAGMA_CUSTOM_DECLARATION(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_loop_control(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_LOOP_CONTROL:
{
nodecl_check_LOOP_CONTROL(n);
break;
}
case NODECL_ITERATOR_LOOP_CONTROL:
case NODECL_RANGE_LOOP_CONTROL:
{
nodecl_check_range_loop_control(n);
break;
}
case NODECL_UNBOUNDED_LOOP_CONTROL:
{
nodecl_check_UNBOUNDED_LOOP_CONTROL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_name(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_SYMBOL:
{
nodecl_check_SYMBOL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_fortran_io_spec(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FORTRAN_IO_SPEC:
{
nodecl_check_FORTRAN_IO_SPEC(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_single_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_SINGLE:
{
nodecl_check_OPEN_M_P_SINGLE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_vector_flags(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ALIGNED_FLAG:
{
nodecl_check_ALIGNED_FLAG(n);
break;
}
case NODECL_ALIGNMENT_INFO:
{
nodecl_check_ALIGNMENT_INFO(n);
break;
}
case NODECL_IN_PLACE_FLAG:
{
nodecl_check_IN_PLACE_FLAG(n);
break;
}
case NODECL_ON_TOP_FLAG:
{
nodecl_check_ON_TOP_FLAG(n);
break;
}
case NODECL_EVICT_FLAG:
{
nodecl_check_EVICT_FLAG(n);
break;
}
case NODECL_RELAXED_FLAG:
{
nodecl_check_RELAXED_FLAG(n);
break;
}
case NODECL_NONTEMPORAL_FLAG:
{
nodecl_check_NONTEMPORAL_FLAG(n);
break;
}
case NODECL_HAS_BEEN_DEFINED_FLAG:
{
nodecl_check_HAS_BEEN_DEFINED_FLAG(n);
break;
}
case NODECL_ARRAY_SUBSCRIPT:
case NODECL_DELETE:
case NODECL_C99_FIELD_DESIGNATOR:
case NODECL_SYMBOL:
case NODECL_VECTOR_BITWISE_XOR:
case NODECL_VECTOR_SUBSCRIPT:
case NODECL_PREPROCESSOR_LINE:
case NODECL_FUNCTION_CALL:
case NODECL_LOGICAL_AND:
case NODECL_CXX_EQUAL_INITIALIZER:
case NODECL_OMP_SS_TASK_EXPRESSION:
case NODECL_CXX_INITIALIZER:
case NODECL_VECTOR_CONDITIONAL_EXPRESSION:
case NODECL_IMAG_PART:
case NODECL_VECTOR_FMADD:
case NODECL_ANALYSIS_MAXIMUM:
case NODECL_SHAPING:
case NODECL_THROW:
case NODECL_DUMMY:
case NODECL_VECTOR_LOWER_OR_EQUAL_THAN:
case NODECL_VECTOR_CONVERSION:
case NODECL_INTEL_ASSUME:
case NODECL_CXX_CAST:
case NODECL_ANALYSIS_RANGE_INTERSECTION:
case NODECL_CXX_DEP_NAME_NESTED:
case NODECL_NEG:
case NODECL_VECTOR_ARITHMETIC_SHR:
case NODECL_CXX_CLASS_MEMBER_ACCESS:
case NODECL_CXX_LAMBDA:
case NODECL_OFFSETOF:
case NODECL_NEW:
case NODECL_VECTOR_MASK_OR:
case NODECL_FORTRAN_BIND_C:
case NODECL_GXX_TRAIT:
case NODECL_VECTOR_SCATTER:
case NODECL_MOD_ASSIGNMENT:
case NODECL_DIFFERENT:
case NODECL_VECTOR_MASK_AND:
case NODECL_CXX_ALIGNOF:
case NODECL_LOWER_OR_EQUAL_THAN:
case NODECL_SIZEOF:
case NODECL_COMPOUND_EXPRESSION:
case NODECL_VECTOR_STORE:
case NODECL_ADD_ASSIGNMENT:
case NODECL_VECTOR_GATHER:
case NODECL_LOWER_THAN:
case NODECL_VECTOR_SINCOS:
case NODECL_BITWISE_AND:
case NODECL_LOGICAL_OR:
case NODECL_FORTRAN_BOZ_LITERAL:
case NODECL_COMPLEX_LITERAL:
case NODECL_BITWISE_XOR:
case NODECL_BITWISE_NOT:
case NODECL_MINUS:
case NODECL_MINUS_ASSIGNMENT:
case NODECL_VECTOR_LANE_ID:
case NODECL_BOOLEAN_LITERAL:
case NODECL_POWER:
case NODECL_FORTRAN_USE:
case NODECL_EQUAL:
case NODECL_CONDITIONAL_EXPRESSION:
case NODECL_CONCAT:
case NODECL_VECTOR_LOGICAL_AND:
case NODECL_CLASS_MEMBER_ACCESS:
case NODECL_REFERENCE:
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_VECTOR_FABS:
case NODECL_FORTRAN_HOLLERITH:
case NODECL_VLA_WILDCARD:
case NODECL_PREINCREMENT:
case NODECL_TYPEID:
case NODECL_ANALYSIS_PLUS_INFINITY:
case NODECL_OFFSET:
case NODECL_CXX_SIZEOF_PACK:
case NODECL_UNKNOWN:
case NODECL_ANALYSIS_RANGE_UNION:
case NODECL_ARITHMETIC_SHR:
case NODECL_CXX_VALUE_PACK_EXPANDED:
case NODECL_VECTOR_EQUAL:
case NODECL_ADD:
case NODECL_ANALYSIS_MINUS_INFINITY:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_C99_DESIGNATED_INITIALIZER:
case NODECL_POSTINCREMENT:
case NODECL_VECTOR_MINUS:
case NODECL_VECTOR_BITWISE_NOT:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_STRING_LITERAL:
case NODECL_VECTOR_MASK_NOT:
case NODECL_BITWISE_OR:
case NODECL_CXX_POSTFIX_INITIALIZER:
case NODECL_TEXT:
case NODECL_CXX_DEP_DECLTYPE:
case NODECL_MUL:
case NODECL_VECTOR_LOAD:
case NODECL_CXX_SIZEOF:
case NODECL_VECTOR_PROMOTION:
case NODECL_VECTOR_GREATER_THAN:
case NODECL_GREATER_THAN:
case NODECL_BITWISE_XOR_ASSIGNMENT:
case NODECL_VECTOR_BITWISE_SHR:
case NODECL_BITWISE_SHL_ASSIGNMENT:
case NODECL_C99_INDEX_DESIGNATOR:
case NODECL_VECTOR_BITWISE_OR:
case NODECL_POSTDECREMENT:
case NODECL_CONTEXT:
case NODECL_VECTOR_BITWISE_SHL:
case NODECL_OMP_SS_TASK_CALL:
case NODECL_VECTOR_CAST:
case NODECL_DELETE_ARRAY:
case NODECL_ANALYSIS_EMPTY_RANGE:
case NODECL_ANALYSIS_PHI:
case NODECL_CXX_ALIGNAS:
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
case NODECL_VIRTUAL_FUNCTION_CALL:
case NODECL_VECTOR_BITWISE_AND:
case NODECL_MASK_LITERAL:
case NODECL_VECTOR_DIV:
case NODECL_BITWISE_OR_ASSIGNMENT:
case NODECL_VECTOR_RCP:
case NODECL_CXX_VALUE_PACK:
case NODECL_VECTOR_MASK_XOR:
case NODECL_VECTOR_MASK_ASSIGNMENT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_VECTOR_FMMINUS:
case NODECL_GREATER_OR_EQUAL_THAN:
case NODECL_VECTOR_GREATER_OR_EQUAL_THAN:
case NODECL_POINTER_TO_MEMBER:
case NODECL_VECTOR_MASK_CONVERSION:
case NODECL_VECTOR_LOOP:
case NODECL_VECTOR_ASSIGNMENT:
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
case NODECL_VECTOR_MOD:
case NODECL_VECTOR_REDUCTION_ADD:
case NODECL_BITWISE_SHR:
case NODECL_VECTOR_ADD:
case NODECL_FLOATING_LITERAL:
case NODECL_GCC_ASM_SPEC:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_VECTOR_LOGICAL_OR:
case NODECL_OBJECT_INIT:
case NODECL_VECTOR_ALIGN_RIGHT:
case NODECL_VECTOR_NEG:
case NODECL_BITWISE_SHL:
case NODECL_ASSIGNMENT:
case NODECL_MUL_ASSIGNMENT:
case NODECL_VECTOR_DIFFERENT:
case NODECL_BITWISE_SHR_ASSIGNMENT:
case NODECL_VECTOR_RSQRT:
case NODECL_FORTRAN_EQUIVALENCE:
case NODECL_VECTOR_MUL:
case NODECL_CUDA_KERNEL_CALL:
case NODECL_VECTOR_LOGICAL_NOT:
case NODECL_CXX_EXPLICIT_TYPE_CAST:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_RANGE:
case NODECL_ANALYSIS_MINIMUM:
case NODECL_VERBATIM:
case NODECL_DEREFERENCE:
case NODECL_DIV:
case NODECL_CXX_ARROW_PTR_MEMBER:
case NODECL_VECTOR_REDUCTION_MINUS:
case NODECL_VECTOR_SQRT:
case NODECL_DIV_ASSIGNMENT:
case NODECL_CXX_BRACED_INITIALIZER:
case NODECL_MOD:
case NODECL_VECTOR_REDUCTION_MUL:
case NODECL_PSEUDO_DESTRUCTOR_NAME:
case NODECL_CXX_DEP_NEW:
case NODECL_VECTOR_MASK_AND_2_NOT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_VECTOR_FUNCTION_CALL:
case NODECL_ERR_EXPR:
case NODECL_NOEXCEPT_IMPLICIT_TRUE:
case NODECL_SOURCE_COMMENT:
case NODECL_FORTRAN_USE_ONLY:
case NODECL_ASM_DEFINITION:
case NODECL_VECTOR_LITERAL:
case NODECL_ALIGNOF:
case NODECL_GXX_BUILTIN_ADDRESSOF:
case NODECL_MULTI_EXPRESSION:
case NODECL_CXX_DOT_PTR_MEMBER:
case NODECL_VECTOR_LOWER_THAN:
case NODECL_PARENTHESIZED_EXPRESSION:
case NODECL_CONVERSION:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_ANALYSIS_RANGE_SUB:
case NODECL_ARITHMETIC_SHR_ASSIGNMENT:
case NODECL_INTEGER_LITERAL:
case NODECL_LOGICAL_NOT:
case NODECL_STRUCTURED_VALUE:
case NODECL_FORTRAN_DATA:
case NODECL_CXX_DEP_FUNCTION_CALL:
case NODECL_CXX_NOEXCEPT:
case NODECL_PREDECREMENT:
case NODECL_VECTOR_PREFETCH:
case NODECL_COMMA:
case NODECL_REAL_PART:
case NODECL_VECTOR_MASK_AND_1_NOT:
case NODECL_PLUS:
case NODECL_BITWISE_AND_ASSIGNMENT:
case NODECL_CXX_ARROW:
{
nodecl_check_expression(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_regular_function_code(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FUNCTION_CODE:
{
nodecl_check_FUNCTION_CODE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_fortran_io_item(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ARRAY_SUBSCRIPT:
case NODECL_DELETE:
case NODECL_C99_FIELD_DESIGNATOR:
case NODECL_SYMBOL:
case NODECL_VECTOR_BITWISE_XOR:
case NODECL_VECTOR_SUBSCRIPT:
case NODECL_PREPROCESSOR_LINE:
case NODECL_FUNCTION_CALL:
case NODECL_LOGICAL_AND:
case NODECL_CXX_EQUAL_INITIALIZER:
case NODECL_OMP_SS_TASK_EXPRESSION:
case NODECL_CXX_INITIALIZER:
case NODECL_VECTOR_CONDITIONAL_EXPRESSION:
case NODECL_IMAG_PART:
case NODECL_VECTOR_FMADD:
case NODECL_ANALYSIS_MAXIMUM:
case NODECL_SHAPING:
case NODECL_THROW:
case NODECL_DUMMY:
case NODECL_VECTOR_LOWER_OR_EQUAL_THAN:
case NODECL_VECTOR_CONVERSION:
case NODECL_INTEL_ASSUME:
case NODECL_CXX_CAST:
case NODECL_ANALYSIS_RANGE_INTERSECTION:
case NODECL_CXX_DEP_NAME_NESTED:
case NODECL_NEG:
case NODECL_VECTOR_ARITHMETIC_SHR:
case NODECL_CXX_CLASS_MEMBER_ACCESS:
case NODECL_CXX_LAMBDA:
case NODECL_OFFSETOF:
case NODECL_NEW:
case NODECL_VECTOR_MASK_OR:
case NODECL_FORTRAN_BIND_C:
case NODECL_GXX_TRAIT:
case NODECL_VECTOR_SCATTER:
case NODECL_MOD_ASSIGNMENT:
case NODECL_DIFFERENT:
case NODECL_VECTOR_MASK_AND:
case NODECL_CXX_ALIGNOF:
case NODECL_LOWER_OR_EQUAL_THAN:
case NODECL_SIZEOF:
case NODECL_COMPOUND_EXPRESSION:
case NODECL_VECTOR_STORE:
case NODECL_ADD_ASSIGNMENT:
case NODECL_VECTOR_GATHER:
case NODECL_LOWER_THAN:
case NODECL_VECTOR_SINCOS:
case NODECL_BITWISE_AND:
case NODECL_LOGICAL_OR:
case NODECL_FORTRAN_BOZ_LITERAL:
case NODECL_COMPLEX_LITERAL:
case NODECL_BITWISE_XOR:
case NODECL_BITWISE_NOT:
case NODECL_MINUS:
case NODECL_MINUS_ASSIGNMENT:
case NODECL_VECTOR_LANE_ID:
case NODECL_BOOLEAN_LITERAL:
case NODECL_POWER:
case NODECL_FORTRAN_USE:
case NODECL_EQUAL:
case NODECL_CONDITIONAL_EXPRESSION:
case NODECL_CONCAT:
case NODECL_VECTOR_LOGICAL_AND:
case NODECL_CLASS_MEMBER_ACCESS:
case NODECL_REFERENCE:
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_VECTOR_FABS:
case NODECL_FORTRAN_HOLLERITH:
case NODECL_VLA_WILDCARD:
case NODECL_PREINCREMENT:
case NODECL_TYPEID:
case NODECL_ANALYSIS_PLUS_INFINITY:
case NODECL_OFFSET:
case NODECL_CXX_SIZEOF_PACK:
case NODECL_UNKNOWN:
case NODECL_ANALYSIS_RANGE_UNION:
case NODECL_ARITHMETIC_SHR:
case NODECL_CXX_VALUE_PACK_EXPANDED:
case NODECL_VECTOR_EQUAL:
case NODECL_ADD:
case NODECL_ANALYSIS_MINUS_INFINITY:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_C99_DESIGNATED_INITIALIZER:
case NODECL_POSTINCREMENT:
case NODECL_VECTOR_MINUS:
case NODECL_VECTOR_BITWISE_NOT:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_STRING_LITERAL:
case NODECL_VECTOR_MASK_NOT:
case NODECL_BITWISE_OR:
case NODECL_CXX_POSTFIX_INITIALIZER:
case NODECL_TEXT:
case NODECL_CXX_DEP_DECLTYPE:
case NODECL_MUL:
case NODECL_VECTOR_LOAD:
case NODECL_CXX_SIZEOF:
case NODECL_VECTOR_PROMOTION:
case NODECL_VECTOR_GREATER_THAN:
case NODECL_GREATER_THAN:
case NODECL_BITWISE_XOR_ASSIGNMENT:
case NODECL_VECTOR_BITWISE_SHR:
case NODECL_BITWISE_SHL_ASSIGNMENT:
case NODECL_C99_INDEX_DESIGNATOR:
case NODECL_VECTOR_BITWISE_OR:
case NODECL_POSTDECREMENT:
case NODECL_CONTEXT:
case NODECL_VECTOR_BITWISE_SHL:
case NODECL_OMP_SS_TASK_CALL:
case NODECL_VECTOR_CAST:
case NODECL_DELETE_ARRAY:
case NODECL_ANALYSIS_EMPTY_RANGE:
case NODECL_ANALYSIS_PHI:
case NODECL_CXX_ALIGNAS:
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
case NODECL_VIRTUAL_FUNCTION_CALL:
case NODECL_VECTOR_BITWISE_AND:
case NODECL_MASK_LITERAL:
case NODECL_VECTOR_DIV:
case NODECL_BITWISE_OR_ASSIGNMENT:
case NODECL_VECTOR_RCP:
case NODECL_CXX_VALUE_PACK:
case NODECL_VECTOR_MASK_XOR:
case NODECL_VECTOR_MASK_ASSIGNMENT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_VECTOR_FMMINUS:
case NODECL_GREATER_OR_EQUAL_THAN:
case NODECL_VECTOR_GREATER_OR_EQUAL_THAN:
case NODECL_POINTER_TO_MEMBER:
case NODECL_VECTOR_MASK_CONVERSION:
case NODECL_VECTOR_LOOP:
case NODECL_VECTOR_ASSIGNMENT:
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
case NODECL_VECTOR_MOD:
case NODECL_VECTOR_REDUCTION_ADD:
case NODECL_BITWISE_SHR:
case NODECL_VECTOR_ADD:
case NODECL_FLOATING_LITERAL:
case NODECL_GCC_ASM_SPEC:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_VECTOR_LOGICAL_OR:
case NODECL_OBJECT_INIT:
case NODECL_VECTOR_ALIGN_RIGHT:
case NODECL_VECTOR_NEG:
case NODECL_BITWISE_SHL:
case NODECL_ASSIGNMENT:
case NODECL_MUL_ASSIGNMENT:
case NODECL_VECTOR_DIFFERENT:
case NODECL_BITWISE_SHR_ASSIGNMENT:
case NODECL_VECTOR_RSQRT:
case NODECL_FORTRAN_EQUIVALENCE:
case NODECL_VECTOR_MUL:
case NODECL_CUDA_KERNEL_CALL:
case NODECL_VECTOR_LOGICAL_NOT:
case NODECL_CXX_EXPLICIT_TYPE_CAST:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_RANGE:
case NODECL_ANALYSIS_MINIMUM:
case NODECL_VERBATIM:
case NODECL_DEREFERENCE:
case NODECL_DIV:
case NODECL_CXX_ARROW_PTR_MEMBER:
case NODECL_VECTOR_REDUCTION_MINUS:
case NODECL_VECTOR_SQRT:
case NODECL_DIV_ASSIGNMENT:
case NODECL_CXX_BRACED_INITIALIZER:
case NODECL_MOD:
case NODECL_VECTOR_REDUCTION_MUL:
case NODECL_PSEUDO_DESTRUCTOR_NAME:
case NODECL_CXX_DEP_NEW:
case NODECL_VECTOR_MASK_AND_2_NOT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_VECTOR_FUNCTION_CALL:
case NODECL_ERR_EXPR:
case NODECL_NOEXCEPT_IMPLICIT_TRUE:
case NODECL_SOURCE_COMMENT:
case NODECL_FORTRAN_USE_ONLY:
case NODECL_ASM_DEFINITION:
case NODECL_VECTOR_LITERAL:
case NODECL_ALIGNOF:
case NODECL_GXX_BUILTIN_ADDRESSOF:
case NODECL_MULTI_EXPRESSION:
case NODECL_CXX_DOT_PTR_MEMBER:
case NODECL_VECTOR_LOWER_THAN:
case NODECL_PARENTHESIZED_EXPRESSION:
case NODECL_CONVERSION:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_ANALYSIS_RANGE_SUB:
case NODECL_ARITHMETIC_SHR_ASSIGNMENT:
case NODECL_INTEGER_LITERAL:
case NODECL_LOGICAL_NOT:
case NODECL_STRUCTURED_VALUE:
case NODECL_FORTRAN_DATA:
case NODECL_CXX_DEP_FUNCTION_CALL:
case NODECL_CXX_NOEXCEPT:
case NODECL_PREDECREMENT:
case NODECL_VECTOR_PREFETCH:
case NODECL_COMMA:
case NODECL_REAL_PART:
case NODECL_VECTOR_MASK_AND_1_NOT:
case NODECL_PLUS:
case NODECL_BITWISE_AND_ASSIGNMENT:
case NODECL_CXX_ARROW:
{
nodecl_check_expression(n);
break;
}
case NODECL_FORTRAN_IMPLIED_DO:
{
nodecl_check_fortran_implied_do(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_task_call(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OMP_SS_TASK_CALL:
{
nodecl_check_OMP_SS_TASK_CALL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_simd_constructs(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_SIMD:
{
nodecl_check_simd_construct(n);
break;
}
case NODECL_OPEN_M_P_SIMD_FOR:
{
nodecl_check_simd_for_construct(n);
break;
}
case NODECL_OPEN_M_P_PARALLEL_SIMD_FOR:
{
nodecl_check_parallel_simd_for_construct(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_cxx_expr_dependent_nodecls(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
case NODECL_CXX_DEP_NAME_NESTED:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_CXX_DEP_DECLTYPE:
{
nodecl_check_cxx_dependent_name(n);
break;
}
case NODECL_CXX_BRACED_INITIALIZER:
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
case NODECL_C99_DESIGNATED_INITIALIZER:
case NODECL_CXX_INITIALIZER:
case NODECL_C99_FIELD_DESIGNATOR:
case NODECL_CXX_EQUAL_INITIALIZER:
case NODECL_C99_INDEX_DESIGNATOR:
{
nodecl_check_cxx_dependent_initializer(n);
break;
}
case NODECL_CXX_CAST:
case NODECL_CXX_NOEXCEPT:
case NODECL_CXX_POSTFIX_INITIALIZER:
case NODECL_CXX_SIZEOF_PACK:
case NODECL_CXX_EXPLICIT_TYPE_CAST:
case NODECL_CXX_DEP_FUNCTION_CALL:
case NODECL_CXX_DEP_NEW:
case NODECL_CXX_DOT_PTR_MEMBER:
case NODECL_CXX_CLASS_MEMBER_ACCESS:
case NODECL_CXX_ALIGNAS:
case NODECL_CXX_LAMBDA:
case NODECL_CXX_ARROW_PTR_MEMBER:
case NODECL_CXX_ARROW:
case NODECL_CXX_ALIGNOF:
case NODECL_CXX_SIZEOF:
{
nodecl_check_cxx_dependent_expressions(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_taskyield_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_TASKYIELD:
{
nodecl_check_OPEN_M_P_TASKYIELD(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_workshare_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_WORKSHARE:
{
nodecl_check_OPEN_M_P_WORKSHARE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_top_level(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_VECTOR_FUNCTION_CODE:
case NODECL_FUNCTION_CODE:
case NODECL_TEMPLATE_FUNCTION_CODE:
{
nodecl_check_function_code(n);
break;
}
case NODECL_OBJECT_INIT:
{
nodecl_check_object_init(n);
break;
}
case NODECL_PRAGMA_CUSTOM_DIRECTIVE:
case NODECL_PRAGMA_CUSTOM_DECLARATION:
{
nodecl_check_pragma_directive(n);
break;
}
case NODECL_GXX_TRAIT:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_GCC_ASM_SPEC:
case NODECL_ASM_DEFINITION:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_VERBATIM:
case NODECL_PREPROCESSOR_LINE:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_SOURCE_COMMENT:
case NODECL_TEXT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_INTEL_ASSUME:
{
nodecl_check_compatibility(n);
break;
}
case NODECL_CXX_EXPLICIT_INSTANTIATION_DECL:
case NODECL_CXX_USING_NAMESPACE:
case NODECL_CXX_IMPLICIT_INSTANTIATION:
case NODECL_CXX_DEF:
case NODECL_CXX_EXPLICIT_INSTANTIATION_DEF:
case NODECL_CXX_PARSE_LATER:
case NODECL_CXX_USING_DECL:
case NODECL_CXX_DECL:
{
nodecl_check_cxx_decl(n);
break;
}
case NODECL_OPEN_M_P_DECLARE_TARGET:
{
nodecl_check_device_constructs_top_level(n);
break;
}
case NODECL_OPEN_M_P_SIMD_FUNCTION:
{
nodecl_check_simd_func_construct(n);
break;
}
case NODECL_OMP_SS_TARGET_DECLARATION:
{
nodecl_check_target_declaration(n);
break;
}
case NODECL_ANALYSIS_ASSERT_DECL:
{
nodecl_check_assert_directive(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_pragma_clause_arg(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_PRAGMA_CLAUSE_ARG:
{
nodecl_check_PRAGMA_CLAUSE_ARG(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_simd_func_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_SIMD_FUNCTION:
{
nodecl_check_OPEN_M_P_SIMD_FUNCTION(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_mem_init(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_MEMBER_INIT:
{
nodecl_check_MEMBER_INIT(n);
break;
}
case NODECL_IMPLICIT_MEMBER_INIT:
{
nodecl_check_IMPLICIT_MEMBER_INIT(n);
break;
}
case NODECL_CXX_MEMBER_INIT:
{
nodecl_check_cxx_mem_init(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_atomic_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_ATOMIC:
{
nodecl_check_OPEN_M_P_ATOMIC(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_cxx_dependent_expressions(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_CLASS_MEMBER_ACCESS:
{
nodecl_check_CXX_CLASS_MEMBER_ACCESS(n);
break;
}
case NODECL_CXX_ARROW:
{
nodecl_check_CXX_ARROW(n);
break;
}
case NODECL_CXX_DOT_PTR_MEMBER:
{
nodecl_check_CXX_DOT_PTR_MEMBER(n);
break;
}
case NODECL_CXX_ARROW_PTR_MEMBER:
{
nodecl_check_CXX_ARROW_PTR_MEMBER(n);
break;
}
case NODECL_CXX_SIZEOF:
{
nodecl_check_CXX_SIZEOF(n);
break;
}
case NODECL_CXX_SIZEOF_PACK:
{
nodecl_check_CXX_SIZEOF_PACK(n);
break;
}
case NODECL_CXX_ALIGNOF:
{
nodecl_check_CXX_ALIGNOF(n);
break;
}
case NODECL_CXX_POSTFIX_INITIALIZER:
{
nodecl_check_CXX_POSTFIX_INITIALIZER(n);
break;
}
case NODECL_CXX_CAST:
{
nodecl_check_CXX_CAST(n);
break;
}
case NODECL_CXX_EXPLICIT_TYPE_CAST:
{
nodecl_check_CXX_EXPLICIT_TYPE_CAST(n);
break;
}
case NODECL_CXX_DEP_FUNCTION_CALL:
{
nodecl_check_CXX_DEP_FUNCTION_CALL(n);
break;
}
case NODECL_CXX_DEP_NEW:
{
nodecl_check_CXX_DEP_NEW(n);
break;
}
case NODECL_CXX_NOEXCEPT:
{
nodecl_check_CXX_NOEXCEPT(n);
break;
}
case NODECL_CXX_LAMBDA:
{
nodecl_check_CXX_LAMBDA(n);
break;
}
case NODECL_CXX_ALIGNAS:
{
nodecl_check_CXX_ALIGNAS(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_structured_value(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_STRUCTURED_VALUE:
{
nodecl_check_STRUCTURED_VALUE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_fortran_expressions(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FORTRAN_DATA:
{
nodecl_check_FORTRAN_DATA(n);
break;
}
case NODECL_FORTRAN_EQUIVALENCE:
{
nodecl_check_FORTRAN_EQUIVALENCE(n);
break;
}
case NODECL_FORTRAN_BOZ_LITERAL:
{
nodecl_check_FORTRAN_BOZ_LITERAL(n);
break;
}
case NODECL_FORTRAN_BIND_C:
{
nodecl_check_FORTRAN_BIND_C(n);
break;
}
case NODECL_FORTRAN_HOLLERITH:
{
nodecl_check_FORTRAN_HOLLERITH(n);
break;
}
case NODECL_FORTRAN_USE:
{
nodecl_check_FORTRAN_USE(n);
break;
}
case NODECL_FORTRAN_USE_ONLY:
{
nodecl_check_FORTRAN_USE_ONLY(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_simd_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_SIMD:
{
nodecl_check_OPEN_M_P_SIMD(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_fortran_actual_argument(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FORTRAN_ACTUAL_ARGUMENT:
{
nodecl_check_FORTRAN_ACTUAL_ARGUMENT(n);
break;
}
case NODECL_FORTRAN_NOT_PRESENT:
{
nodecl_check_FORTRAN_NOT_PRESENT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_memory_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_FLUSH_AT_ENTRY:
{
nodecl_check_OPEN_M_P_FLUSH_AT_ENTRY(n);
break;
}
case NODECL_OPEN_M_P_FLUSH_AT_EXIT:
{
nodecl_check_OPEN_M_P_FLUSH_AT_EXIT(n);
break;
}
case NODECL_OPEN_M_P_NO_FLUSH:
{
nodecl_check_OPEN_M_P_NO_FLUSH(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_default_arg(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_DEFAULT_ARGUMENT:
{
nodecl_check_DEFAULT_ARGUMENT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_cxx_mem_init(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_MEMBER_INIT:
{
nodecl_check_CXX_MEMBER_INIT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_multi_expr_iterator(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_MULTI_EXPRESSION_ITERATOR:
{
nodecl_check_MULTI_EXPRESSION_ITERATOR(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_section_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_SECTION:
{
nodecl_check_OPEN_M_P_SECTION(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_compound_statement(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_COMPOUND_STATEMENT:
{
nodecl_check_COMPOUND_STATEMENT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_statement_but_object_init(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_EMPTY_STATEMENT:
{
nodecl_check_EMPTY_STATEMENT(n);
break;
}
case NODECL_EXPRESSION_STATEMENT:
{
nodecl_check_EXPRESSION_STATEMENT(n);
break;
}
case NODECL_COMPOUND_STATEMENT:
{
nodecl_check_compound_statement(n);
break;
}
case NODECL_DO_STATEMENT:
{
nodecl_check_DO_STATEMENT(n);
break;
}
case NODECL_WHILE_STATEMENT:
{
nodecl_check_WHILE_STATEMENT(n);
break;
}
case NODECL_FOR_STATEMENT:
{
nodecl_check_FOR_STATEMENT(n);
break;
}
case NODECL_IF_ELSE_STATEMENT:
{
nodecl_check_IF_ELSE_STATEMENT(n);
break;
}
case NODECL_LABELED_STATEMENT:
{
nodecl_check_LABELED_STATEMENT(n);
break;
}
case NODECL_SWITCH_STATEMENT:
{
nodecl_check_SWITCH_STATEMENT(n);
break;
}
case NODECL_DEFAULT_STATEMENT:
{
nodecl_check_DEFAULT_STATEMENT(n);
break;
}
case NODECL_CASE_STATEMENT:
{
nodecl_check_CASE_STATEMENT(n);
break;
}
case NODECL_BREAK_STATEMENT:
{
nodecl_check_BREAK_STATEMENT(n);
break;
}
case NODECL_CONTINUE_STATEMENT:
{
nodecl_check_CONTINUE_STATEMENT(n);
break;
}
case NODECL_GOTO_STATEMENT:
{
nodecl_check_GOTO_STATEMENT(n);
break;
}
case NODECL_RETURN_STATEMENT:
{
nodecl_check_RETURN_STATEMENT(n);
break;
}
case NODECL_PRAGMA_CUSTOM_DIRECTIVE:
case NODECL_PRAGMA_CUSTOM_DECLARATION:
{
nodecl_check_pragma_directive(n);
break;
}
case NODECL_PRAGMA_CUSTOM_STATEMENT:
{
nodecl_check_pragma_statement(n);
break;
}
case NODECL_TRY_BLOCK:
case NODECL_CXX_FOR_RANGED:
case NODECL_CATCH_HANDLER:
case NODECL_CXX_STATIC_ASSERT:
{
nodecl_check_c_cxx_only_statements(n);
break;
}
case NODECL_FORTRAN_LABEL_ASSIGN_STATEMENT:
case NODECL_FORTRAN_ALTERNATE_RETURN_STATEMENT:
case NODECL_FORTRAN_NULLIFY_STATEMENT:
case NODECL_FORTRAN_PRINT_STATEMENT:
case NODECL_FORTRAN_PAUSE_STATEMENT:
case NODECL_FORTRAN_OPEN_STATEMENT:
case NODECL_FORTRAN_ARITHMETIC_IF_STATEMENT:
case NODECL_FORTRAN_READ_STATEMENT:
case NODECL_FORTRAN_ENTRY_STATEMENT:
case NODECL_FORTRAN_WHERE:
case NODECL_FORTRAN_STOP_STATEMENT:
case NODECL_FORTRAN_FORALL:
case NODECL_FORTRAN_ALLOCATE_STATEMENT:
case NODECL_FORTRAN_DEALLOCATE_STATEMENT:
case NODECL_FORTRAN_COMPUTED_GOTO_STATEMENT:
case NODECL_FORTRAN_WRITE_STATEMENT:
case NODECL_FORTRAN_IO_STATEMENT:
case NODECL_FORTRAN_CLOSE_STATEMENT:
case NODECL_FORTRAN_ASSIGNED_GOTO_STATEMENT:
{
nodecl_check_fortran_only_statements(n);
break;
}
case NODECL_GXX_TRAIT:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_GCC_ASM_SPEC:
case NODECL_ASM_DEFINITION:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_VERBATIM:
case NODECL_PREPROCESSOR_LINE:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_SOURCE_COMMENT:
case NODECL_TEXT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_INTEL_ASSUME:
{
nodecl_check_compatibility(n);
break;
}
case NODECL_ERR_STATEMENT:
{
nodecl_check_ERR_STATEMENT(n);
break;
}
case NODECL_ANALYSIS_ASSERT:
{
nodecl_check_assert_construct(n);
break;
}
case NODECL_OPEN_M_P_TARGET_DATA:
case NODECL_OPEN_M_P_ATOMIC:
case NODECL_OMP_SS_UNREGISTER:
case NODECL_OPEN_M_P_FOR:
case NODECL_OPEN_M_P_SIMD_FOR:
case NODECL_OPEN_M_P_TASK:
case NODECL_OPEN_M_P_TEAMS:
case NODECL_OPEN_M_P_TASKYIELD:
case NODECL_OPEN_M_P_TARGET_UPDATE:
case NODECL_OPEN_M_P_FOR_APPENDIX:
case NODECL_OPEN_M_P_TASKWAIT:
case NODECL_OPEN_M_P_TASKLOOP:
case NODECL_OMP_SS_LOOP:
case NODECL_OMP_SS_RELEASE:
case NODECL_OPEN_M_P_FLUSH_MEMORY:
case NODECL_OPEN_M_P_SECTIONS:
case NODECL_OPEN_M_P_TARGET:
case NODECL_OPEN_M_P_BARRIER_WAIT:
case NODECL_OPEN_M_P_PARALLEL_SIMD_FOR:
case NODECL_OPEN_M_P_DISTRIBUTE:
case NODECL_OPEN_M_P_MASTER:
case NODECL_OPEN_M_P_TASKGROUP:
case NODECL_OPEN_M_P_BARRIER_FULL:
case NODECL_OPEN_M_P_WORKSHARE:
case NODECL_OPEN_M_P_SINGLE:
case NODECL_OMP_SS_REGISTER:
case NODECL_OPEN_M_P_PARALLEL:
case NODECL_OPEN_M_P_BARRIER_SIGNAL:
case NODECL_OPEN_M_P_SIMD:
case NODECL_OPEN_M_P_CRITICAL:
{
nodecl_check_parallel_statements(n);
break;
}
case NODECL_CHECKPOINT_LOAD:
case NODECL_CHECKPOINT_INIT:
case NODECL_CHECKPOINT_SHUTDOWN:
case NODECL_CHECKPOINT_STORE:
{
nodecl_check_checkpoint_directives(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_object_init(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OBJECT_INIT:
{
nodecl_check_OBJECT_INIT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_gcc_asm_spec(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_GCC_ASM_SPEC:
{
nodecl_check_GCC_ASM_SPEC(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_context(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CONTEXT:
{
nodecl_check_CONTEXT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_parallel_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_PARALLEL:
{
nodecl_check_OPEN_M_P_PARALLEL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_fortran_argument(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ARRAY_SUBSCRIPT:
case NODECL_DELETE:
case NODECL_C99_FIELD_DESIGNATOR:
case NODECL_SYMBOL:
case NODECL_VECTOR_BITWISE_XOR:
case NODECL_VECTOR_SUBSCRIPT:
case NODECL_PREPROCESSOR_LINE:
case NODECL_FUNCTION_CALL:
case NODECL_LOGICAL_AND:
case NODECL_CXX_EQUAL_INITIALIZER:
case NODECL_OMP_SS_TASK_EXPRESSION:
case NODECL_CXX_INITIALIZER:
case NODECL_VECTOR_CONDITIONAL_EXPRESSION:
case NODECL_IMAG_PART:
case NODECL_VECTOR_FMADD:
case NODECL_ANALYSIS_MAXIMUM:
case NODECL_SHAPING:
case NODECL_THROW:
case NODECL_DUMMY:
case NODECL_VECTOR_LOWER_OR_EQUAL_THAN:
case NODECL_VECTOR_CONVERSION:
case NODECL_INTEL_ASSUME:
case NODECL_CXX_CAST:
case NODECL_ANALYSIS_RANGE_INTERSECTION:
case NODECL_CXX_DEP_NAME_NESTED:
case NODECL_NEG:
case NODECL_VECTOR_ARITHMETIC_SHR:
case NODECL_CXX_CLASS_MEMBER_ACCESS:
case NODECL_CXX_LAMBDA:
case NODECL_OFFSETOF:
case NODECL_NEW:
case NODECL_VECTOR_MASK_OR:
case NODECL_FORTRAN_BIND_C:
case NODECL_GXX_TRAIT:
case NODECL_VECTOR_SCATTER:
case NODECL_MOD_ASSIGNMENT:
case NODECL_DIFFERENT:
case NODECL_VECTOR_MASK_AND:
case NODECL_CXX_ALIGNOF:
case NODECL_LOWER_OR_EQUAL_THAN:
case NODECL_SIZEOF:
case NODECL_COMPOUND_EXPRESSION:
case NODECL_VECTOR_STORE:
case NODECL_ADD_ASSIGNMENT:
case NODECL_VECTOR_GATHER:
case NODECL_LOWER_THAN:
case NODECL_VECTOR_SINCOS:
case NODECL_BITWISE_AND:
case NODECL_LOGICAL_OR:
case NODECL_FORTRAN_BOZ_LITERAL:
case NODECL_COMPLEX_LITERAL:
case NODECL_BITWISE_XOR:
case NODECL_BITWISE_NOT:
case NODECL_MINUS:
case NODECL_MINUS_ASSIGNMENT:
case NODECL_VECTOR_LANE_ID:
case NODECL_BOOLEAN_LITERAL:
case NODECL_POWER:
case NODECL_FORTRAN_USE:
case NODECL_EQUAL:
case NODECL_CONDITIONAL_EXPRESSION:
case NODECL_CONCAT:
case NODECL_VECTOR_LOGICAL_AND:
case NODECL_CLASS_MEMBER_ACCESS:
case NODECL_REFERENCE:
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_VECTOR_FABS:
case NODECL_FORTRAN_HOLLERITH:
case NODECL_VLA_WILDCARD:
case NODECL_PREINCREMENT:
case NODECL_TYPEID:
case NODECL_ANALYSIS_PLUS_INFINITY:
case NODECL_OFFSET:
case NODECL_CXX_SIZEOF_PACK:
case NODECL_UNKNOWN:
case NODECL_ANALYSIS_RANGE_UNION:
case NODECL_ARITHMETIC_SHR:
case NODECL_CXX_VALUE_PACK_EXPANDED:
case NODECL_VECTOR_EQUAL:
case NODECL_ADD:
case NODECL_ANALYSIS_MINUS_INFINITY:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_C99_DESIGNATED_INITIALIZER:
case NODECL_POSTINCREMENT:
case NODECL_VECTOR_MINUS:
case NODECL_VECTOR_BITWISE_NOT:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_STRING_LITERAL:
case NODECL_VECTOR_MASK_NOT:
case NODECL_BITWISE_OR:
case NODECL_CXX_POSTFIX_INITIALIZER:
case NODECL_TEXT:
case NODECL_CXX_DEP_DECLTYPE:
case NODECL_MUL:
case NODECL_VECTOR_LOAD:
case NODECL_CXX_SIZEOF:
case NODECL_VECTOR_PROMOTION:
case NODECL_VECTOR_GREATER_THAN:
case NODECL_GREATER_THAN:
case NODECL_BITWISE_XOR_ASSIGNMENT:
case NODECL_VECTOR_BITWISE_SHR:
case NODECL_BITWISE_SHL_ASSIGNMENT:
case NODECL_C99_INDEX_DESIGNATOR:
case NODECL_VECTOR_BITWISE_OR:
case NODECL_POSTDECREMENT:
case NODECL_CONTEXT:
case NODECL_VECTOR_BITWISE_SHL:
case NODECL_OMP_SS_TASK_CALL:
case NODECL_VECTOR_CAST:
case NODECL_DELETE_ARRAY:
case NODECL_ANALYSIS_EMPTY_RANGE:
case NODECL_ANALYSIS_PHI:
case NODECL_CXX_ALIGNAS:
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
case NODECL_VIRTUAL_FUNCTION_CALL:
case NODECL_VECTOR_BITWISE_AND:
case NODECL_MASK_LITERAL:
case NODECL_VECTOR_DIV:
case NODECL_BITWISE_OR_ASSIGNMENT:
case NODECL_VECTOR_RCP:
case NODECL_CXX_VALUE_PACK:
case NODECL_VECTOR_MASK_XOR:
case NODECL_VECTOR_MASK_ASSIGNMENT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_VECTOR_FMMINUS:
case NODECL_GREATER_OR_EQUAL_THAN:
case NODECL_VECTOR_GREATER_OR_EQUAL_THAN:
case NODECL_POINTER_TO_MEMBER:
case NODECL_VECTOR_MASK_CONVERSION:
case NODECL_VECTOR_LOOP:
case NODECL_VECTOR_ASSIGNMENT:
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
case NODECL_VECTOR_MOD:
case NODECL_VECTOR_REDUCTION_ADD:
case NODECL_BITWISE_SHR:
case NODECL_VECTOR_ADD:
case NODECL_FLOATING_LITERAL:
case NODECL_GCC_ASM_SPEC:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_VECTOR_LOGICAL_OR:
case NODECL_OBJECT_INIT:
case NODECL_VECTOR_ALIGN_RIGHT:
case NODECL_VECTOR_NEG:
case NODECL_BITWISE_SHL:
case NODECL_ASSIGNMENT:
case NODECL_MUL_ASSIGNMENT:
case NODECL_VECTOR_DIFFERENT:
case NODECL_BITWISE_SHR_ASSIGNMENT:
case NODECL_VECTOR_RSQRT:
case NODECL_FORTRAN_EQUIVALENCE:
case NODECL_VECTOR_MUL:
case NODECL_CUDA_KERNEL_CALL:
case NODECL_VECTOR_LOGICAL_NOT:
case NODECL_CXX_EXPLICIT_TYPE_CAST:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_RANGE:
case NODECL_ANALYSIS_MINIMUM:
case NODECL_VERBATIM:
case NODECL_DEREFERENCE:
case NODECL_DIV:
case NODECL_CXX_ARROW_PTR_MEMBER:
case NODECL_VECTOR_REDUCTION_MINUS:
case NODECL_VECTOR_SQRT:
case NODECL_DIV_ASSIGNMENT:
case NODECL_CXX_BRACED_INITIALIZER:
case NODECL_MOD:
case NODECL_VECTOR_REDUCTION_MUL:
case NODECL_PSEUDO_DESTRUCTOR_NAME:
case NODECL_CXX_DEP_NEW:
case NODECL_VECTOR_MASK_AND_2_NOT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_VECTOR_FUNCTION_CALL:
case NODECL_ERR_EXPR:
case NODECL_NOEXCEPT_IMPLICIT_TRUE:
case NODECL_SOURCE_COMMENT:
case NODECL_FORTRAN_USE_ONLY:
case NODECL_ASM_DEFINITION:
case NODECL_VECTOR_LITERAL:
case NODECL_ALIGNOF:
case NODECL_GXX_BUILTIN_ADDRESSOF:
case NODECL_MULTI_EXPRESSION:
case NODECL_CXX_DOT_PTR_MEMBER:
case NODECL_VECTOR_LOWER_THAN:
case NODECL_PARENTHESIZED_EXPRESSION:
case NODECL_CONVERSION:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_ANALYSIS_RANGE_SUB:
case NODECL_ARITHMETIC_SHR_ASSIGNMENT:
case NODECL_INTEGER_LITERAL:
case NODECL_LOGICAL_NOT:
case NODECL_STRUCTURED_VALUE:
case NODECL_FORTRAN_DATA:
case NODECL_CXX_DEP_FUNCTION_CALL:
case NODECL_CXX_NOEXCEPT:
case NODECL_PREDECREMENT:
case NODECL_VECTOR_PREFETCH:
case NODECL_COMMA:
case NODECL_REAL_PART:
case NODECL_VECTOR_MASK_AND_1_NOT:
case NODECL_PLUS:
case NODECL_BITWISE_AND_ASSIGNMENT:
case NODECL_CXX_ARROW:
{
nodecl_check_expression(n);
break;
}
case NODECL_FORTRAN_ALTERNATE_RETURN_ARGUMENT:
{
nodecl_check_alt_return(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_expression(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_INTEGER_LITERAL:
case NODECL_STRING_LITERAL:
case NODECL_STRUCTURED_VALUE:
case NODECL_FLOATING_LITERAL:
case NODECL_COMPLEX_LITERAL:
case NODECL_BOOLEAN_LITERAL:
{
nodecl_check_literal(n);
break;
}
case NODECL_SYMBOL:
{
nodecl_check_name(n);
break;
}
case NODECL_CONTEXT:
{
nodecl_check_context(n);
break;
}
case NODECL_FUNCTION_CALL:
{
nodecl_check_FUNCTION_CALL(n);
break;
}
case NODECL_ARRAY_SUBSCRIPT:
{
nodecl_check_ARRAY_SUBSCRIPT(n);
break;
}
case NODECL_RANGE:
{
nodecl_check_range_expression(n);
break;
}
case NODECL_CLASS_MEMBER_ACCESS:
{
nodecl_check_CLASS_MEMBER_ACCESS(n);
break;
}
case NODECL_PLUS:
{
nodecl_check_PLUS(n);
break;
}
case NODECL_NEG:
{
nodecl_check_NEG(n);
break;
}
case NODECL_MUL:
{
nodecl_check_MUL(n);
break;
}
case NODECL_POWER:
{
nodecl_check_POWER(n);
break;
}
case NODECL_DIV:
{
nodecl_check_DIV(n);
break;
}
case NODECL_MOD:
{
nodecl_check_MOD(n);
break;
}
case NODECL_ADD:
{
nodecl_check_ADD(n);
break;
}
case NODECL_MINUS:
{
nodecl_check_MINUS(n);
break;
}
case NODECL_CONCAT:
{
nodecl_check_CONCAT(n);
break;
}
case NODECL_EQUAL:
{
nodecl_check_EQUAL(n);
break;
}
case NODECL_DIFFERENT:
{
nodecl_check_DIFFERENT(n);
break;
}
case NODECL_LOWER_THAN:
{
nodecl_check_LOWER_THAN(n);
break;
}
case NODECL_LOWER_OR_EQUAL_THAN:
{
nodecl_check_LOWER_OR_EQUAL_THAN(n);
break;
}
case NODECL_GREATER_THAN:
{
nodecl_check_GREATER_THAN(n);
break;
}
case NODECL_GREATER_OR_EQUAL_THAN:
{
nodecl_check_GREATER_OR_EQUAL_THAN(n);
break;
}
case NODECL_LOGICAL_NOT:
{
nodecl_check_LOGICAL_NOT(n);
break;
}
case NODECL_LOGICAL_AND:
{
nodecl_check_LOGICAL_AND(n);
break;
}
case NODECL_LOGICAL_OR:
{
nodecl_check_LOGICAL_OR(n);
break;
}
case NODECL_BITWISE_NOT:
{
nodecl_check_BITWISE_NOT(n);
break;
}
case NODECL_BITWISE_AND:
{
nodecl_check_BITWISE_AND(n);
break;
}
case NODECL_BITWISE_OR:
{
nodecl_check_BITWISE_OR(n);
break;
}
case NODECL_BITWISE_XOR:
{
nodecl_check_BITWISE_XOR(n);
break;
}
case NODECL_BITWISE_SHL:
{
nodecl_check_BITWISE_SHL(n);
break;
}
case NODECL_ARITHMETIC_SHR:
{
nodecl_check_ARITHMETIC_SHR(n);
break;
}
case NODECL_BITWISE_SHR:
{
nodecl_check_BITWISE_SHR(n);
break;
}
case NODECL_ASSIGNMENT:
{
nodecl_check_ASSIGNMENT(n);
break;
}
case NODECL_PARENTHESIZED_EXPRESSION:
{
nodecl_check_PARENTHESIZED_EXPRESSION(n);
break;
}
case NODECL_DEREFERENCE:
{
nodecl_check_DEREFERENCE(n);
break;
}
case NODECL_COMPOUND_EXPRESSION:
{
nodecl_check_COMPOUND_EXPRESSION(n);
break;
}
case NODECL_VECTOR_SUBSCRIPT:
{
nodecl_check_VECTOR_SUBSCRIPT(n);
break;
}
case NODECL_VECTOR_ADD:
{
nodecl_check_VECTOR_ADD(n);
break;
}
case NODECL_VECTOR_FMADD:
{
nodecl_check_VECTOR_FMADD(n);
break;
}
case NODECL_VECTOR_MINUS:
{
nodecl_check_VECTOR_MINUS(n);
break;
}
case NODECL_VECTOR_FMMINUS:
{
nodecl_check_VECTOR_FMMINUS(n);
break;
}
case NODECL_VECTOR_MUL:
{
nodecl_check_VECTOR_MUL(n);
break;
}
case NODECL_VECTOR_DIV:
{
nodecl_check_VECTOR_DIV(n);
break;
}
case NODECL_VECTOR_RCP:
{
nodecl_check_VECTOR_RCP(n);
break;
}
case NODECL_VECTOR_MOD:
{
nodecl_check_VECTOR_MOD(n);
break;
}
case NODECL_VECTOR_NEG:
{
nodecl_check_VECTOR_NEG(n);
break;
}
case NODECL_VECTOR_SQRT:
{
nodecl_check_VECTOR_SQRT(n);
break;
}
case NODECL_VECTOR_RSQRT:
{
nodecl_check_VECTOR_RSQRT(n);
break;
}
case NODECL_VECTOR_REDUCTION_ADD:
{
nodecl_check_VECTOR_REDUCTION_ADD(n);
break;
}
case NODECL_VECTOR_REDUCTION_MINUS:
{
nodecl_check_VECTOR_REDUCTION_MINUS(n);
break;
}
case NODECL_VECTOR_REDUCTION_MUL:
{
nodecl_check_VECTOR_REDUCTION_MUL(n);
break;
}
case NODECL_VECTOR_EQUAL:
{
nodecl_check_VECTOR_EQUAL(n);
break;
}
case NODECL_VECTOR_DIFFERENT:
{
nodecl_check_VECTOR_DIFFERENT(n);
break;
}
case NODECL_VECTOR_LOWER_THAN:
{
nodecl_check_VECTOR_LOWER_THAN(n);
break;
}
case NODECL_VECTOR_LOWER_OR_EQUAL_THAN:
{
nodecl_check_VECTOR_LOWER_OR_EQUAL_THAN(n);
break;
}
case NODECL_VECTOR_GREATER_THAN:
{
nodecl_check_VECTOR_GREATER_THAN(n);
break;
}
case NODECL_VECTOR_GREATER_OR_EQUAL_THAN:
{
nodecl_check_VECTOR_GREATER_OR_EQUAL_THAN(n);
break;
}
case NODECL_VECTOR_LOGICAL_NOT:
{
nodecl_check_VECTOR_LOGICAL_NOT(n);
break;
}
case NODECL_VECTOR_LOGICAL_AND:
{
nodecl_check_VECTOR_LOGICAL_AND(n);
break;
}
case NODECL_VECTOR_LOGICAL_OR:
{
nodecl_check_VECTOR_LOGICAL_OR(n);
break;
}
case NODECL_VECTOR_BITWISE_NOT:
{
nodecl_check_VECTOR_BITWISE_NOT(n);
break;
}
case NODECL_VECTOR_BITWISE_AND:
{
nodecl_check_VECTOR_BITWISE_AND(n);
break;
}
case NODECL_VECTOR_BITWISE_OR:
{
nodecl_check_VECTOR_BITWISE_OR(n);
break;
}
case NODECL_VECTOR_BITWISE_XOR:
{
nodecl_check_VECTOR_BITWISE_XOR(n);
break;
}
case NODECL_VECTOR_BITWISE_SHL:
{
nodecl_check_VECTOR_BITWISE_SHL(n);
break;
}
case NODECL_VECTOR_ARITHMETIC_SHR:
{
nodecl_check_VECTOR_ARITHMETIC_SHR(n);
break;
}
case NODECL_VECTOR_BITWISE_SHR:
{
nodecl_check_VECTOR_BITWISE_SHR(n);
break;
}
case NODECL_VECTOR_ALIGN_RIGHT:
{
nodecl_check_VECTOR_ALIGN_RIGHT(n);
break;
}
case NODECL_VECTOR_ASSIGNMENT:
{
nodecl_check_VECTOR_ASSIGNMENT(n);
break;
}
case NODECL_VECTOR_STORE:
{
nodecl_check_VECTOR_STORE(n);
break;
}
case NODECL_VECTOR_SCATTER:
{
nodecl_check_VECTOR_SCATTER(n);
break;
}
case NODECL_VECTOR_LOAD:
{
nodecl_check_VECTOR_LOAD(n);
break;
}
case NODECL_VECTOR_GATHER:
{
nodecl_check_VECTOR_GATHER(n);
break;
}
case NODECL_VECTOR_PROMOTION:
{
nodecl_check_VECTOR_PROMOTION(n);
break;
}
case NODECL_VECTOR_PREFETCH:
{
nodecl_check_VECTOR_PREFETCH(n);
break;
}
case NODECL_VECTOR_LITERAL:
{
nodecl_check_VECTOR_LITERAL(n);
break;
}
case NODECL_VECTOR_LANE_ID:
{
nodecl_check_VECTOR_LANE_ID(n);
break;
}
case NODECL_VECTOR_CONVERSION:
{
nodecl_check_VECTOR_CONVERSION(n);
break;
}
case NODECL_VECTOR_CAST:
{
nodecl_check_VECTOR_CAST(n);
break;
}
case NODECL_VECTOR_FUNCTION_CALL:
{
nodecl_check_VECTOR_FUNCTION_CALL(n);
break;
}
case NODECL_VECTOR_FABS:
{
nodecl_check_VECTOR_FABS(n);
break;
}
case NODECL_VECTOR_SINCOS:
{
nodecl_check_VECTOR_SINCOS(n);
break;
}
case NODECL_VECTOR_MASK_ASSIGNMENT:
{
nodecl_check_VECTOR_MASK_ASSIGNMENT(n);
break;
}
case NODECL_VECTOR_MASK_CONVERSION:
{
nodecl_check_VECTOR_MASK_CONVERSION(n);
break;
}
case NODECL_VECTOR_MASK_NOT:
{
nodecl_check_VECTOR_MASK_NOT(n);
break;
}
case NODECL_VECTOR_MASK_AND:
{
nodecl_check_VECTOR_MASK_AND(n);
break;
}
case NODECL_VECTOR_MASK_OR:
{
nodecl_check_VECTOR_MASK_OR(n);
break;
}
case NODECL_VECTOR_MASK_XOR:
{
nodecl_check_VECTOR_MASK_XOR(n);
break;
}
case NODECL_VECTOR_MASK_AND_1_NOT:
{
nodecl_check_VECTOR_MASK_AND_1_NOT(n);
break;
}
case NODECL_VECTOR_MASK_AND_2_NOT:
{
nodecl_check_VECTOR_MASK_AND_2_NOT(n);
break;
}
case NODECL_VECTOR_LOOP:
{
nodecl_check_VECTOR_LOOP(n);
break;
}
case NODECL_NOEXCEPT_IMPLICIT_TRUE:
{
nodecl_check_NOEXCEPT_IMPLICIT_TRUE(n);
break;
}
case NODECL_BITWISE_XOR_ASSIGNMENT:
case NODECL_THROW:
case NODECL_C99_FIELD_DESIGNATOR:
case NODECL_POSTDECREMENT:
case NODECL_CXX_NOEXCEPT:
case NODECL_REAL_PART:
case NODECL_CXX_EQUAL_INITIALIZER:
case NODECL_DELETE_ARRAY:
case NODECL_CXX_ALIGNAS:
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
case NODECL_VIRTUAL_FUNCTION_CALL:
case NODECL_CXX_INITIALIZER:
case NODECL_VECTOR_CONDITIONAL_EXPRESSION:
case NODECL_IMAG_PART:
case NODECL_MASK_LITERAL:
case NODECL_BITWISE_SHL_ASSIGNMENT:
case NODECL_BITWISE_OR_ASSIGNMENT:
case NODECL_SHAPING:
case NODECL_DELETE:
case NODECL_CXX_VALUE_PACK:
case NODECL_C99_INDEX_DESIGNATOR:
case NODECL_CXX_CAST:
case NODECL_POINTER_TO_MEMBER:
case NODECL_CXX_DEP_NAME_NESTED:
case NODECL_CXX_CLASS_MEMBER_ACCESS:
case NODECL_CXX_LAMBDA:
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
case NODECL_OFFSETOF:
case NODECL_NEW:
case NODECL_MOD_ASSIGNMENT:
case NODECL_CXX_ALIGNOF:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_SIZEOF:
case NODECL_ADD_ASSIGNMENT:
case NODECL_CXX_DEP_DECLTYPE:
case NODECL_BITWISE_SHR_ASSIGNMENT:
case NODECL_PSEUDO_DESTRUCTOR_NAME:
case NODECL_CUDA_KERNEL_CALL:
case NODECL_CXX_EXPLICIT_TYPE_CAST:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_CXX_ARROW_PTR_MEMBER:
case NODECL_OFFSET:
case NODECL_MINUS_ASSIGNMENT:
case NODECL_DIV_ASSIGNMENT:
case NODECL_CXX_BRACED_INITIALIZER:
case NODECL_REFERENCE:
case NODECL_CXX_SIZEOF_PACK:
case NODECL_CXX_DEP_NEW:
case NODECL_CONDITIONAL_EXPRESSION:
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_ARITHMETIC_SHR_ASSIGNMENT:
case NODECL_VLA_WILDCARD:
case NODECL_PREINCREMENT:
case NODECL_ALIGNOF:
case NODECL_TYPEID:
case NODECL_GXX_BUILTIN_ADDRESSOF:
case NODECL_CXX_DOT_PTR_MEMBER:
case NODECL_POSTINCREMENT:
case NODECL_CXX_VALUE_PACK_EXPANDED:
case NODECL_C99_DESIGNATED_INITIALIZER:
case NODECL_CXX_DEP_FUNCTION_CALL:
case NODECL_PREDECREMENT:
case NODECL_COMMA:
case NODECL_CXX_POSTFIX_INITIALIZER:
case NODECL_BITWISE_AND_ASSIGNMENT:
case NODECL_CXX_ARROW:
case NODECL_MUL_ASSIGNMENT:
case NODECL_CXX_SIZEOF:
{
nodecl_check_c_cxx_expressions(n);
break;
}
case NODECL_FORTRAN_BOZ_LITERAL:
case NODECL_FORTRAN_USE:
case NODECL_FORTRAN_EQUIVALENCE:
case NODECL_FORTRAN_HOLLERITH:
case NODECL_FORTRAN_USE_ONLY:
case NODECL_FORTRAN_DATA:
case NODECL_FORTRAN_BIND_C:
{
nodecl_check_fortran_expressions(n);
break;
}
case NODECL_OBJECT_INIT:
{
nodecl_check_object_init(n);
break;
}
case NODECL_GXX_TRAIT:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_GCC_ASM_SPEC:
case NODECL_ASM_DEFINITION:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_VERBATIM:
case NODECL_PREPROCESSOR_LINE:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_SOURCE_COMMENT:
case NODECL_TEXT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_INTEL_ASSUME:
{
nodecl_check_compatibility(n);
break;
}
case NODECL_ERR_EXPR:
{
nodecl_check_ERR_EXPR(n);
break;
}
case NODECL_CONVERSION:
{
nodecl_check_CONVERSION(n);
break;
}
case NODECL_DUMMY:
{
nodecl_check_DUMMY(n);
break;
}
case NODECL_MULTI_EXPRESSION:
{
nodecl_check_MULTI_EXPRESSION(n);
break;
}
case NODECL_OMP_SS_TASK_CALL:
{
nodecl_check_task_call(n);
break;
}
case NODECL_OMP_SS_TASK_EXPRESSION:
{
nodecl_check_task_expression(n);
break;
}
case NODECL_ANALYSIS_MINUS_INFINITY:
case NODECL_ANALYSIS_PHI:
case NODECL_ANALYSIS_RANGE_INTERSECTION:
case NODECL_ANALYSIS_PLUS_INFINITY:
case NODECL_ANALYSIS_MAXIMUM:
case NODECL_ANALYSIS_RANGE_UNION:
case NODECL_ANALYSIS_RANGE_SUB:
case NODECL_ANALYSIS_MINIMUM:
case NODECL_ANALYSIS_EMPTY_RANGE:
{
nodecl_check_constraint_expression(n);
break;
}
case NODECL_UNKNOWN:
{
nodecl_check_UNKNOWN(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_alt_return(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FORTRAN_ALTERNATE_RETURN_ARGUMENT:
{
nodecl_check_FORTRAN_ALTERNATE_RETURN_ARGUMENT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_range_discrete(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_RANGE_DISCRETE:
{
nodecl_check_RANGE_DISCRETE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_parallel_execution(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_TASK:
{
nodecl_check_task_construct(n);
break;
}
case NODECL_OPEN_M_P_TASKYIELD:
{
nodecl_check_taskyield_construct(n);
break;
}
case NODECL_OPEN_M_P_SINGLE:
{
nodecl_check_single_construct(n);
break;
}
case NODECL_OPEN_M_P_CRITICAL:
{
nodecl_check_critical_construct(n);
break;
}
case NODECL_OPEN_M_P_PARALLEL:
{
nodecl_check_parallel_construct(n);
break;
}
case NODECL_OPEN_M_P_FOR:
case NODECL_OPEN_M_P_FOR_APPENDIX:
{
nodecl_check_omp_for_construct(n);
break;
}
case NODECL_OPEN_M_P_TASKLOOP:
{
nodecl_check_taskloop_construct(n);
break;
}
case NODECL_OPEN_M_P_ATOMIC:
{
nodecl_check_atomic_construct(n);
break;
}
case NODECL_OPEN_M_P_SECTIONS:
{
nodecl_check_sections_construct(n);
break;
}
case NODECL_OPEN_M_P_MASTER:
{
nodecl_check_master_construct(n);
break;
}
case NODECL_OPEN_M_P_WORKSHARE:
{
nodecl_check_workshare_construct(n);
break;
}
case NODECL_OPEN_M_P_SIMD:
case NODECL_OPEN_M_P_PARALLEL_SIMD_FOR:
case NODECL_OPEN_M_P_SIMD_FOR:
{
nodecl_check_simd_constructs(n);
break;
}
case NODECL_OPEN_M_P_TARGET_UPDATE:
case NODECL_OPEN_M_P_TARGET_DATA:
case NODECL_OPEN_M_P_TEAMS:
case NODECL_OPEN_M_P_DISTRIBUTE:
case NODECL_OPEN_M_P_TARGET:
{
nodecl_check_device_constructs(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_where_pair(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FORTRAN_WHERE_PAIR:
{
nodecl_check_FORTRAN_WHERE_PAIR(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_gxx_traits(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_GXX_TRAIT:
{
nodecl_check_GXX_TRAIT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_induction_var_expression(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ANALYSIS_INDUCTION_VAR_EXPR:
{
nodecl_check_ANALYSIS_INDUCTION_VAR_EXPR(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_construct_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_COMBINED_WITH_PARALLEL:
{
nodecl_check_OPEN_M_P_COMBINED_WITH_PARALLEL(n);
break;
}
case NODECL_OPEN_M_P_FUNCTION_TASK_PARSING_CONTEXT:
{
nodecl_check_OPEN_M_P_FUNCTION_TASK_PARSING_CONTEXT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_task_expression(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OMP_SS_TASK_EXPRESSION:
{
nodecl_check_OMP_SS_TASK_EXPRESSION(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_taskloop_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_NUM_TASKS:
{
nodecl_check_OPEN_M_P_NUM_TASKS(n);
break;
}
case NODECL_OPEN_M_P_GRAINSIZE:
{
nodecl_check_OPEN_M_P_GRAINSIZE(n);
break;
}
case NODECL_OMP_SS_CHUNKSIZE:
{
nodecl_check_OMP_SS_CHUNKSIZE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_c_cxx_expressions(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CONDITIONAL_EXPRESSION:
{
nodecl_check_CONDITIONAL_EXPRESSION(n);
break;
}
case NODECL_REFERENCE:
{
nodecl_check_REFERENCE(n);
break;
}
case NODECL_COMMA:
{
nodecl_check_COMMA(n);
break;
}
case NODECL_THROW:
{
nodecl_check_THROW(n);
break;
}
case NODECL_VIRTUAL_FUNCTION_CALL:
{
nodecl_check_VIRTUAL_FUNCTION_CALL(n);
break;
}
case NODECL_MUL_ASSIGNMENT:
{
nodecl_check_MUL_ASSIGNMENT(n);
break;
}
case NODECL_DIV_ASSIGNMENT:
{
nodecl_check_DIV_ASSIGNMENT(n);
break;
}
case NODECL_ADD_ASSIGNMENT:
{
nodecl_check_ADD_ASSIGNMENT(n);
break;
}
case NODECL_MINUS_ASSIGNMENT:
{
nodecl_check_MINUS_ASSIGNMENT(n);
break;
}
case NODECL_BITWISE_SHL_ASSIGNMENT:
{
nodecl_check_BITWISE_SHL_ASSIGNMENT(n);
break;
}
case NODECL_BITWISE_SHR_ASSIGNMENT:
{
nodecl_check_BITWISE_SHR_ASSIGNMENT(n);
break;
}
case NODECL_ARITHMETIC_SHR_ASSIGNMENT:
{
nodecl_check_ARITHMETIC_SHR_ASSIGNMENT(n);
break;
}
case NODECL_BITWISE_AND_ASSIGNMENT:
{
nodecl_check_BITWISE_AND_ASSIGNMENT(n);
break;
}
case NODECL_BITWISE_OR_ASSIGNMENT:
{
nodecl_check_BITWISE_OR_ASSIGNMENT(n);
break;
}
case NODECL_BITWISE_XOR_ASSIGNMENT:
{
nodecl_check_BITWISE_XOR_ASSIGNMENT(n);
break;
}
case NODECL_MOD_ASSIGNMENT:
{
nodecl_check_MOD_ASSIGNMENT(n);
break;
}
case NODECL_PREINCREMENT:
{
nodecl_check_PREINCREMENT(n);
break;
}
case NODECL_POSTINCREMENT:
{
nodecl_check_POSTINCREMENT(n);
break;
}
case NODECL_PREDECREMENT:
{
nodecl_check_PREDECREMENT(n);
break;
}
case NODECL_POSTDECREMENT:
{
nodecl_check_POSTDECREMENT(n);
break;
}
case NODECL_SIZEOF:
{
nodecl_check_SIZEOF(n);
break;
}
case NODECL_ALIGNOF:
{
nodecl_check_ALIGNOF(n);
break;
}
case NODECL_OFFSET:
{
nodecl_check_OFFSET(n);
break;
}
case NODECL_TYPEID:
{
nodecl_check_TYPEID(n);
break;
}
case NODECL_NEW:
{
nodecl_check_NEW(n);
break;
}
case NODECL_DELETE:
{
nodecl_check_DELETE(n);
break;
}
case NODECL_DELETE_ARRAY:
{
nodecl_check_DELETE_ARRAY(n);
break;
}
case NODECL_POINTER_TO_MEMBER:
{
nodecl_check_POINTER_TO_MEMBER(n);
break;
}
case NODECL_REAL_PART:
{
nodecl_check_REAL_PART(n);
break;
}
case NODECL_IMAG_PART:
{
nodecl_check_IMAG_PART(n);
break;
}
case NODECL_OFFSETOF:
{
nodecl_check_OFFSETOF(n);
break;
}
case NODECL_SHAPING:
{
nodecl_check_SHAPING(n);
break;
}
case NODECL_PSEUDO_DESTRUCTOR_NAME:
{
nodecl_check_PSEUDO_DESTRUCTOR_NAME(n);
break;
}
case NODECL_VECTOR_CONDITIONAL_EXPRESSION:
{
nodecl_check_VECTOR_CONDITIONAL_EXPRESSION(n);
break;
}
case NODECL_VLA_WILDCARD:
{
nodecl_check_VLA_WILDCARD(n);
break;
}
case NODECL_GXX_BUILTIN_ADDRESSOF:
{
nodecl_check_GXX_BUILTIN_ADDRESSOF(n);
break;
}
case NODECL_CXX_CAST:
case NODECL_CXX_NOEXCEPT:
case NODECL_CXX_DEP_NEW:
case NODECL_C99_FIELD_DESIGNATOR:
case NODECL_CXX_DEP_NAME_NESTED:
case NODECL_CXX_EXPLICIT_TYPE_CAST:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_CXX_DOT_PTR_MEMBER:
case NODECL_CXX_ARROW_PTR_MEMBER:
case NODECL_CXX_CLASS_MEMBER_ACCESS:
case NODECL_CXX_LAMBDA:
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
case NODECL_CXX_EQUAL_INITIALIZER:
case NODECL_CXX_BRACED_INITIALIZER:
case NODECL_CXX_ALIGNAS:
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
case NODECL_C99_DESIGNATED_INITIALIZER:
case NODECL_CXX_INITIALIZER:
case NODECL_CXX_DEP_FUNCTION_CALL:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_CXX_SIZEOF_PACK:
case NODECL_CXX_POSTFIX_INITIALIZER:
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_CXX_ARROW:
case NODECL_CXX_SIZEOF:
case NODECL_CXX_ALIGNOF:
case NODECL_C99_INDEX_DESIGNATOR:
case NODECL_CXX_DEP_DECLTYPE:
{
nodecl_check_cxx_expr_dependent_nodecls(n);
break;
}
case NODECL_CUDA_KERNEL_CALL:
{
nodecl_check_cuda_expressions(n);
break;
}
case NODECL_MASK_LITERAL:
{
nodecl_check_mask_expressions(n);
break;
}
case NODECL_CXX_VALUE_PACK_EXPANDED:
case NODECL_CXX_VALUE_PACK:
{
nodecl_check_cxx_pack(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_type_or_expr(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_TYPE:
{
nodecl_check_type(n);
break;
}
case NODECL_ARRAY_SUBSCRIPT:
case NODECL_DELETE:
case NODECL_C99_FIELD_DESIGNATOR:
case NODECL_SYMBOL:
case NODECL_VECTOR_BITWISE_XOR:
case NODECL_VECTOR_SUBSCRIPT:
case NODECL_PREPROCESSOR_LINE:
case NODECL_FUNCTION_CALL:
case NODECL_LOGICAL_AND:
case NODECL_CXX_EQUAL_INITIALIZER:
case NODECL_OMP_SS_TASK_EXPRESSION:
case NODECL_CXX_INITIALIZER:
case NODECL_VECTOR_CONDITIONAL_EXPRESSION:
case NODECL_IMAG_PART:
case NODECL_VECTOR_FMADD:
case NODECL_ANALYSIS_MAXIMUM:
case NODECL_SHAPING:
case NODECL_THROW:
case NODECL_DUMMY:
case NODECL_VECTOR_LOWER_OR_EQUAL_THAN:
case NODECL_VECTOR_CONVERSION:
case NODECL_INTEL_ASSUME:
case NODECL_CXX_CAST:
case NODECL_ANALYSIS_RANGE_INTERSECTION:
case NODECL_CXX_DEP_NAME_NESTED:
case NODECL_NEG:
case NODECL_VECTOR_ARITHMETIC_SHR:
case NODECL_CXX_CLASS_MEMBER_ACCESS:
case NODECL_CXX_LAMBDA:
case NODECL_OFFSETOF:
case NODECL_NEW:
case NODECL_VECTOR_MASK_OR:
case NODECL_FORTRAN_BIND_C:
case NODECL_GXX_TRAIT:
case NODECL_VECTOR_SCATTER:
case NODECL_MOD_ASSIGNMENT:
case NODECL_DIFFERENT:
case NODECL_VECTOR_MASK_AND:
case NODECL_CXX_ALIGNOF:
case NODECL_LOWER_OR_EQUAL_THAN:
case NODECL_SIZEOF:
case NODECL_COMPOUND_EXPRESSION:
case NODECL_VECTOR_STORE:
case NODECL_ADD_ASSIGNMENT:
case NODECL_VECTOR_GATHER:
case NODECL_LOWER_THAN:
case NODECL_VECTOR_SINCOS:
case NODECL_BITWISE_AND:
case NODECL_LOGICAL_OR:
case NODECL_FORTRAN_BOZ_LITERAL:
case NODECL_COMPLEX_LITERAL:
case NODECL_BITWISE_XOR:
case NODECL_BITWISE_NOT:
case NODECL_MINUS:
case NODECL_MINUS_ASSIGNMENT:
case NODECL_VECTOR_LANE_ID:
case NODECL_BOOLEAN_LITERAL:
case NODECL_POWER:
case NODECL_FORTRAN_USE:
case NODECL_EQUAL:
case NODECL_CONDITIONAL_EXPRESSION:
case NODECL_CONCAT:
case NODECL_VECTOR_LOGICAL_AND:
case NODECL_CLASS_MEMBER_ACCESS:
case NODECL_REFERENCE:
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_VECTOR_FABS:
case NODECL_FORTRAN_HOLLERITH:
case NODECL_VLA_WILDCARD:
case NODECL_PREINCREMENT:
case NODECL_TYPEID:
case NODECL_ANALYSIS_PLUS_INFINITY:
case NODECL_OFFSET:
case NODECL_CXX_SIZEOF_PACK:
case NODECL_UNKNOWN:
case NODECL_ANALYSIS_RANGE_UNION:
case NODECL_ARITHMETIC_SHR:
case NODECL_CXX_VALUE_PACK_EXPANDED:
case NODECL_VECTOR_EQUAL:
case NODECL_ADD:
case NODECL_ANALYSIS_MINUS_INFINITY:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_C99_DESIGNATED_INITIALIZER:
case NODECL_POSTINCREMENT:
case NODECL_VECTOR_MINUS:
case NODECL_VECTOR_BITWISE_NOT:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_STRING_LITERAL:
case NODECL_VECTOR_MASK_NOT:
case NODECL_BITWISE_OR:
case NODECL_CXX_POSTFIX_INITIALIZER:
case NODECL_TEXT:
case NODECL_CXX_DEP_DECLTYPE:
case NODECL_MUL:
case NODECL_VECTOR_LOAD:
case NODECL_CXX_SIZEOF:
case NODECL_VECTOR_PROMOTION:
case NODECL_VECTOR_GREATER_THAN:
case NODECL_GREATER_THAN:
case NODECL_BITWISE_XOR_ASSIGNMENT:
case NODECL_VECTOR_BITWISE_SHR:
case NODECL_BITWISE_SHL_ASSIGNMENT:
case NODECL_C99_INDEX_DESIGNATOR:
case NODECL_VECTOR_BITWISE_OR:
case NODECL_POSTDECREMENT:
case NODECL_CONTEXT:
case NODECL_VECTOR_BITWISE_SHL:
case NODECL_OMP_SS_TASK_CALL:
case NODECL_VECTOR_CAST:
case NODECL_DELETE_ARRAY:
case NODECL_ANALYSIS_EMPTY_RANGE:
case NODECL_ANALYSIS_PHI:
case NODECL_CXX_ALIGNAS:
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
case NODECL_VIRTUAL_FUNCTION_CALL:
case NODECL_VECTOR_BITWISE_AND:
case NODECL_MASK_LITERAL:
case NODECL_VECTOR_DIV:
case NODECL_BITWISE_OR_ASSIGNMENT:
case NODECL_VECTOR_RCP:
case NODECL_CXX_VALUE_PACK:
case NODECL_VECTOR_MASK_XOR:
case NODECL_VECTOR_MASK_ASSIGNMENT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_VECTOR_FMMINUS:
case NODECL_GREATER_OR_EQUAL_THAN:
case NODECL_VECTOR_GREATER_OR_EQUAL_THAN:
case NODECL_POINTER_TO_MEMBER:
case NODECL_VECTOR_MASK_CONVERSION:
case NODECL_VECTOR_LOOP:
case NODECL_VECTOR_ASSIGNMENT:
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
case NODECL_VECTOR_MOD:
case NODECL_VECTOR_REDUCTION_ADD:
case NODECL_BITWISE_SHR:
case NODECL_VECTOR_ADD:
case NODECL_FLOATING_LITERAL:
case NODECL_GCC_ASM_SPEC:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_VECTOR_LOGICAL_OR:
case NODECL_OBJECT_INIT:
case NODECL_VECTOR_ALIGN_RIGHT:
case NODECL_VECTOR_NEG:
case NODECL_BITWISE_SHL:
case NODECL_ASSIGNMENT:
case NODECL_MUL_ASSIGNMENT:
case NODECL_VECTOR_DIFFERENT:
case NODECL_BITWISE_SHR_ASSIGNMENT:
case NODECL_VECTOR_RSQRT:
case NODECL_FORTRAN_EQUIVALENCE:
case NODECL_VECTOR_MUL:
case NODECL_CUDA_KERNEL_CALL:
case NODECL_VECTOR_LOGICAL_NOT:
case NODECL_CXX_EXPLICIT_TYPE_CAST:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_RANGE:
case NODECL_ANALYSIS_MINIMUM:
case NODECL_VERBATIM:
case NODECL_DEREFERENCE:
case NODECL_DIV:
case NODECL_CXX_ARROW_PTR_MEMBER:
case NODECL_VECTOR_REDUCTION_MINUS:
case NODECL_VECTOR_SQRT:
case NODECL_DIV_ASSIGNMENT:
case NODECL_CXX_BRACED_INITIALIZER:
case NODECL_MOD:
case NODECL_VECTOR_REDUCTION_MUL:
case NODECL_PSEUDO_DESTRUCTOR_NAME:
case NODECL_CXX_DEP_NEW:
case NODECL_VECTOR_MASK_AND_2_NOT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_VECTOR_FUNCTION_CALL:
case NODECL_ERR_EXPR:
case NODECL_NOEXCEPT_IMPLICIT_TRUE:
case NODECL_SOURCE_COMMENT:
case NODECL_FORTRAN_USE_ONLY:
case NODECL_ASM_DEFINITION:
case NODECL_VECTOR_LITERAL:
case NODECL_ALIGNOF:
case NODECL_GXX_BUILTIN_ADDRESSOF:
case NODECL_MULTI_EXPRESSION:
case NODECL_CXX_DOT_PTR_MEMBER:
case NODECL_VECTOR_LOWER_THAN:
case NODECL_PARENTHESIZED_EXPRESSION:
case NODECL_CONVERSION:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_ANALYSIS_RANGE_SUB:
case NODECL_ARITHMETIC_SHR_ASSIGNMENT:
case NODECL_INTEGER_LITERAL:
case NODECL_LOGICAL_NOT:
case NODECL_STRUCTURED_VALUE:
case NODECL_FORTRAN_DATA:
case NODECL_CXX_DEP_FUNCTION_CALL:
case NODECL_CXX_NOEXCEPT:
case NODECL_PREDECREMENT:
case NODECL_VECTOR_PREFETCH:
case NODECL_COMMA:
case NODECL_REAL_PART:
case NODECL_VECTOR_MASK_AND_1_NOT:
case NODECL_PLUS:
case NODECL_BITWISE_AND_ASSIGNMENT:
case NODECL_CXX_ARROW:
{
nodecl_check_expression(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_gcc_asm_operand(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_GCC_ASM_OPERAND:
{
nodecl_check_GCC_ASM_OPERAND(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_assert_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ANALYSIS_ASSERT:
{
nodecl_check_ANALYSIS_ASSERT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_literal(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_INTEGER_LITERAL:
{
nodecl_check_INTEGER_LITERAL(n);
break;
}
case NODECL_FLOATING_LITERAL:
{
nodecl_check_FLOATING_LITERAL(n);
break;
}
case NODECL_COMPLEX_LITERAL:
{
nodecl_check_COMPLEX_LITERAL(n);
break;
}
case NODECL_BOOLEAN_LITERAL:
{
nodecl_check_BOOLEAN_LITERAL(n);
break;
}
case NODECL_STRING_LITERAL:
{
nodecl_check_string_literal(n);
break;
}
case NODECL_STRUCTURED_VALUE:
{
nodecl_check_structured_value(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_statement(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FORTRAN_ALTERNATE_RETURN_STATEMENT:
case NODECL_CATCH_HANDLER:
case NODECL_INTEL_ASSUME:
case NODECL_CHECKPOINT_STORE:
case NODECL_IF_ELSE_STATEMENT:
case NODECL_OPEN_M_P_BARRIER_FULL:
case NODECL_PREPROCESSOR_LINE:
case NODECL_CASE_STATEMENT:
case NODECL_EMPTY_STATEMENT:
case NODECL_OMP_SS_REGISTER:
case NODECL_WHILE_STATEMENT:
case NODECL_FORTRAN_IO_STATEMENT:
case NODECL_PRAGMA_CUSTOM_STATEMENT:
case NODECL_FORTRAN_DEALLOCATE_STATEMENT:
case NODECL_OPEN_M_P_SECTIONS:
case NODECL_BREAK_STATEMENT:
case NODECL_OMP_SS_LOOP:
case NODECL_ASM_DEFINITION:
case NODECL_FORTRAN_CLOSE_STATEMENT:
case NODECL_COMPOUND_STATEMENT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_FORTRAN_LABEL_ASSIGN_STATEMENT:
case NODECL_CXX_FOR_RANGED:
case NODECL_DO_STATEMENT:
case NODECL_FOR_STATEMENT:
case NODECL_FORTRAN_PAUSE_STATEMENT:
case NODECL_OPEN_M_P_TASK:
case NODECL_OPEN_M_P_TEAMS:
case NODECL_CHECKPOINT_SHUTDOWN:
case NODECL_OPEN_M_P_TASKYIELD:
case NODECL_ANALYSIS_ASSERT:
case NODECL_OPEN_M_P_FOR_APPENDIX:
case NODECL_SWITCH_STATEMENT:
case NODECL_GXX_TRAIT:
case NODECL_FORTRAN_ALLOCATE_STATEMENT:
case NODECL_OPEN_M_P_FLUSH_MEMORY:
case NODECL_GCC_ASM_SPEC:
case NODECL_OPEN_M_P_PARALLEL_SIMD_FOR:
case NODECL_OPEN_M_P_TASKGROUP:
case NODECL_GOTO_STATEMENT:
case NODECL_CHECKPOINT_LOAD:
case NODECL_FORTRAN_ASSIGNED_GOTO_STATEMENT:
case NODECL_OPEN_M_P_SIMD:
case NODECL_ERR_STATEMENT:
case NODECL_OPEN_M_P_ATOMIC:
case NODECL_FORTRAN_FORALL:
case NODECL_FORTRAN_PRINT_STATEMENT:
case NODECL_OPEN_M_P_SIMD_FOR:
case NODECL_OMP_SS_UNREGISTER:
case NODECL_OPEN_M_P_BARRIER_WAIT:
case NODECL_CONTINUE_STATEMENT:
case NODECL_CXX_STATIC_ASSERT:
case NODECL_VERBATIM:
case NODECL_FORTRAN_ARITHMETIC_IF_STATEMENT:
case NODECL_FORTRAN_READ_STATEMENT:
case NODECL_FORTRAN_ENTRY_STATEMENT:
case NODECL_OPEN_M_P_TASKWAIT:
case NODECL_FORTRAN_WHERE:
case NODECL_FORTRAN_COMPUTED_GOTO_STATEMENT:
case NODECL_RETURN_STATEMENT:
case NODECL_OPEN_M_P_MASTER:
case NODECL_DEFAULT_STATEMENT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_PRAGMA_CUSTOM_DECLARATION:
case NODECL_SOURCE_COMMENT:
case NODECL_OPEN_M_P_PARALLEL:
case NODECL_OPEN_M_P_BARRIER_SIGNAL:
case NODECL_EXPRESSION_STATEMENT:
case NODECL_TRY_BLOCK:
case NODECL_FORTRAN_NULLIFY_STATEMENT:
case NODECL_OPEN_M_P_FOR:
case NODECL_CHECKPOINT_INIT:
case NODECL_FORTRAN_OPEN_STATEMENT:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_OPEN_M_P_TARGET_UPDATE:
case NODECL_OPEN_M_P_TASKLOOP:
case NODECL_FORTRAN_STOP_STATEMENT:
case NODECL_OMP_SS_RELEASE:
case NODECL_LABELED_STATEMENT:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_OPEN_M_P_TARGET:
case NODECL_FORTRAN_WRITE_STATEMENT:
case NODECL_OPEN_M_P_DISTRIBUTE:
case NODECL_OPEN_M_P_WORKSHARE:
case NODECL_OPEN_M_P_SINGLE:
case NODECL_PRAGMA_CUSTOM_DIRECTIVE:
case NODECL_OPEN_M_P_TARGET_DATA:
case NODECL_TEXT:
case NODECL_OPEN_M_P_CRITICAL:
{
nodecl_check_statement_but_object_init(n);
break;
}
case NODECL_OBJECT_INIT:
{
nodecl_check_object_init(n);
break;
}
case NODECL_CXX_EXPLICIT_INSTANTIATION_DECL:
case NODECL_CXX_USING_NAMESPACE:
case NODECL_CXX_IMPLICIT_INSTANTIATION:
case NODECL_CXX_DEF:
case NODECL_CXX_EXPLICIT_INSTANTIATION_DEF:
case NODECL_CXX_PARSE_LATER:
case NODECL_CXX_USING_DECL:
case NODECL_CXX_DECL:
{
nodecl_check_cxx_decl(n);
break;
}
case NODECL_CONTEXT:
{
nodecl_check_context(n);
break;
}
case NODECL_VECTOR_FUNCTION_CODE:
case NODECL_FUNCTION_CODE:
case NODECL_TEMPLATE_FUNCTION_CODE:
{
nodecl_check_function_code(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_deps_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_DEP_IN:
{
nodecl_check_OPEN_M_P_DEP_IN(n);
break;
}
case NODECL_OPEN_M_P_DEP_OUT:
{
nodecl_check_OPEN_M_P_DEP_OUT(n);
break;
}
case NODECL_OPEN_M_P_DEP_INOUT:
{
nodecl_check_OPEN_M_P_DEP_INOUT(n);
break;
}
case NODECL_OMP_SS_DEP_CONCURRENT:
{
nodecl_check_OMP_SS_DEP_CONCURRENT(n);
break;
}
case NODECL_OMP_SS_DEP_COMMUTATIVE:
{
nodecl_check_OMP_SS_DEP_COMMUTATIVE(n);
break;
}
case NODECL_OMP_SS_DEP_REDUCTION:
{
nodecl_check_OMP_SS_DEP_REDUCTION(n);
break;
}
case NODECL_OMP_SS_DEP_WEAK_REDUCTION:
{
nodecl_check_OMP_SS_DEP_WEAK_REDUCTION(n);
break;
}
case NODECL_OMP_SS_DEP_IN_PRIVATE:
{
nodecl_check_OMP_SS_DEP_IN_PRIVATE(n);
break;
}
case NODECL_OMP_SS_DEP_WEAK_IN:
{
nodecl_check_OMP_SS_DEP_WEAK_IN(n);
break;
}
case NODECL_OMP_SS_DEP_WEAK_OUT:
{
nodecl_check_OMP_SS_DEP_WEAK_OUT(n);
break;
}
case NODECL_OMP_SS_DEP_WEAK_INOUT:
{
nodecl_check_OMP_SS_DEP_WEAK_INOUT(n);
break;
}
case NODECL_OMP_SS_DEP_WEAK_COMMUTATIVE:
{
nodecl_check_OMP_SS_DEP_WEAK_COMMUTATIVE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_type(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_TYPE:
{
nodecl_check_TYPE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_pragma_custom_clause(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_PRAGMA_CUSTOM_CLAUSE:
{
nodecl_check_PRAGMA_CUSTOM_CLAUSE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_cxx_decl(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_DECL:
{
nodecl_check_CXX_DECL(n);
break;
}
case NODECL_CXX_DEF:
{
nodecl_check_CXX_DEF(n);
break;
}
case NODECL_CXX_EXPLICIT_INSTANTIATION_DEF:
{
nodecl_check_CXX_EXPLICIT_INSTANTIATION_DEF(n);
break;
}
case NODECL_CXX_EXPLICIT_INSTANTIATION_DECL:
{
nodecl_check_CXX_EXPLICIT_INSTANTIATION_DECL(n);
break;
}
case NODECL_CXX_USING_NAMESPACE:
{
nodecl_check_CXX_USING_NAMESPACE(n);
break;
}
case NODECL_CXX_USING_DECL:
{
nodecl_check_CXX_USING_DECL(n);
break;
}
case NODECL_CXX_PARSE_LATER:
{
nodecl_check_CXX_PARSE_LATER(n);
break;
}
case NODECL_CXX_IMPLICIT_INSTANTIATION:
{
nodecl_check_CXX_IMPLICIT_INSTANTIATION(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_template_function_code(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_TEMPLATE_FUNCTION_CODE:
{
nodecl_check_TEMPLATE_FUNCTION_CODE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_verbatim(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_VERBATIM:
{
nodecl_check_VERBATIM(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_fortran_implied_do(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FORTRAN_IMPLIED_DO:
{
nodecl_check_FORTRAN_IMPLIED_DO(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_exec_environment(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_PRIVATE:
case NODECL_OPEN_M_P_AUTO:
case NODECL_OPEN_M_P_FIRSTPRIVATE:
case NODECL_OPEN_M_P_PRIVATE_INIT:
case NODECL_OPEN_M_P_SHARED:
case NODECL_OPEN_M_P_FIRST_LASTPRIVATE:
case NODECL_OPEN_M_P_THREADPRIVATE:
case NODECL_OPEN_M_P_TASK_REDUCTION:
case NODECL_OPEN_M_P_REDUCTION:
case NODECL_OPEN_M_P_IN_REDUCTION:
case NODECL_OPEN_M_P_LASTPRIVATE:
{
nodecl_check_omp_data_sharings_info(n);
break;
}
case NODECL_OPEN_M_P_FUNCTION_TASK_PARSING_CONTEXT:
case NODECL_OPEN_M_P_COMBINED_WITH_PARALLEL:
{
nodecl_check_omp_construct_info(n);
break;
}
case NODECL_OPEN_M_P_BARRIER_AT_END:
{
nodecl_check_omp_sync_info(n);
break;
}
case NODECL_OPEN_M_P_FLUSH_AT_EXIT:
case NODECL_OPEN_M_P_FLUSH_AT_ENTRY:
case NODECL_OPEN_M_P_NO_FLUSH:
{
nodecl_check_omp_memory_info(n);
break;
}
case NODECL_OPEN_M_P_SCHEDULE:
case NODECL_OPEN_M_P_DIST_SCHEDULE:
{
nodecl_check_omp_loop_info(n);
break;
}
case NODECL_OPEN_M_P_NUM_TASKS:
case NODECL_OPEN_M_P_GRAINSIZE:
case NODECL_OMP_SS_CHUNKSIZE:
{
nodecl_check_omp_taskloop_info(n);
break;
}
case NODECL_OPEN_M_P_DEP_IN:
case NODECL_OPEN_M_P_DEP_INOUT:
case NODECL_OMP_SS_DEP_WEAK_INOUT:
case NODECL_OMP_SS_DEP_WEAK_IN:
case NODECL_OMP_SS_DEP_CONCURRENT:
case NODECL_OMP_SS_DEP_WEAK_COMMUTATIVE:
case NODECL_OMP_SS_DEP_COMMUTATIVE:
case NODECL_OPEN_M_P_DEP_OUT:
case NODECL_OMP_SS_DEP_WEAK_REDUCTION:
case NODECL_OMP_SS_DEP_IN_PRIVATE:
case NODECL_OMP_SS_DEP_WEAK_OUT:
case NODECL_OMP_SS_DEP_REDUCTION:
{
nodecl_check_omp_deps_info(n);
break;
}
case NODECL_OPEN_M_P_FINAL:
case NODECL_OPEN_M_P_IF:
case NODECL_OMP_SS_WAIT:
case NODECL_OPEN_M_P_MERGEABLE:
case NODECL_OPEN_M_P_PRIORITY:
case NODECL_OPEN_M_P_UNTIED:
{
nodecl_check_omp_execution_control(n);
break;
}
case NODECL_OPEN_M_P_CRITICAL_NAME:
{
nodecl_check_omp_critical_info(n);
break;
}
case NODECL_OPEN_M_P_PREFETCH:
case NODECL_OPEN_M_P_NO_PREFETCH:
case NODECL_OPEN_M_P_UNIFORM:
case NODECL_OPEN_M_P_SUITABLE:
case NODECL_OPEN_M_P_NONTEMPORAL:
case NODECL_OPEN_M_P_SIMD_REDUCTION:
case NODECL_OPEN_M_P_UNROLL:
case NODECL_OPEN_M_P_VECTOR_LENGTH_FOR:
case NODECL_OPEN_M_P_UNROLL_AND_JAM:
case NODECL_OPEN_M_P_MASK:
case NODECL_OPEN_M_P_VECTOR_LENGTH:
case NODECL_OPEN_M_P_OVERLAP:
case NODECL_OPEN_M_P_NO_MASK:
case NODECL_OPEN_M_P_LINEAR:
case NODECL_OPEN_M_P_ALIGNED:
{
nodecl_check_omp_simd_info(n);
break;
}
case NODECL_OPEN_M_P_NUM_TEAMS:
case NODECL_OPEN_M_P_DEVICE:
case NODECL_OPEN_M_P_MOTION_TO:
case NODECL_OPEN_M_P_THREAD_LIMIT:
case NODECL_OPEN_M_P_MAP_ALLOC:
case NODECL_OPEN_M_P_MAP_TO:
case NODECL_OPEN_M_P_MAP_FROM:
case NODECL_OPEN_M_P_MAP_TO_FROM:
case NODECL_OPEN_M_P_TARGET_TASK_UNDEFERRED:
case NODECL_OPEN_M_P_MOTION_FROM:
{
nodecl_check_omp_device_info(n);
break;
}
case NODECL_OPEN_M_P_TASK_IS_TASKWAIT:
case NODECL_OMP_SS_TASK_IS_TASK_CALL:
case NODECL_OMP_SS_TASK_IS_LOOP:
{
nodecl_check_omp_task_flags(n);
break;
}
case NODECL_OMP_SS_ALLOCA:
{
nodecl_check_OMP_SS_ALLOCA(n);
break;
}
case NODECL_OMP_SS_SHARED_AND_ALLOCA:
{
nodecl_check_OMP_SS_SHARED_AND_ALLOCA(n);
break;
}
case NODECL_OMP_SS_WEAK_REDUCTION:
{
nodecl_check_OMP_SS_WEAK_REDUCTION(n);
break;
}
case NODECL_OMP_SS_COST:
{
nodecl_check_OMP_SS_COST(n);
break;
}
case NODECL_OMP_SS_TASK_LABEL:
{
nodecl_check_OMP_SS_TASK_LABEL(n);
break;
}
case NODECL_OMP_SS_TARGET:
{
nodecl_check_ompss_device_info(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_parallel_statements(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_ATOMIC:
case NODECL_OPEN_M_P_FOR_APPENDIX:
case NODECL_OPEN_M_P_SECTIONS:
case NODECL_OPEN_M_P_TARGET:
case NODECL_OPEN_M_P_FOR:
case NODECL_OPEN_M_P_TASKYIELD:
case NODECL_OPEN_M_P_PARALLEL_SIMD_FOR:
case NODECL_OPEN_M_P_TASK:
case NODECL_OPEN_M_P_MASTER:
case NODECL_OPEN_M_P_TEAMS:
case NODECL_OPEN_M_P_WORKSHARE:
case NODECL_OPEN_M_P_SINGLE:
case NODECL_OPEN_M_P_SIMD_FOR:
case NODECL_OPEN_M_P_TARGET_UPDATE:
case NODECL_OPEN_M_P_PARALLEL:
case NODECL_OPEN_M_P_SIMD:
case NODECL_OPEN_M_P_TARGET_DATA:
case NODECL_OPEN_M_P_TASKLOOP:
case NODECL_OPEN_M_P_DISTRIBUTE:
case NODECL_OPEN_M_P_CRITICAL:
{
nodecl_check_parallel_execution(n);
break;
}
case NODECL_OPEN_M_P_TASKGROUP:
case NODECL_OPEN_M_P_BARRIER_FULL:
case NODECL_OPEN_M_P_FLUSH_MEMORY:
case NODECL_OPEN_M_P_BARRIER_SIGNAL:
case NODECL_OPEN_M_P_TASKWAIT:
case NODECL_OPEN_M_P_BARRIER_WAIT:
{
nodecl_check_synchronization(n);
break;
}
case NODECL_OMP_SS_LOOP:
{
nodecl_check_oss_specific_constructs(n);
break;
}
case NODECL_OMP_SS_UNREGISTER:
case NODECL_OMP_SS_REGISTER:
{
nodecl_check_data_coordination_constructs(n);
break;
}
case NODECL_OMP_SS_RELEASE:
{
nodecl_check_release_deps_construct(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_c_cxx_only_statements(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_TRY_BLOCK:
{
nodecl_check_TRY_BLOCK(n);
break;
}
case NODECL_CXX_FOR_RANGED:
{
nodecl_check_CXX_FOR_RANGED(n);
break;
}
case NODECL_CATCH_HANDLER:
{
nodecl_check_CATCH_HANDLER(n);
break;
}
case NODECL_CXX_STATIC_ASSERT:
{
nodecl_check_CXX_STATIC_ASSERT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_simd_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_ALIGNED:
{
nodecl_check_OPEN_M_P_ALIGNED(n);
break;
}
case NODECL_OPEN_M_P_VECTOR_LENGTH:
{
nodecl_check_OPEN_M_P_VECTOR_LENGTH(n);
break;
}
case NODECL_OPEN_M_P_VECTOR_LENGTH_FOR:
{
nodecl_check_OPEN_M_P_VECTOR_LENGTH_FOR(n);
break;
}
case NODECL_OPEN_M_P_UNIFORM:
{
nodecl_check_OPEN_M_P_UNIFORM(n);
break;
}
case NODECL_OPEN_M_P_LINEAR:
{
nodecl_check_OPEN_M_P_LINEAR(n);
break;
}
case NODECL_OPEN_M_P_SUITABLE:
{
nodecl_check_OPEN_M_P_SUITABLE(n);
break;
}
case NODECL_OPEN_M_P_OVERLAP:
{
nodecl_check_OPEN_M_P_OVERLAP(n);
break;
}
case NODECL_OPEN_M_P_UNROLL:
{
nodecl_check_OPEN_M_P_UNROLL(n);
break;
}
case NODECL_OPEN_M_P_UNROLL_AND_JAM:
{
nodecl_check_OPEN_M_P_UNROLL_AND_JAM(n);
break;
}
case NODECL_OPEN_M_P_NONTEMPORAL:
{
nodecl_check_OPEN_M_P_NONTEMPORAL(n);
break;
}
case NODECL_OPEN_M_P_PREFETCH:
{
nodecl_check_OPEN_M_P_PREFETCH(n);
break;
}
case NODECL_OPEN_M_P_NO_PREFETCH:
{
nodecl_check_OPEN_M_P_NO_PREFETCH(n);
break;
}
case NODECL_OPEN_M_P_MASK:
{
nodecl_check_OPEN_M_P_MASK(n);
break;
}
case NODECL_OPEN_M_P_NO_MASK:
{
nodecl_check_OPEN_M_P_NO_MASK(n);
break;
}
case NODECL_OPEN_M_P_SIMD_REDUCTION:
{
nodecl_check_OPEN_M_P_SIMD_REDUCTION(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_assert_directive(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ANALYSIS_ASSERT_DECL:
{
nodecl_check_ANALYSIS_ASSERT_DECL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_explicit_capture(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_CAPTURE_COPY:
{
nodecl_check_CXX_CAPTURE_COPY(n);
break;
}
case NODECL_CXX_CAPTURE_REFERENCE:
{
nodecl_check_CXX_CAPTURE_REFERENCE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_function_form(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_FUNCTION_FORM_TEMPLATE_ID:
{
nodecl_check_CXX_FUNCTION_FORM_TEMPLATE_ID(n);
break;
}
case NODECL_CXX_FUNCTION_FORM_IMPLICIT:
{
nodecl_check_CXX_FUNCTION_FORM_IMPLICIT(n);
break;
}
case NODECL_CXX_FUNCTION_FORM_BINARY_INFIX:
{
nodecl_check_CXX_FUNCTION_FORM_BINARY_INFIX(n);
break;
}
case NODECL_CXX_FUNCTION_FORM_UNARY_PREFIX:
{
nodecl_check_CXX_FUNCTION_FORM_UNARY_PREFIX(n);
break;
}
case NODECL_CXX_FUNCTION_FORM_UNARY_POSTFIX:
{
nodecl_check_CXX_FUNCTION_FORM_UNARY_POSTFIX(n);
break;
}
case NODECL_CXX_FUNCTION_FORM_DEFAULT_INIT:
{
nodecl_check_CXX_FUNCTION_FORM_DEFAULT_INIT(n);
break;
}
case NODECL_CXX_FUNCTION_FORM_DEFAULT_INIT_BRACED:
{
nodecl_check_CXX_FUNCTION_FORM_DEFAULT_INIT_BRACED(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_for_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_FOR:
{
nodecl_check_OPEN_M_P_FOR(n);
break;
}
case NODECL_OPEN_M_P_FOR_APPENDIX:
{
nodecl_check_OPEN_M_P_FOR_APPENDIX(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_asm_definition(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ASM_DEFINITION:
{
nodecl_check_ASM_DEFINITION(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_device_constructs_top_level(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_DECLARE_TARGET:
{
nodecl_check_OPEN_M_P_DECLARE_TARGET(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_taskloop_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_TASKLOOP:
{
nodecl_check_OPEN_M_P_TASKLOOP(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_release_deps_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OMP_SS_RELEASE:
{
nodecl_check_OMP_SS_RELEASE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_task_flags(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_TASK_IS_TASKWAIT:
{
nodecl_check_OPEN_M_P_TASK_IS_TASKWAIT(n);
break;
}
case NODECL_OMP_SS_TASK_IS_LOOP:
{
nodecl_check_OMP_SS_TASK_IS_LOOP(n);
break;
}
case NODECL_OMP_SS_TASK_IS_TASK_CALL:
{
nodecl_check_OMP_SS_TASK_IS_TASK_CALL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_task_construct(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_TASK:
{
nodecl_check_OPEN_M_P_TASK(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_reach_def_expression(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ANALYSIS_REACH_DEF_EXPR:
{
nodecl_check_ANALYSIS_REACH_DEF_EXPR(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_sync_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_BARRIER_AT_END:
{
nodecl_check_OPEN_M_P_BARRIER_AT_END(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_device_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_DEVICE:
{
nodecl_check_OPEN_M_P_DEVICE(n);
break;
}
case NODECL_OPEN_M_P_MAP_TO:
{
nodecl_check_OPEN_M_P_MAP_TO(n);
break;
}
case NODECL_OPEN_M_P_MAP_FROM:
{
nodecl_check_OPEN_M_P_MAP_FROM(n);
break;
}
case NODECL_OPEN_M_P_MAP_TO_FROM:
{
nodecl_check_OPEN_M_P_MAP_TO_FROM(n);
break;
}
case NODECL_OPEN_M_P_MAP_ALLOC:
{
nodecl_check_OPEN_M_P_MAP_ALLOC(n);
break;
}
case NODECL_OPEN_M_P_MOTION_TO:
{
nodecl_check_OPEN_M_P_MOTION_TO(n);
break;
}
case NODECL_OPEN_M_P_MOTION_FROM:
{
nodecl_check_OPEN_M_P_MOTION_FROM(n);
break;
}
case NODECL_OPEN_M_P_NUM_TEAMS:
{
nodecl_check_OPEN_M_P_NUM_TEAMS(n);
break;
}
case NODECL_OPEN_M_P_THREAD_LIMIT:
{
nodecl_check_OPEN_M_P_THREAD_LIMIT(n);
break;
}
case NODECL_OPEN_M_P_TARGET_TASK_UNDEFERRED:
{
nodecl_check_OPEN_M_P_TARGET_TASK_UNDEFERRED(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_argument(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ARRAY_SUBSCRIPT:
case NODECL_DELETE:
case NODECL_C99_FIELD_DESIGNATOR:
case NODECL_SYMBOL:
case NODECL_VECTOR_BITWISE_XOR:
case NODECL_VECTOR_SUBSCRIPT:
case NODECL_PREPROCESSOR_LINE:
case NODECL_FUNCTION_CALL:
case NODECL_LOGICAL_AND:
case NODECL_CXX_EQUAL_INITIALIZER:
case NODECL_OMP_SS_TASK_EXPRESSION:
case NODECL_CXX_INITIALIZER:
case NODECL_VECTOR_CONDITIONAL_EXPRESSION:
case NODECL_IMAG_PART:
case NODECL_VECTOR_FMADD:
case NODECL_ANALYSIS_MAXIMUM:
case NODECL_SHAPING:
case NODECL_THROW:
case NODECL_DUMMY:
case NODECL_VECTOR_LOWER_OR_EQUAL_THAN:
case NODECL_VECTOR_CONVERSION:
case NODECL_INTEL_ASSUME:
case NODECL_CXX_CAST:
case NODECL_ANALYSIS_RANGE_INTERSECTION:
case NODECL_CXX_DEP_NAME_NESTED:
case NODECL_NEG:
case NODECL_VECTOR_ARITHMETIC_SHR:
case NODECL_CXX_CLASS_MEMBER_ACCESS:
case NODECL_CXX_LAMBDA:
case NODECL_OFFSETOF:
case NODECL_NEW:
case NODECL_VECTOR_MASK_OR:
case NODECL_FORTRAN_BIND_C:
case NODECL_GXX_TRAIT:
case NODECL_VECTOR_SCATTER:
case NODECL_MOD_ASSIGNMENT:
case NODECL_DIFFERENT:
case NODECL_VECTOR_MASK_AND:
case NODECL_CXX_ALIGNOF:
case NODECL_LOWER_OR_EQUAL_THAN:
case NODECL_SIZEOF:
case NODECL_COMPOUND_EXPRESSION:
case NODECL_VECTOR_STORE:
case NODECL_ADD_ASSIGNMENT:
case NODECL_VECTOR_GATHER:
case NODECL_LOWER_THAN:
case NODECL_VECTOR_SINCOS:
case NODECL_BITWISE_AND:
case NODECL_LOGICAL_OR:
case NODECL_FORTRAN_BOZ_LITERAL:
case NODECL_COMPLEX_LITERAL:
case NODECL_BITWISE_XOR:
case NODECL_BITWISE_NOT:
case NODECL_MINUS:
case NODECL_MINUS_ASSIGNMENT:
case NODECL_VECTOR_LANE_ID:
case NODECL_BOOLEAN_LITERAL:
case NODECL_POWER:
case NODECL_FORTRAN_USE:
case NODECL_EQUAL:
case NODECL_CONDITIONAL_EXPRESSION:
case NODECL_CONCAT:
case NODECL_VECTOR_LOGICAL_AND:
case NODECL_CLASS_MEMBER_ACCESS:
case NODECL_REFERENCE:
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_VECTOR_FABS:
case NODECL_FORTRAN_HOLLERITH:
case NODECL_VLA_WILDCARD:
case NODECL_PREINCREMENT:
case NODECL_TYPEID:
case NODECL_ANALYSIS_PLUS_INFINITY:
case NODECL_OFFSET:
case NODECL_CXX_SIZEOF_PACK:
case NODECL_UNKNOWN:
case NODECL_ANALYSIS_RANGE_UNION:
case NODECL_ARITHMETIC_SHR:
case NODECL_CXX_VALUE_PACK_EXPANDED:
case NODECL_VECTOR_EQUAL:
case NODECL_ADD:
case NODECL_ANALYSIS_MINUS_INFINITY:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_C99_DESIGNATED_INITIALIZER:
case NODECL_POSTINCREMENT:
case NODECL_VECTOR_MINUS:
case NODECL_VECTOR_BITWISE_NOT:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_STRING_LITERAL:
case NODECL_VECTOR_MASK_NOT:
case NODECL_BITWISE_OR:
case NODECL_CXX_POSTFIX_INITIALIZER:
case NODECL_TEXT:
case NODECL_CXX_DEP_DECLTYPE:
case NODECL_MUL:
case NODECL_VECTOR_LOAD:
case NODECL_CXX_SIZEOF:
case NODECL_VECTOR_PROMOTION:
case NODECL_VECTOR_GREATER_THAN:
case NODECL_GREATER_THAN:
case NODECL_BITWISE_XOR_ASSIGNMENT:
case NODECL_VECTOR_BITWISE_SHR:
case NODECL_BITWISE_SHL_ASSIGNMENT:
case NODECL_C99_INDEX_DESIGNATOR:
case NODECL_VECTOR_BITWISE_OR:
case NODECL_POSTDECREMENT:
case NODECL_CONTEXT:
case NODECL_VECTOR_BITWISE_SHL:
case NODECL_OMP_SS_TASK_CALL:
case NODECL_VECTOR_CAST:
case NODECL_DELETE_ARRAY:
case NODECL_ANALYSIS_EMPTY_RANGE:
case NODECL_ANALYSIS_PHI:
case NODECL_CXX_ALIGNAS:
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
case NODECL_VIRTUAL_FUNCTION_CALL:
case NODECL_VECTOR_BITWISE_AND:
case NODECL_MASK_LITERAL:
case NODECL_VECTOR_DIV:
case NODECL_BITWISE_OR_ASSIGNMENT:
case NODECL_VECTOR_RCP:
case NODECL_CXX_VALUE_PACK:
case NODECL_VECTOR_MASK_XOR:
case NODECL_VECTOR_MASK_ASSIGNMENT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_VECTOR_FMMINUS:
case NODECL_GREATER_OR_EQUAL_THAN:
case NODECL_VECTOR_GREATER_OR_EQUAL_THAN:
case NODECL_POINTER_TO_MEMBER:
case NODECL_VECTOR_MASK_CONVERSION:
case NODECL_VECTOR_LOOP:
case NODECL_VECTOR_ASSIGNMENT:
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
case NODECL_VECTOR_MOD:
case NODECL_VECTOR_REDUCTION_ADD:
case NODECL_BITWISE_SHR:
case NODECL_VECTOR_ADD:
case NODECL_FLOATING_LITERAL:
case NODECL_GCC_ASM_SPEC:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_VECTOR_LOGICAL_OR:
case NODECL_OBJECT_INIT:
case NODECL_VECTOR_ALIGN_RIGHT:
case NODECL_VECTOR_NEG:
case NODECL_BITWISE_SHL:
case NODECL_ASSIGNMENT:
case NODECL_MUL_ASSIGNMENT:
case NODECL_VECTOR_DIFFERENT:
case NODECL_BITWISE_SHR_ASSIGNMENT:
case NODECL_VECTOR_RSQRT:
case NODECL_FORTRAN_EQUIVALENCE:
case NODECL_VECTOR_MUL:
case NODECL_CUDA_KERNEL_CALL:
case NODECL_VECTOR_LOGICAL_NOT:
case NODECL_CXX_EXPLICIT_TYPE_CAST:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_RANGE:
case NODECL_ANALYSIS_MINIMUM:
case NODECL_VERBATIM:
case NODECL_DEREFERENCE:
case NODECL_DIV:
case NODECL_CXX_ARROW_PTR_MEMBER:
case NODECL_VECTOR_REDUCTION_MINUS:
case NODECL_VECTOR_SQRT:
case NODECL_DIV_ASSIGNMENT:
case NODECL_CXX_BRACED_INITIALIZER:
case NODECL_MOD:
case NODECL_VECTOR_REDUCTION_MUL:
case NODECL_PSEUDO_DESTRUCTOR_NAME:
case NODECL_CXX_DEP_NEW:
case NODECL_VECTOR_MASK_AND_2_NOT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_VECTOR_FUNCTION_CALL:
case NODECL_ERR_EXPR:
case NODECL_NOEXCEPT_IMPLICIT_TRUE:
case NODECL_SOURCE_COMMENT:
case NODECL_FORTRAN_USE_ONLY:
case NODECL_ASM_DEFINITION:
case NODECL_VECTOR_LITERAL:
case NODECL_ALIGNOF:
case NODECL_GXX_BUILTIN_ADDRESSOF:
case NODECL_MULTI_EXPRESSION:
case NODECL_CXX_DOT_PTR_MEMBER:
case NODECL_VECTOR_LOWER_THAN:
case NODECL_PARENTHESIZED_EXPRESSION:
case NODECL_CONVERSION:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_ANALYSIS_RANGE_SUB:
case NODECL_ARITHMETIC_SHR_ASSIGNMENT:
case NODECL_INTEGER_LITERAL:
case NODECL_LOGICAL_NOT:
case NODECL_STRUCTURED_VALUE:
case NODECL_FORTRAN_DATA:
case NODECL_CXX_DEP_FUNCTION_CALL:
case NODECL_CXX_NOEXCEPT:
case NODECL_PREDECREMENT:
case NODECL_VECTOR_PREFETCH:
case NODECL_COMMA:
case NODECL_REAL_PART:
case NODECL_VECTOR_MASK_AND_1_NOT:
case NODECL_PLUS:
case NODECL_BITWISE_AND_ASSIGNMENT:
case NODECL_CXX_ARROW:
{
nodecl_check_expression(n);
break;
}
case NODECL_DEFAULT_ARGUMENT:
{
nodecl_check_default_arg(n);
break;
}
case NODECL_FORTRAN_ACTUAL_ARGUMENT:
case NODECL_FORTRAN_NOT_PRESENT:
{
nodecl_check_fortran_actual_argument(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_data_sharings_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_FIRSTPRIVATE:
{
nodecl_check_OPEN_M_P_FIRSTPRIVATE(n);
break;
}
case NODECL_OPEN_M_P_LASTPRIVATE:
{
nodecl_check_OPEN_M_P_LASTPRIVATE(n);
break;
}
case NODECL_OPEN_M_P_FIRST_LASTPRIVATE:
{
nodecl_check_OPEN_M_P_FIRST_LASTPRIVATE(n);
break;
}
case NODECL_OPEN_M_P_SHARED:
{
nodecl_check_OPEN_M_P_SHARED(n);
break;
}
case NODECL_OPEN_M_P_THREADPRIVATE:
{
nodecl_check_OPEN_M_P_THREADPRIVATE(n);
break;
}
case NODECL_OPEN_M_P_PRIVATE:
{
nodecl_check_OPEN_M_P_PRIVATE(n);
break;
}
case NODECL_OPEN_M_P_AUTO:
{
nodecl_check_OPEN_M_P_AUTO(n);
break;
}
case NODECL_OPEN_M_P_REDUCTION:
{
nodecl_check_OPEN_M_P_REDUCTION(n);
break;
}
case NODECL_OPEN_M_P_TASK_REDUCTION:
{
nodecl_check_OPEN_M_P_TASK_REDUCTION(n);
break;
}
case NODECL_OPEN_M_P_IN_REDUCTION:
{
nodecl_check_OPEN_M_P_IN_REDUCTION(n);
break;
}
case NODECL_OPEN_M_P_PRIVATE_INIT:
{
nodecl_check_OPEN_M_P_PRIVATE_INIT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_fortran_only_statements(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FORTRAN_ALLOCATE_STATEMENT:
{
nodecl_check_FORTRAN_ALLOCATE_STATEMENT(n);
break;
}
case NODECL_FORTRAN_ARITHMETIC_IF_STATEMENT:
{
nodecl_check_FORTRAN_ARITHMETIC_IF_STATEMENT(n);
break;
}
case NODECL_FORTRAN_ASSIGNED_GOTO_STATEMENT:
{
nodecl_check_FORTRAN_ASSIGNED_GOTO_STATEMENT(n);
break;
}
case NODECL_FORTRAN_OPEN_STATEMENT:
{
nodecl_check_FORTRAN_OPEN_STATEMENT(n);
break;
}
case NODECL_FORTRAN_CLOSE_STATEMENT:
{
nodecl_check_FORTRAN_CLOSE_STATEMENT(n);
break;
}
case NODECL_FORTRAN_COMPUTED_GOTO_STATEMENT:
{
nodecl_check_FORTRAN_COMPUTED_GOTO_STATEMENT(n);
break;
}
case NODECL_FORTRAN_ALTERNATE_RETURN_STATEMENT:
{
nodecl_check_FORTRAN_ALTERNATE_RETURN_STATEMENT(n);
break;
}
case NODECL_FORTRAN_DEALLOCATE_STATEMENT:
{
nodecl_check_FORTRAN_DEALLOCATE_STATEMENT(n);
break;
}
case NODECL_FORTRAN_IO_STATEMENT:
{
nodecl_check_FORTRAN_IO_STATEMENT(n);
break;
}
case NODECL_FORTRAN_LABEL_ASSIGN_STATEMENT:
{
nodecl_check_FORTRAN_LABEL_ASSIGN_STATEMENT(n);
break;
}
case NODECL_FORTRAN_NULLIFY_STATEMENT:
{
nodecl_check_FORTRAN_NULLIFY_STATEMENT(n);
break;
}
case NODECL_FORTRAN_PRINT_STATEMENT:
{
nodecl_check_FORTRAN_PRINT_STATEMENT(n);
break;
}
case NODECL_FORTRAN_READ_STATEMENT:
{
nodecl_check_FORTRAN_READ_STATEMENT(n);
break;
}
case NODECL_FORTRAN_WRITE_STATEMENT:
{
nodecl_check_FORTRAN_WRITE_STATEMENT(n);
break;
}
case NODECL_FORTRAN_STOP_STATEMENT:
{
nodecl_check_FORTRAN_STOP_STATEMENT(n);
break;
}
case NODECL_FORTRAN_PAUSE_STATEMENT:
{
nodecl_check_FORTRAN_PAUSE_STATEMENT(n);
break;
}
case NODECL_FORTRAN_ENTRY_STATEMENT:
{
nodecl_check_FORTRAN_ENTRY_STATEMENT(n);
break;
}
case NODECL_FORTRAN_WHERE:
{
nodecl_check_FORTRAN_WHERE(n);
break;
}
case NODECL_FORTRAN_FORALL:
{
nodecl_check_FORTRAN_FORALL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_any(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_device_constructs(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_TARGET_DATA:
{
nodecl_check_OPEN_M_P_TARGET_DATA(n);
break;
}
case NODECL_OPEN_M_P_TARGET:
{
nodecl_check_OPEN_M_P_TARGET(n);
break;
}
case NODECL_OPEN_M_P_TARGET_UPDATE:
{
nodecl_check_OPEN_M_P_TARGET_UPDATE(n);
break;
}
case NODECL_OPEN_M_P_TEAMS:
{
nodecl_check_OPEN_M_P_TEAMS(n);
break;
}
case NODECL_OPEN_M_P_DISTRIBUTE:
{
nodecl_check_OPEN_M_P_DISTRIBUTE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_mask_expressions(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_MASK_LITERAL:
{
nodecl_check_MASK_LITERAL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_checkpoint_directives(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CHECKPOINT_STORE:
{
nodecl_check_CHECKPOINT_STORE(n);
break;
}
case NODECL_CHECKPOINT_LOAD:
{
nodecl_check_CHECKPOINT_LOAD(n);
break;
}
case NODECL_CHECKPOINT_INIT:
{
nodecl_check_CHECKPOINT_INIT(n);
break;
}
case NODECL_CHECKPOINT_SHUTDOWN:
{
nodecl_check_CHECKPOINT_SHUTDOWN(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_checkpoint_environment(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CHECKPOINT_DATA:
{
nodecl_check_CHECKPOINT_DATA(n);
break;
}
case NODECL_CHECKPOINT_LEVEL:
{
nodecl_check_CHECKPOINT_LEVEL(n);
break;
}
case NODECL_CHECKPOINT_ID:
{
nodecl_check_CHECKPOINT_ID(n);
break;
}
case NODECL_CHECKPOINT_COMM:
{
nodecl_check_CHECKPOINT_COMM(n);
break;
}
case NODECL_CHECKPOINT_IF:
{
nodecl_check_CHECKPOINT_IF(n);
break;
}
case NODECL_CHECKPOINT_KIND:
{
nodecl_check_CHECKPOINT_KIND(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_source_comment(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_SOURCE_COMMENT:
{
nodecl_check_SOURCE_COMMENT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_ompss_device_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OMP_SS_TARGET:
{
nodecl_check_OMP_SS_TARGET(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_function_code(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FUNCTION_CODE:
{
nodecl_check_regular_function_code(n);
break;
}
case NODECL_TEMPLATE_FUNCTION_CODE:
{
nodecl_check_template_function_code(n);
break;
}
case NODECL_VECTOR_FUNCTION_CODE:
{
nodecl_check_vector_regular_function_code(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_range_loop_control(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_RANGE_LOOP_CONTROL:
{
nodecl_check_RANGE_LOOP_CONTROL(n);
break;
}
case NODECL_ITERATOR_LOOP_CONTROL:
{
nodecl_check_ITERATOR_LOOP_CONTROL(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_critical_info(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_CRITICAL_NAME:
{
nodecl_check_OPEN_M_P_CRITICAL_NAME(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_cxx_simple_name(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_DEP_NAME_SIMPLE:
{
nodecl_check_CXX_DEP_NAME_SIMPLE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_analysis_exec_environment(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_ANALYSIS_UPPER_EXPOSED:
{
nodecl_check_ANALYSIS_UPPER_EXPOSED(n);
break;
}
case NODECL_ANALYSIS_DEFINED:
{
nodecl_check_ANALYSIS_DEFINED(n);
break;
}
case NODECL_ANALYSIS_UNDEFINED:
{
nodecl_check_ANALYSIS_UNDEFINED(n);
break;
}
case NODECL_ANALYSIS_LIVE_IN:
{
nodecl_check_ANALYSIS_LIVE_IN(n);
break;
}
case NODECL_ANALYSIS_LIVE_OUT:
{
nodecl_check_ANALYSIS_LIVE_OUT(n);
break;
}
case NODECL_ANALYSIS_DEAD:
{
nodecl_check_ANALYSIS_DEAD(n);
break;
}
case NODECL_ANALYSIS_REACHING_DEFINITION_IN:
{
nodecl_check_ANALYSIS_REACHING_DEFINITION_IN(n);
break;
}
case NODECL_ANALYSIS_REACHING_DEFINITION_OUT:
{
nodecl_check_ANALYSIS_REACHING_DEFINITION_OUT(n);
break;
}
case NODECL_ANALYSIS_INDUCTION_VARIABLE:
{
nodecl_check_ANALYSIS_INDUCTION_VARIABLE(n);
break;
}
case NODECL_ANALYSIS_AUTO_SCOPE_FIRSTPRIVATE:
{
nodecl_check_ANALYSIS_AUTO_SCOPE_FIRSTPRIVATE(n);
break;
}
case NODECL_ANALYSIS_AUTO_SCOPE_PRIVATE:
{
nodecl_check_ANALYSIS_AUTO_SCOPE_PRIVATE(n);
break;
}
case NODECL_ANALYSIS_AUTO_SCOPE_SHARED:
{
nodecl_check_ANALYSIS_AUTO_SCOPE_SHARED(n);
break;
}
case NODECL_ANALYSIS_RANGE:
{
nodecl_check_ANALYSIS_RANGE(n);
break;
}
case NODECL_ANALYSIS_CORRECTNESS_AUTO_STORAGE:
{
nodecl_check_ANALYSIS_CORRECTNESS_AUTO_STORAGE(n);
break;
}
case NODECL_ANALYSIS_CORRECTNESS_DEAD:
{
nodecl_check_ANALYSIS_CORRECTNESS_DEAD(n);
break;
}
case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_FP:
{
nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_FP(n);
break;
}
case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_P:
{
nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_P(n);
break;
}
case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_IN:
{
nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_IN(n);
break;
}
case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_OUT:
{
nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_OUT(n);
break;
}
case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_IN_POINTED:
{
nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_IN_POINTED(n);
break;
}
case NODECL_ANALYSIS_CORRECTNESS_INCOHERENT_OUT_POINTED:
{
nodecl_check_ANALYSIS_CORRECTNESS_INCOHERENT_OUT_POINTED(n);
break;
}
case NODECL_ANALYSIS_CORRECTNESS_RACE:
{
nodecl_check_ANALYSIS_CORRECTNESS_RACE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_vector_regular_function_code(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_VECTOR_FUNCTION_CODE:
{
nodecl_check_VECTOR_FUNCTION_CODE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_compatibility(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_UNKNOWN_PRAGMA:
{
nodecl_check_unknown_pragma(n);
break;
}
case NODECL_SOURCE_COMMENT:
{
nodecl_check_source_comment(n);
break;
}
case NODECL_PREPROCESSOR_LINE:
{
nodecl_check_preprocessor_text(n);
break;
}
case NODECL_VERBATIM:
{
nodecl_check_verbatim(n);
break;
}
case NODECL_ASM_DEFINITION:
{
nodecl_check_asm_definition(n);
break;
}
case NODECL_GCC_ASM_DEFINITION:
{
nodecl_check_gcc_asm_definition(n);
break;
}
case NODECL_GCC_ASM_SPEC:
{
nodecl_check_gcc_asm_spec(n);
break;
}
case NODECL_UPC_SYNC_STATEMENT:
{
nodecl_check_upc_sync_statement(n);
break;
}
case NODECL_GCC_BUILTIN_VA_ARG:
{
nodecl_check_gcc_builtin_va_arg(n);
break;
}
case NODECL_GXX_TRAIT:
{
nodecl_check_gxx_traits(n);
break;
}
case NODECL_TEXT:
{
nodecl_check_text(n);
break;
}
case NODECL_INTEL_ASSUME:
case NODECL_INTEL_ASSUME_ALIGNED:
{
nodecl_check_intel_expressions(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_upc_sync_statement(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_UPC_SYNC_STATEMENT:
{
nodecl_check_UPC_SYNC_STATEMENT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_multi_expr_range_expression(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_RANGE:
{
nodecl_check_range_expression(n);
break;
}
case NODECL_RANGE_DISCRETE:
{
nodecl_check_range_discrete(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_cxx_dependent_name(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
{
nodecl_check_CXX_DEP_GLOBAL_NAME_NESTED(n);
break;
}
case NODECL_CXX_DEP_NAME_NESTED:
{
nodecl_check_CXX_DEP_NAME_NESTED(n);
break;
}
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_CXX_DEP_DECLTYPE:
{
nodecl_check_cxx_atom_dependent_name(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_unknown_pragma(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_UNKNOWN_PRAGMA:
{
nodecl_check_UNKNOWN_PRAGMA(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_initializer_item(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_FIELD_DESIGNATOR:
{
nodecl_check_FIELD_DESIGNATOR(n);
break;
}
case NODECL_INDEX_DESIGNATOR:
{
nodecl_check_INDEX_DESIGNATOR(n);
break;
}
case NODECL_ARRAY_SUBSCRIPT:
case NODECL_DELETE:
case NODECL_C99_FIELD_DESIGNATOR:
case NODECL_SYMBOL:
case NODECL_VECTOR_BITWISE_XOR:
case NODECL_VECTOR_SUBSCRIPT:
case NODECL_PREPROCESSOR_LINE:
case NODECL_FUNCTION_CALL:
case NODECL_LOGICAL_AND:
case NODECL_CXX_EQUAL_INITIALIZER:
case NODECL_OMP_SS_TASK_EXPRESSION:
case NODECL_CXX_INITIALIZER:
case NODECL_VECTOR_CONDITIONAL_EXPRESSION:
case NODECL_IMAG_PART:
case NODECL_VECTOR_FMADD:
case NODECL_ANALYSIS_MAXIMUM:
case NODECL_SHAPING:
case NODECL_THROW:
case NODECL_DUMMY:
case NODECL_VECTOR_LOWER_OR_EQUAL_THAN:
case NODECL_VECTOR_CONVERSION:
case NODECL_INTEL_ASSUME:
case NODECL_CXX_CAST:
case NODECL_ANALYSIS_RANGE_INTERSECTION:
case NODECL_CXX_DEP_NAME_NESTED:
case NODECL_NEG:
case NODECL_VECTOR_ARITHMETIC_SHR:
case NODECL_CXX_CLASS_MEMBER_ACCESS:
case NODECL_CXX_LAMBDA:
case NODECL_OFFSETOF:
case NODECL_NEW:
case NODECL_VECTOR_MASK_OR:
case NODECL_FORTRAN_BIND_C:
case NODECL_GXX_TRAIT:
case NODECL_VECTOR_SCATTER:
case NODECL_MOD_ASSIGNMENT:
case NODECL_DIFFERENT:
case NODECL_VECTOR_MASK_AND:
case NODECL_CXX_ALIGNOF:
case NODECL_LOWER_OR_EQUAL_THAN:
case NODECL_SIZEOF:
case NODECL_COMPOUND_EXPRESSION:
case NODECL_VECTOR_STORE:
case NODECL_ADD_ASSIGNMENT:
case NODECL_VECTOR_GATHER:
case NODECL_LOWER_THAN:
case NODECL_VECTOR_SINCOS:
case NODECL_BITWISE_AND:
case NODECL_LOGICAL_OR:
case NODECL_FORTRAN_BOZ_LITERAL:
case NODECL_COMPLEX_LITERAL:
case NODECL_BITWISE_XOR:
case NODECL_BITWISE_NOT:
case NODECL_MINUS:
case NODECL_MINUS_ASSIGNMENT:
case NODECL_VECTOR_LANE_ID:
case NODECL_BOOLEAN_LITERAL:
case NODECL_POWER:
case NODECL_FORTRAN_USE:
case NODECL_EQUAL:
case NODECL_CONDITIONAL_EXPRESSION:
case NODECL_CONCAT:
case NODECL_VECTOR_LOGICAL_AND:
case NODECL_CLASS_MEMBER_ACCESS:
case NODECL_REFERENCE:
case NODECL_CXX_DEP_TEMPLATE_ID:
case NODECL_VECTOR_FABS:
case NODECL_FORTRAN_HOLLERITH:
case NODECL_VLA_WILDCARD:
case NODECL_PREINCREMENT:
case NODECL_TYPEID:
case NODECL_ANALYSIS_PLUS_INFINITY:
case NODECL_OFFSET:
case NODECL_CXX_SIZEOF_PACK:
case NODECL_UNKNOWN:
case NODECL_ANALYSIS_RANGE_UNION:
case NODECL_ARITHMETIC_SHR:
case NODECL_CXX_VALUE_PACK_EXPANDED:
case NODECL_VECTOR_EQUAL:
case NODECL_ADD:
case NODECL_ANALYSIS_MINUS_INFINITY:
case NODECL_UNKNOWN_PRAGMA:
case NODECL_C99_DESIGNATED_INITIALIZER:
case NODECL_POSTINCREMENT:
case NODECL_VECTOR_MINUS:
case NODECL_VECTOR_BITWISE_NOT:
case NODECL_UPC_SYNC_STATEMENT:
case NODECL_STRING_LITERAL:
case NODECL_VECTOR_MASK_NOT:
case NODECL_BITWISE_OR:
case NODECL_CXX_POSTFIX_INITIALIZER:
case NODECL_TEXT:
case NODECL_CXX_DEP_DECLTYPE:
case NODECL_MUL:
case NODECL_VECTOR_LOAD:
case NODECL_CXX_SIZEOF:
case NODECL_VECTOR_PROMOTION:
case NODECL_VECTOR_GREATER_THAN:
case NODECL_GREATER_THAN:
case NODECL_BITWISE_XOR_ASSIGNMENT:
case NODECL_VECTOR_BITWISE_SHR:
case NODECL_BITWISE_SHL_ASSIGNMENT:
case NODECL_C99_INDEX_DESIGNATOR:
case NODECL_VECTOR_BITWISE_OR:
case NODECL_POSTDECREMENT:
case NODECL_CONTEXT:
case NODECL_VECTOR_BITWISE_SHL:
case NODECL_OMP_SS_TASK_CALL:
case NODECL_VECTOR_CAST:
case NODECL_DELETE_ARRAY:
case NODECL_ANALYSIS_EMPTY_RANGE:
case NODECL_ANALYSIS_PHI:
case NODECL_CXX_ALIGNAS:
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
case NODECL_VIRTUAL_FUNCTION_CALL:
case NODECL_VECTOR_BITWISE_AND:
case NODECL_MASK_LITERAL:
case NODECL_VECTOR_DIV:
case NODECL_BITWISE_OR_ASSIGNMENT:
case NODECL_VECTOR_RCP:
case NODECL_CXX_VALUE_PACK:
case NODECL_VECTOR_MASK_XOR:
case NODECL_VECTOR_MASK_ASSIGNMENT:
case NODECL_INTEL_ASSUME_ALIGNED:
case NODECL_VECTOR_FMMINUS:
case NODECL_GREATER_OR_EQUAL_THAN:
case NODECL_VECTOR_GREATER_OR_EQUAL_THAN:
case NODECL_POINTER_TO_MEMBER:
case NODECL_VECTOR_MASK_CONVERSION:
case NODECL_VECTOR_LOOP:
case NODECL_VECTOR_ASSIGNMENT:
case NODECL_CXX_DEP_GLOBAL_NAME_NESTED:
case NODECL_VECTOR_MOD:
case NODECL_VECTOR_REDUCTION_ADD:
case NODECL_BITWISE_SHR:
case NODECL_VECTOR_ADD:
case NODECL_FLOATING_LITERAL:
case NODECL_GCC_ASM_SPEC:
case NODECL_CXX_DEP_NAME_SIMPLE:
case NODECL_VECTOR_LOGICAL_OR:
case NODECL_OBJECT_INIT:
case NODECL_VECTOR_ALIGN_RIGHT:
case NODECL_VECTOR_NEG:
case NODECL_BITWISE_SHL:
case NODECL_ASSIGNMENT:
case NODECL_MUL_ASSIGNMENT:
case NODECL_VECTOR_DIFFERENT:
case NODECL_BITWISE_SHR_ASSIGNMENT:
case NODECL_VECTOR_RSQRT:
case NODECL_FORTRAN_EQUIVALENCE:
case NODECL_VECTOR_MUL:
case NODECL_CUDA_KERNEL_CALL:
case NODECL_VECTOR_LOGICAL_NOT:
case NODECL_CXX_EXPLICIT_TYPE_CAST:
case NODECL_CXX_DEP_NAME_CONVERSION:
case NODECL_RANGE:
case NODECL_ANALYSIS_MINIMUM:
case NODECL_VERBATIM:
case NODECL_DEREFERENCE:
case NODECL_DIV:
case NODECL_CXX_ARROW_PTR_MEMBER:
case NODECL_VECTOR_REDUCTION_MINUS:
case NODECL_VECTOR_SQRT:
case NODECL_DIV_ASSIGNMENT:
case NODECL_CXX_BRACED_INITIALIZER:
case NODECL_MOD:
case NODECL_VECTOR_REDUCTION_MUL:
case NODECL_PSEUDO_DESTRUCTOR_NAME:
case NODECL_CXX_DEP_NEW:
case NODECL_VECTOR_MASK_AND_2_NOT:
case NODECL_GCC_ASM_DEFINITION:
case NODECL_VECTOR_FUNCTION_CALL:
case NODECL_ERR_EXPR:
case NODECL_NOEXCEPT_IMPLICIT_TRUE:
case NODECL_SOURCE_COMMENT:
case NODECL_FORTRAN_USE_ONLY:
case NODECL_ASM_DEFINITION:
case NODECL_VECTOR_LITERAL:
case NODECL_ALIGNOF:
case NODECL_GXX_BUILTIN_ADDRESSOF:
case NODECL_MULTI_EXPRESSION:
case NODECL_CXX_DOT_PTR_MEMBER:
case NODECL_VECTOR_LOWER_THAN:
case NODECL_PARENTHESIZED_EXPRESSION:
case NODECL_CONVERSION:
case NODECL_GCC_BUILTIN_VA_ARG:
case NODECL_ANALYSIS_RANGE_SUB:
case NODECL_ARITHMETIC_SHR_ASSIGNMENT:
case NODECL_INTEGER_LITERAL:
case NODECL_LOGICAL_NOT:
case NODECL_STRUCTURED_VALUE:
case NODECL_FORTRAN_DATA:
case NODECL_CXX_DEP_FUNCTION_CALL:
case NODECL_CXX_NOEXCEPT:
case NODECL_PREDECREMENT:
case NODECL_VECTOR_PREFETCH:
case NODECL_COMMA:
case NODECL_REAL_PART:
case NODECL_VECTOR_MASK_AND_1_NOT:
case NODECL_PLUS:
case NODECL_BITWISE_AND_ASSIGNMENT:
case NODECL_CXX_ARROW:
{
nodecl_check_expression(n);
break;
}
case NODECL_FORTRAN_IMPLIED_DO:
{
nodecl_check_fortran_implied_do(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_preprocessor_text(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_PREPROCESSOR_LINE:
{
nodecl_check_PREPROCESSOR_LINE(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_cxx_dependent_initializer(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_INITIALIZER:
{
nodecl_check_CXX_INITIALIZER(n);
break;
}
case NODECL_CXX_BRACED_INITIALIZER:
{
nodecl_check_CXX_BRACED_INITIALIZER(n);
break;
}
case NODECL_CXX_EQUAL_INITIALIZER:
{
nodecl_check_CXX_EQUAL_INITIALIZER(n);
break;
}
case NODECL_CXX_PARENTHESIZED_INITIALIZER:
{
nodecl_check_CXX_PARENTHESIZED_INITIALIZER(n);
break;
}
case NODECL_C99_DESIGNATED_INITIALIZER:
{
nodecl_check_C99_DESIGNATED_INITIALIZER(n);
break;
}
case NODECL_C99_FIELD_DESIGNATOR:
{
nodecl_check_C99_FIELD_DESIGNATOR(n);
break;
}
case NODECL_C99_INDEX_DESIGNATOR:
{
nodecl_check_C99_INDEX_DESIGNATOR(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_cxx_pack(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_CXX_VALUE_PACK:
{
nodecl_check_CXX_VALUE_PACK(n);
break;
}
case NODECL_CXX_VALUE_PACK_EXPANDED:
{
nodecl_check_CXX_VALUE_PACK_EXPANDED(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_execution_control(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_IF:
{
nodecl_check_OPEN_M_P_IF(n);
break;
}
case NODECL_OPEN_M_P_FINAL:
{
nodecl_check_OPEN_M_P_FINAL(n);
break;
}
case NODECL_OPEN_M_P_PRIORITY:
{
nodecl_check_OPEN_M_P_PRIORITY(n);
break;
}
case NODECL_OPEN_M_P_MERGEABLE:
{
nodecl_check_OPEN_M_P_MERGEABLE(n);
break;
}
case NODECL_OPEN_M_P_UNTIED:
{
nodecl_check_OPEN_M_P_UNTIED(n);
break;
}
case NODECL_OMP_SS_WAIT:
{
nodecl_check_OMP_SS_WAIT(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_omp_reduction_item(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OPEN_M_P_REDUCTION_ITEM:
{
nodecl_check_OPEN_M_P_REDUCTION_ITEM(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
static void nodecl_check_ompss_device_info_clauses(nodecl_t n)
{
ERROR_CONDITION(nodecl_is_null(n), "Node is null", 0);
switch (nodecl_get_kind(n))
{
case NODECL_OMP_SS_COPY_IN:
{
nodecl_check_OMP_SS_COPY_IN(n);
break;
}
case NODECL_OMP_SS_COPY_OUT:
{
nodecl_check_OMP_SS_COPY_OUT(n);
break;
}
case NODECL_OMP_SS_COPY_INOUT:
{
nodecl_check_OMP_SS_COPY_INOUT(n);
break;
}
case NODECL_OMP_SS_N_D_RANGE:
{
nodecl_check_OMP_SS_N_D_RANGE(n);
break;
}
case NODECL_OMP_SS_SH_MEM:
{
nodecl_check_OMP_SS_SH_MEM(n);
break;
}
case NODECL_OMP_SS_FILE:
{
nodecl_check_OMP_SS_FILE(n);
break;
}
case NODECL_OMP_SS_NAME:
{
nodecl_check_OMP_SS_NAME(n);
break;
}
case NODECL_OMP_SS_ONTO:
{
nodecl_check_OMP_SS_ONTO(n);
break;
}
case NODECL_OMP_SS_IMPLEMENTS:
{
nodecl_check_OMP_SS_IMPLEMENTS(n);
break;
}
default:
{
internal_error("Node of kind %s not valid", ast_print_node_type(nodecl_get_kind(n)));
break;
}
}
}
void nodecl_check_tree(AST a)
{
nodecl_check_nodecl(_nodecl_wrap(a));
}
