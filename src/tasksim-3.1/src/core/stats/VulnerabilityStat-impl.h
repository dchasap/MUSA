/*
 * Copyright - Barcelona Supercomputing Center.
 * All rights reserved.
 *
 * Redistribution in source and binary forms, with or without
 * modification, is not permitted.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#ifndef STATS_VULNERABILITYSTAT_IMPL_H_
#define STATS_VULNERABILITYSTAT_IMPL_H_

#include <cstdlib>

#include "VulnerabilityStat.h"
#include "VulnerabilityTime.h"
#include "VulnerabilityAccessCount.h"
#include "VulnerabilityHistogram.h"
#include "core/engine/Config.h"

#ifndef STATS_VULNERABILITYSTAT_H_
#error Include header before impl
#endif

namespace sim {
namespace stats {

template <typename T>
inline
std::unique_ptr<VulnerabilityStat> VulnerabilityStat::create_from_config(const T &obj, const sim::engine::Config &config)
{
	VulnerabilityStat *vuln_module(nullptr);

	if (config.key_exists("vulnerability_stat")) {
		std::string type = config.get_value<std::string>("vulnerability_stat");

		unsigned ignored_lsb = config.get_value_with_default<unsigned>("vulnerability_ignoredlsb", 3);
		engine::addr_t granularity = config.get_value_with_default<engine::cycles_t>("vulnerability_grain", 4096);
		engine::cycles_t period = config.get_value_with_default<engine::cycles_t>("vulnerability_period", 100000000);
		std::string range_map = config.get_value_with_default<std::string>("vulnerability_ranges", std::string());

		if (type.compare("time") == 0) {
			vuln_module = new sim::stats::VulnerabilityTime(obj, "Vulnerable Time per Memory Address", ignored_lsb,
															period, granularity, range_map);
		} else if (type.compare("access") == 0) {
			vuln_module = new sim::stats::VulnerabilityAccessCount(obj, "Vulnerability Access Count", ignored_lsb,
																   period, granularity, range_map);
		} else if (type.compare("histogram") == 0) {
			unsigned bins = config.get_value_with_default<unsigned>("vulnerability_bins", 100);
			vuln_module = new sim::stats::VulnerabilityHistogram(obj, "Vulnerability Histogram", ignored_lsb,
															     period, granularity, range_map, bins);
		} else if (type.compare("none") != 0) {
			std::cerr << "Error: unrecognized vuln_stat_type value " << type << std::endl;
		}
	}

	return std::unique_ptr<VulnerabilityStat>(vuln_module);
}

}
}

#endif // STATS_VULNERABILITYSTAT_IMPL_H_

