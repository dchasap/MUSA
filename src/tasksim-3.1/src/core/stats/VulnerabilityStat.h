/*
 * Copyright - Barcelona Supercomputing Center.
 * All rights reserved.
 *
 * Redistribution in source and binary forms, with or without
 * modification, is not permitted.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#ifndef STATS_VULNERABILITYSTAT_H_
#define STATS_VULNERABILITYSTAT_H_

#include <map>

#include "Stat.h"
#include "core/utils/RangeMap.h"
#include "core/logic/coherence/single/Message.h"

#include "core/utils/Log.h"

namespace sim {
namespace stats {

using sim::utils::Log;


class VulnerabilityStat: public Stat {
protected:

    typedef struct {
        engine::cycles_t last, safe, fill;
    } address_stats_t;

    typedef struct {
        uint64_t nterms;
        double mean;
    } average_t;

    utils::RangeMap range_map_;
    engine::addr_t address_mask_, stat_mask_;
    engine::cycles_t stat_period_, end_time_;

    template<typename T>
    VulnerabilityStat(const T &obj, const std::string &name, unsigned num_bits_ignored, engine::cycles_t stat_period,
                      engine::addr_t stat_granularity, const std::string& addr_range_map_file) :
        Stat(obj, name),
        range_map_(),
        address_mask_(~((1ULL << num_bits_ignored) - 1)),
        stat_mask_(~(stat_granularity - 1)),
        stat_period_(stat_period)
    {
        if (addr_range_map_file.empty()) {
            Log::warning() << "No file was specified for address range to name mapping, "
                           << "no per-data-structure classification available";
            range_map_.setup_catch_all();
        } else {
            range_map_.load_range_map(addr_range_map_file, num_bits_ignored);
        }


        // stats granularity should be a power of 2, and bigger (or equal) to 2^num_bits_ignored
        assert(stat_granularity && stat_granularity == 1ULL << (ffs(stat_granularity) - 1));
        assert((stat_mask_ & address_mask_) == stat_mask_);
    }

public:
    ~VulnerabilityStat() {}

    virtual void extrapolate(uint64_t, uint64_t) { std::abort(); }
    virtual void mem_access(engine::cycles_t, sim::logic::coherence::single::Request&) = 0;
    virtual void finalize(engine::cycles_t) = 0;

    template <typename T>
    static
    std::unique_ptr<VulnerabilityStat> create_from_config(const T &obj, const sim::engine::Config &config);
};


}
}

// Include child classes before factory function
#include "VulnerabilityTime.h"
#include "VulnerabilityAccessCount.h"
#include "VulnerabilityHistogram.h"

#include "VulnerabilityStat-impl.h"


#endif // STATS_VULNERABILITYSTAT_H_

